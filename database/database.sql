/******************************************************************************/
/***          Generated by IBExpert 2012.02.06 04.10.2015 18:51:23          ***/
/******************************************************************************/

SET SQL DIALECT 3;

SET NAMES WIN1251;

CREATE DATABASE 'LOCALHOST:C:\Projects\Zawuch\zawuch.FDB'
USER 'SYSDBA' PASSWORD 'masterkey'
PAGE_SIZE 4096
DEFAULT CHARACTER SET WIN1251 COLLATION WIN1251;



/******************************************************************************/
/***                         User Defined Functions                         ***/
/******************************************************************************/

DECLARE EXTERNAL FUNCTION "ABS"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_abs' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "ACOS"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_acos' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION ADDDAY
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addDay' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDHOUR
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addHour' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDMILLISECOND
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addMilliSecond' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDMINUTE
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addMinute' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDMONTH
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addMonth' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDSECOND
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addSecond' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDWEEK
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addWeek' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION ADDYEAR
    TIMESTAMP,
    INTEGER
    RETURNS TIMESTAMP
    ENTRY_POINT 'addYear' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION "ASCII_CHAR"
    INTEGER
    RETURNS CSTRING(1) FREE_IT
    ENTRY_POINT 'IB_UDF_ascii_char' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "ASCII_VAL"
    CHAR(1)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_ascii_val' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "ASIN"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_asin' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "ATAN"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_atan' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "ATAN2"
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_atan2' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "BIN_AND"
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_bin_and' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "BIN_OR"
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_bin_or' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "BIN_XOR"
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_bin_xor' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "CEILING"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_ceiling' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "COS"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_cos' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "COSH"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_cosh' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "COT"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_cot' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION DIV
    INTEGER,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_div' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION DNULLIF
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR
    RETURNS DOUBLE PRECISION BY DESCRIPTOR
    ENTRY_POINT 'dNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION DNVL
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR
    RETURNS DOUBLE PRECISION BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION DOW
    TIMESTAMP,
    VARCHAR(15)
    RETURNS PARAMETER 2
    ENTRY_POINT 'DOW' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION DPOWER
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'power' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION "FLOOR"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_floor' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION GETEXACTTIMESTAMP
    TIMESTAMP
    RETURNS PARAMETER 1
    ENTRY_POINT 'getExactTimestamp' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64NULLIF
    NUMERIC(18,4) BY DESCRIPTOR,
    NUMERIC(18,4) BY DESCRIPTOR
    RETURNS NUMERIC(18,4) BY DESCRIPTOR
    ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64NVL
    NUMERIC(18,0) BY DESCRIPTOR,
    NUMERIC(18,0) BY DESCRIPTOR
    RETURNS NUMERIC(18,0) BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64ROUND
    NUMERIC(18,4) BY DESCRIPTOR,
    NUMERIC(18,4) BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbround' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION I64TRUNCATE
    NUMERIC(18,0) BY DESCRIPTOR,
    NUMERIC(18,0) BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION INULLIF
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS INTEGER BY DESCRIPTOR
    ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION INVL
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS INTEGER BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION "LN"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_ln' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "LOG"
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_log' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "LOG10"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_log10' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "LOWER"
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_lower' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "LPAD"
    CSTRING(255),
    INTEGER,
    CSTRING(1)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION LTRIM
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_ltrim' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "MOD"
    INTEGER,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_mod' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "PI"

    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_pi' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "RAND"

    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_rand' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "ROUND"
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbround' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION "RPAD"
    CSTRING(255),
    INTEGER,
    CSTRING(1)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_rpad' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION RTRIM
    CSTRING(255)
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_rtrim' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SDOW
    TIMESTAMP,
    VARCHAR(5)
    RETURNS PARAMETER 2
    ENTRY_POINT 'SDOW' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION "SIGN"
    DOUBLE PRECISION
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_sign' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "SIN"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_sin' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "SINH"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_sinh' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SNULLIF
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'sNullIf' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION SNVL
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR,
    VARCHAR(100) BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'sNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION "SQRT"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_sqrt' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SRIGHT
    VARCHAR(100) BY DESCRIPTOR,
    SMALLINT,
    VARCHAR(100) BY DESCRIPTOR
    RETURNS PARAMETER 3
    ENTRY_POINT 'right' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION STRING2BLOB
    VARCHAR(300) BY DESCRIPTOR,
    BLOB
    RETURNS PARAMETER 2
    ENTRY_POINT 'string2blob' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION STRLEN
    CSTRING(32767)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_strlen' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SUBSTR
    CSTRING(255),
    SMALLINT,
    SMALLINT
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_substr' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SUBSTRLEN
    CSTRING(255),
    SMALLINT,
    SMALLINT
    RETURNS CSTRING(255) FREE_IT
    ENTRY_POINT 'IB_UDF_substrlen' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "TAN"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_tan' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION "TANH"
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'IB_UDF_tanh' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION TRUNCATE
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS PARAMETER 2
    ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf';




/******************************************************************************/
/***                                Domains                                 ***/
/******************************************************************************/

CREATE DOMAIN BLOB_TYPE AS
BLOB SUB_TYPE 2 SEGMENT SIZE 100;

CREATE DOMAIN BOOLEAN_TYPE AS
BOOLEAN;

CREATE DOMAIN BYTE_TYPE AS
CHAR(1);

CREATE DOMAIN CODE_TYPE AS
INTEGER
DEFAULT 000;

CREATE DOMAIN DATETIME_TYPE AS
TIMESTAMP;

CREATE DOMAIN DATE_TYPE AS
DATE;

CREATE DOMAIN DOUBLE_PREC_TYPE AS
DOUBLE PRECISION;

CREATE DOMAIN D_FK_TYPE AS
INTEGER;

CREATE DOMAIN D_MONEY AS
NUMERIC(15,2);

CREATE DOMAIN FLOAT_TYPE AS
FLOAT;

CREATE DOMAIN ID_TYPE AS
INTEGER
NOT NULL;

CREATE DOMAIN INFO_TYPE AS
VARCHAR(255);

CREATE DOMAIN INTEGER_ARRAY30_TYPE AS
INTEGER [1:30];

CREATE DOMAIN INTEGER_TYPE AS
INTEGER
DEFAULT 0;

CREATE DOMAIN LONG_TEXT_TYPE AS
VARCHAR(3000);

CREATE DOMAIN MONEY_TYPE AS
DOUBLE PRECISION
DEFAULT 0.00;

CREATE DOMAIN NAME_TYPE AS
VARCHAR(150);

CREATE DOMAIN NAME_TYPE_SIZE5 AS
VARCHAR(5);

CREATE DOMAIN SMALLINT_ARRAY30_TYPE AS
SMALLINT [1:30];

CREATE DOMAIN SMALLINT_TYPE AS
SMALLINT
DEFAULT 0;

CREATE DOMAIN TEXT_TYPE AS
VARCHAR(256);

CREATE DOMAIN TIME_TYPE AS
TIME
DEFAULT 0.00;



/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR GEN_CALC_GROUP;
SET GENERATOR GEN_CALC_GROUP TO 13;

CREATE GENERATOR GEN_CALC_GROUP_SUBJECT;
SET GENERATOR GEN_CALC_GROUP_SUBJECT TO 169;

CREATE GENERATOR GEN_CALC_INDIVIDUAL;
SET GENERATOR GEN_CALC_INDIVIDUAL TO 19;

CREATE GENERATOR GEN_CALC_INDIVIDUAL_SUBJECT;
SET GENERATOR GEN_CALC_INDIVIDUAL_SUBJECT TO 215;

CREATE GENERATOR GEN_CALC_PACK;
SET GENERATOR GEN_CALC_PACK TO 4;

CREATE GENERATOR GEN_COMMON;
SET GENERATOR GEN_COMMON TO 299;

CREATE GENERATOR GEN_CURREC_ID;
SET GENERATOR GEN_CURREC_ID TO 2;

CREATE GENERATOR GEN_CURRICULUM_ID;
SET GENERATOR GEN_CURRICULUM_ID TO 40;

CREATE GENERATOR GEN_DEPARTMENT_ID;
SET GENERATOR GEN_DEPARTMENT_ID TO 47;

CREATE GENERATOR GEN_EDUCATION_ID;
SET GENERATOR GEN_EDUCATION_ID TO 2;

CREATE GENERATOR GEN_FILIAL_ID;
SET GENERATOR GEN_FILIAL_ID TO 11;

CREATE GENERATOR GEN_GROUPING_ID;
SET GENERATOR GEN_GROUPING_ID TO 16;

CREATE GENERATOR GEN_GROUPING_SUBJ_ID;
SET GENERATOR GEN_GROUPING_SUBJ_ID TO 0;

CREATE GENERATOR GEN_LEARN_TIME_GRID;
SET GENERATOR GEN_LEARN_TIME_GRID TO 4;

CREATE GENERATOR GEN_OBJECT_CATEGORY_KIND_ID;
SET GENERATOR GEN_OBJECT_CATEGORY_KIND_ID TO 0;

CREATE GENERATOR GEN_OBJECT_KIND_ID;
SET GENERATOR GEN_OBJECT_KIND_ID TO 0;

CREATE GENERATOR GEN_OBJECT_NOTE_KIND_ID;
SET GENERATOR GEN_OBJECT_NOTE_KIND_ID TO 0;

CREATE GENERATOR GEN_OBJ_CAT_GROUP_ID;
SET GENERATOR GEN_OBJ_CAT_GROUP_ID TO 0;

CREATE GENERATOR GEN_OBJ_CAT_KIND_ID;
SET GENERATOR GEN_OBJ_CAT_KIND_ID TO 0;

CREATE GENERATOR GEN_OBJ_NOTE_ID;
SET GENERATOR GEN_OBJ_NOTE_ID TO 0;

CREATE GENERATOR GEN_POST_ID;
SET GENERATOR GEN_POST_ID TO 3;

CREATE GENERATOR GEN_REPORT_PARAM_ID;
SET GENERATOR GEN_REPORT_PARAM_ID TO 11;

CREATE GENERATOR GEN_REP_TAB;
SET GENERATOR GEN_REP_TAB TO 7;

CREATE GENERATOR GEN_SEX_ID;
SET GENERATOR GEN_SEX_ID TO 0;

CREATE GENERATOR GEN_SPECIALIZATION_ID;
SET GENERATOR GEN_SPECIALIZATION_ID TO 150;

CREATE GENERATOR GEN_STUDENT_FILTER_ID;
SET GENERATOR GEN_STUDENT_FILTER_ID TO 1;

CREATE GENERATOR GEN_STUDENT_ID;
SET GENERATOR GEN_STUDENT_ID TO 2982;

CREATE GENERATOR GEN_STUDENT_PLAN_ID;
SET GENERATOR GEN_STUDENT_PLAN_ID TO 0;

CREATE GENERATOR GEN_SUBJECT_ID;
SET GENERATOR GEN_SUBJECT_ID TO 116;

CREATE GENERATOR GEN_TARIFFICARION_ID;
SET GENERATOR GEN_TARIFFICARION_ID TO 0;

CREATE GENERATOR GEN_TEACHER_ADDINGS_ID;
SET GENERATOR GEN_TEACHER_ADDINGS_ID TO 4;

CREATE GENERATOR GEN_TEACHER_CAT_ID;
SET GENERATOR GEN_TEACHER_CAT_ID TO 0;

CREATE GENERATOR GEN_TEACHER_CAT_KIND_ID;
SET GENERATOR GEN_TEACHER_CAT_KIND_ID TO 0;

CREATE GENERATOR GEN_TEACHER_FILTER_ID;
SET GENERATOR GEN_TEACHER_FILTER_ID TO 1;

CREATE GENERATOR GEN_TEACHER_ID;
SET GENERATOR GEN_TEACHER_ID TO 336;

CREATE GENERATOR GEN_TEACHER_NOTE_ID;
SET GENERATOR GEN_TEACHER_NOTE_ID TO 0;

CREATE GENERATOR GEN_TEACHER_TITLE_ID;
SET GENERATOR GEN_TEACHER_TITLE_ID TO 0;

CREATE GENERATOR GEN_TEACHER_TITLE_KIND_ID;
SET GENERATOR GEN_TEACHER_TITLE_KIND_ID TO 0;

CREATE GENERATOR IBE$REPORT_ID_GEN;
SET GENERATOR IBE$REPORT_ID_GEN TO 0;



/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION E_CALC_GROUP_NOT_EXIST 'Такого групового расчёта не существует';

CREATE EXCEPTION E_CALC_INDIVIDUAL_NOT_EXISTS 'Такой индивидуальный расчёт не существует';

CREATE EXCEPTION E_CALC_PACK_NOT_EXIST 'Пакет расчёта не существует';

CREATE EXCEPTION E_STUDENT_FILTER_SPEC 'Фильтр не существует';



SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE PROCEDURE ABSENT_TAB_PART_2
RETURNS (
    ABSENCE_CODES VARCHAR(255),
    TEACHER_TAB_NUM INTEGER,
    CLOCK_Y INTEGER,
    CLOCK_O INTEGER,
    CLOCK_C INTEGER,
    CLOCK_SWP_Y INTEGER,
    CLOCK_SWP_O INTEGER,
    CLOCK_SWP_C INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_CURR_CAT (
    CURR_ID INTEGER,
    CLASS_NUM INTEGER,
    CAT INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ADD_CURR_REC (
    CURR_ID INTEGER,
    ID INTEGER,
    SUBJ_ID INTEGER,
    GROUP_QTY INTEGER,
    R_POS INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_CURR_REC_TIME (
    CURR_ID INTEGER,
    CURR_REC_ID INTEGER,
    CLASS_NUM INTEGER,
    C_TIME DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ADD_CURRICULUM (
    INID INTEGER,
    INNAME VARCHAR(150),
    INPERIOD INTEGER,
    IN_PERIOD_FOR_PRINT VARCHAR(150))
RETURNS (
    OUTID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_DEPARTMENT (
    INID INTEGER,
    INCODE INTEGER,
    INNAME VARCHAR(30),
    INCURRICULUMID INTEGER,
    ININFO VARCHAR(50))
RETURNS (
    OUTID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_EDUCATION (
    INID INTEGER,
    INNAME VARCHAR(30))
RETURNS (
    OUTID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_FILIAL (
    INID INTEGER,
    INCODE INTEGER,
    INNAME VARCHAR(30),
    ININFO VARCHAR(50))
RETURNS (
    OUTID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_GROUPING (
    IN_ID INTEGER,
    IN_NAME VARCHAR(30),
    IN_FINANC_ID INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_GROUPING_DEPT (
    IN_GROUPING_ID INTEGER,
    IN_DEPT_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ADD_GROUPING_SUBJ (
    IN_GROUPING_ID INTEGER,
    IN_SUBJ_ID INTEGER,
    IN_SUBJ_NAME VARCHAR(30),
    IN_CODE INTEGER,
    IN_GR_QTY INTEGER,
    IN_POS INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_GROUPING_SUBJ_CURR (
    IN_GROUPING_ID INTEGER,
    IN_GR_SUBJ_ID INTEGER,
    IN_CURR_ID INTEGER,
    IN_CURR_REC_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ADD_LEARN_TIME_GRID (
    ID INTEGER,
    FINANCING_ID INTEGER,
    NAME VARCHAR(50))
RETURNS (
    OUT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_LTG_GROUPING (
    LTG_ID INTEGER,
    GROUPING_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ADD_LTG_I_SUBJ_CURR (
    LTG_ID INTEGER,
    LTG_I_SUBJ_ID INTEGER,
    CURR_ID INTEGER,
    CURR_REC_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ADD_LTG_I_SUBJECT (
    LTG_ID INTEGER,
    I_SUBJ_ID INTEGER,
    I_SUBJ_NAME VARCHAR(30),
    POS INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_POST (
    INID INTEGER,
    INNAME VARCHAR(30))
RETURNS (
    OUTID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_REP_TAB (
    ID INTEGER,
    T_ID INTEGER,
    TAB_NUM INTEGER,
    T_NAME VARCHAR(100),
    D_QTY INTEGER,
    B_Y_T DOUBLE PRECISION,
    B_O_T DOUBLE PRECISION,
    B_C_T DOUBLE PRECISION,
    S_Y_T DOUBLE PRECISION,
    S_O_T DOUBLE PRECISION,
    S_C_T DOUBLE PRECISION,
    BE_Y_T DOUBLE PRECISION,
    BE_C_T DOUBLE PRECISION,
    T_DATE DATE)
RETURNS (
    O_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_REP_TAB_EXT (
    IN_REC_TIME TIMESTAMP,
    IN_TEACHER_NAME VARCHAR(100),
    IN_TAB_MONTH DATE,
    IN_Y_T DOUBLE PRECISION,
    IN_O_T DOUBLE PRECISION,
    IN_C_T DOUBLE PRECISION,
    IN_Y_T_OOD DOUBLE PRECISION,
    IN_O_T_OOD DOUBLE PRECISION,
    IN_C_T_OOD DOUBLE PRECISION,
    IN_Y_T_FILIAL DOUBLE PRECISION,
    IN_O_T_FILIAL DOUBLE PRECISION,
    IN_C_T_FILIAL DOUBLE PRECISION)
RETURNS (
    OUT_REC_TIME TIMESTAMP)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_REP_TAB_EXT_2 (
    IN_REC_TIME TIMESTAMP,
    IN_TEACHER_NAME VARCHAR(100),
    IN_TAB_MONTH DATE,
    IN_Y_T DOUBLE PRECISION,
    IN_O_T DOUBLE PRECISION,
    IN_C_T DOUBLE PRECISION,
    IN_Y_T_OOD DOUBLE PRECISION,
    IN_O_T_OOD DOUBLE PRECISION,
    IN_C_T_OOD DOUBLE PRECISION,
    IN_Y_T_FILIAL DOUBLE PRECISION,
    IN_O_T_FILIAL DOUBLE PRECISION,
    IN_C_T_FILIAL DOUBLE PRECISION)
RETURNS (
    OUT_REC_TIME TIMESTAMP)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_REPORT_PARAM (
    IN_ID INTEGER,
    IN_NAME VARCHAR(30),
    IN_PAGE_ORIENT SMALLINT,
    IN_M_LEFT INTEGER,
    IN_M_RIGHT INTEGER,
    IN_M_TOP INTEGER,
    IN_M_BOTTOM INTEGER,
    IN_SIZES_1 VARCHAR(30),
    IN_SIZES_2 VARCHAR(30),
    IN_SIZES_3 VARCHAR(30),
    IN_QTY_1 SMALLINT,
    IN_QTY_2 SMALLINT,
    IN_QTY_3 SMALLINT)
RETURNS (
    OUT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_SPECIALIZATION (
    INID INTEGER,
    INDEPARTMENTID INTEGER,
    INCODE INTEGER,
    INNAME VARCHAR(30),
    INBUDGET DOUBLE PRECISION,
    INSELF_REPAYMENT DOUBLE PRECISION,
    ININFO VARCHAR(50))
RETURNS (
    OUTID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_STUDENT (
    INID INTEGER,
    INCODE INTEGER,
    INNAME VARCHAR(50),
    INSPECID INTEGER,
    INFILIALID INTEGER,
    INFINANCINGID SMALLINT,
    INMASTERID INTEGER,
    INCLASS SMALLINT,
    INPERCENT SMALLINT,
    INBIRTHDATE DATE,
    INENTERDATE DATE,
    INRELEASEDATE DATE,
    INRESTOREDATE DATE,
    INENTERINFO VARCHAR(30),
    INRELEASEINFO VARCHAR(30),
    INRESTOREINFO VARCHAR(30),
    INACADEMYBDATE DATE,
    INACADEMYEDATE DATE,
    INACADEMYBINFO VARCHAR(30),
    INACADEMYEINFO VARCHAR(30),
    INADDRESS VARCHAR(256),
    INTELEPHONE VARCHAR(50),
    IN_ID_SEX INTEGER)
RETURNS (
    OUTID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_STUDENT_FILTER (
    IN_ID INTEGER,
    IN_NAME VARCHAR(30),
    IN_FILIAL_ID INTEGER,
    IN_CLASS_B INTEGER,
    IN_CLASS_E INTEGER,
    IN_CURATOR_ID INTEGER,
    IN_CATEGORY INTEGER,
    IN_PERIOD INTEGER,
    IN_STATUS INTEGER,
    IN_PAY_PERCENT INTEGER,
    IN_AGE_B INTEGER,
    IN_AGE_E INTEGER,
    IN_ENTER_D_B DATE,
    IN_ENTER_D_E DATE,
    IN_RELEASE_D_B DATE,
    IN_RELEASE_D_E DATE,
    IN_RESTORE_D_B DATE,
    IN_RESTORE_D_E DATE,
    IN_ACADEMY_D_B DATE,
    IN_ACADEMY_D_E DATE,
    IN_SUBJECT_ID_1 INTEGER,
    IN_TEACHER_ID_1 INTEGER,
    IN_SUBJECT_ID_2 INTEGER,
    IN_TEACHER_ID_2 INTEGER,
    IN_SUBJ_STATE INTEGER,
    IN_FINANCING_ID INTEGER,
    IN_ID_SEX INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_STUDENT_FILTER_SPEC (
    ID_FILTER INTEGER,
    ID_SPECIALIZATION INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ADD_STUDENT_PLAN (
    IN_CURR_REC_ID INTEGER,
    IN_STUDENT_ID INTEGER,
    IN_USE SMALLINT,
    IN_TEACHER_ID INTEGER)
RETURNS (
    OUTID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_SUBJECT (
    INID INTEGER,
    INCODE INTEGER,
    INNAME VARCHAR(30),
    ININFO VARCHAR(50),
    INSHORTNAME VARCHAR(150))
RETURNS (
    OUTID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_TARIFF (
    INGRADE INTEGER,
    INSALARY DOUBLE PRECISION,
    ININFO VARCHAR(50))
RETURNS (
    OUTID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_TEACHER (
    INID INTEGER,
    INTAB_NUM INTEGER,
    INNAME VARCHAR(100),
    INFILIALID INTEGER,
    INSUBJECTID INTEGER,
    INEDUCATIONID INTEGER,
    INPOSTID INTEGER,
    INSTAGEDATE DATE,
    INBIRTHDATE DATE,
    INENTERDATE DATE,
    INRELEASEDATE DATE,
    INGRADEID INTEGER,
    INCONCERTGRADEID INTEGER,
    INDIPLOMA VARCHAR(256),
    INADDRESS VARCHAR(256),
    INTELEPHONE VARCHAR(50),
    INSTAGEY SMALLINT,
    INSTAGEM SMALLINT,
    INSTAGED SMALLINT,
    INIDGRADEADD INTEGER,
    INIDGRADECONCERTADD INTEGER,
    INIDTITLE INTEGER,
    INIDCATEGORY INTEGER,
    INIDCATEGORYCONC INTEGER,
    INCATEGORYDATE DATE,
    INCATEGORYCONCDATE DATE,
    INQUALIFICATIONID INTEGER,
    INEDUCATION2ID INTEGER,
    INQUALIFICATION2ID INTEGER,
    INDIPLOMA2 VARCHAR(256))
RETURNS (
    OUTID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_TEACHER_ADDING (
    INID INTEGER,
    INTEACHERID INTEGER,
    INNAME VARCHAR(30),
    INPERCENT SMALLINT,
    INSUM DOUBLE PRECISION)
RETURNS (
    OUTID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_TEACHER_CAT_KIND (
    P_ID INTEGER,
    P_NAME VARCHAR(150),
    P_PRINT VARCHAR(255),
    P_COEF DOUBLE PRECISION)
RETURNS (
    P_O_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_TEACHER_FILTER (
    IN_ID INTEGER,
    IN_NAME VARCHAR(30),
    IN_MAIN_SUBJ_ID INTEGER,
    IN_MAIN_GRADE INTEGER,
    IN_CONC_GRADE INTEGER,
    IN_POST_ID VARCHAR(255),
    IN_EDUCATION_ID VARCHAR(255),
    IN_FILIAL_ID INTEGER,
    IN_STATE INTEGER,
    IN_STAGE_B INTEGER,
    IN_STAGE_E INTEGER,
    IN_BIRTH_D_B DATE,
    IN_BIRTH_D_E DATE,
    IN_ENTER_D_B DATE,
    IN_ENTER_D_E DATE,
    IN_RELEASE_D_B DATE,
    IN_RELEASE_D_E DATE,
    IN_STAGE_B_M INTEGER,
    IN_STAGE_E_M INTEGER,
    IN_CAT_ID_PED VARCHAR(255),
    IN_CAT_ID_CONC VARCHAR(255),
    IN_TITLE_ID VARCHAR(255),
    IN_AGE_B INTEGER,
    IN_AGE_E INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADD_TEACHER_GROUP (
    GROUPING_ID INTEGER,
    TEACHER_ID INTEGER,
    GR_SUBJ_ID INTEGER,
    CLASS_NUM INTEGER,
    GROUP_Q INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CG_ADD (
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50),
    HEADER VARCHAR(3000),
    FOOTER VARCHAR(3000),
    SHOW_POSITION INTEGER)
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CG_DELETE (
    ID INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CG_FILL_FROM_GROUPING (
    ID_CALC_PACK INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_GROUPING INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CG_FOOTER_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    FOOTER VARCHAR(3000))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CG_HEADER_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    HEADER VARCHAR(3000))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CG_NAME_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CG_RECALCULATE (
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CG_SHOW_POSITION_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    SHOW_POSITION INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CGCD_ADD (
    CLASS_NUMBER INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    CATEGORY SMALLINT,
    QTY_STUDENT SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CGCD_CATEGORY_CHANGE (
    CLASS_NUMBER INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    CATEGORY SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CGCD_QTY_STUDENT_CHANGE (
    CLASS_NUMBER INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    QTY_STUDENT SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CGS_ADD (
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50),
    ID_GROUPING INTEGER,
    ID_GROUPING_SUBJ INTEGER,
    SHOW_POSITION INTEGER,
    IS_CONCERTMASTER SMALLINT)
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CGS_DELETE (
    ID INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CGS_MOVE_DOWN (
    ID INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CGS_MOVE_UP (
    ID INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CGS_NAME_CHANGE (
    ID INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CGSCD_ADD (
    CLASS_NUMBER SMALLINT,
    ID_CALC_GROUP_SUBJECT INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    CLOCK_CURR DOUBLE PRECISION,
    QTY_FACT SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CGSCD_CLOCK_CURR (
    CLASS_NUMBER SMALLINT,
    ID_CALC_GROUP_SUBJECT INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    CLOCK_CURR DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CGSCD_CLOCK_CURR_CHANGE (
    CLASS_NUMBER SMALLINT,
    ID_CALC_GROUP_SUBJECT INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    CLOCK_CURR DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CGSCD_DELETE (
    CLASS_NUMBER SMALLINT,
    ID_CALC_GROUP_SUBJECT INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CGSCD_QTY_FACT_CHANGE (
    CLASS_NUMBER SMALLINT,
    ID_CALC_GROUP_SUBJECT INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    QTY_FACT SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CHANGE_CONSTANTS (
    IN_YTCOEF DOUBLE PRECISION,
    IN_OTCOEF DOUBLE PRECISION,
    IN_CTCOEF DOUBLE PRECISION,
    IN_PASPORT_CODE VARCHAR(50),
    IN_PASPORT_NAME VARCHAR(256),
    IN_DIRECTOR_SIGN VARCHAR(256),
    IN_TARIFFICATION_SIGN VARCHAR(3000),
    IN_TAB_SIGN VARCHAR(3000))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CHANGE_SYS_DATE (
    IN_DATE DATE)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CHECK_ORDERED (
    P_TABLE_NAME VARCHAR(150),
    P_ORDER_BY VARCHAR(1000))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CI_ADD (
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50),
    HEADER VARCHAR(3000),
    FOOTER VARCHAR(3000),
    SHOW_POSITION INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CI_DELETE (
    ID INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CI_FILL_FROM_CURR_DEPT (
    ID_CALC_PACK INTEGER,
    ID_CURRICULUM INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CI_FILL_FROM_DEPT (
    ID_CALC_PACK INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_DEPARTMENT INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CI_FOOTER_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    FOOTER VARCHAR(3000))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CI_HEADER_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    HEADER VARCHAR(3000))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CI_NAME_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CI_RECALCULATE (
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CI_SHOW_POSITION_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    SHOW_POSITION INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CICD_ADD (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    CATEGORY SMALLINT,
    QTY_STUDENT SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CICD_CATEGORY_CHANGE (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    CATEGORY SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CICD_DELETE (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CICD_QTY_STUDENT_CHANGE (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    QTY_STUDENT SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CIS_ADD (
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50),
    ID_DEPARTMENT INTEGER,
    ID_CURR_REC INTEGER,
    SHOW_POSITION INTEGER,
    IS_CONCERTMASTER SMALLINT)
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CIS_DELETE (
    ID INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CIS_MOVE_DOWN (
    ID INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CIS_MOVE_UP (
    ID INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CIS_NAME_CHANGE (
    ID INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CISCD_ADD (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL_SUBJECT INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    CLOCK_CURRICULUM DOUBLE PRECISION,
    QTY_FACT SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CISCD_CLOCK_CURR_CHANGE (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL_SUBJECT INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    CLOCK_CURRICULUM DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CISCD_DELETE (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL_SUBJECT INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    CLOCK_CURRICULUM DOUBLE PRECISION,
    QTY_FACT SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CISCD_QTY_FACT_CHANGE (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL_SUBJECT INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    QTY_FACT SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CLEAR_STUDENT_FILTER_SPEC (
    ID_FILTER INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CONST_ADD (
    P_CODE VARCHAR(150),
    P_NAME VARCHAR(150),
    P_TYPE INTEGER)
RETURNS (
    P_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CONST_FLOAT_SET (
    P_CODE VARCHAR(150),
    P_VALUE DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CP_ADD_EDIT (
    ID INTEGER,
    NAME VARCHAR(50))
RETURNS (
    OUT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CP_DELETE (
    ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_CURRICULUM (
    ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_CURRICULUM_RECORD (
    INID INTEGER,
    INCURRID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_DEPARTMENT (
    INID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_EDUCATION (
    INID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_FILIAL (
    INID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_GROUPING (
    IN_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_GROUPING_DEPT (
    IN_GROUPING_ID INTEGER,
    IN_DEPT_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_POST (
    INID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_REP_TAB_EXT (
    IN_REC_TIME TIMESTAMP)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_REP_TAB_EXT_2 (
    IN_REC_TIME TIMESTAMP)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_SPECIALIZATION (
    INID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_STUDENT_PLAN (
    IN_CURR_REC_ID INTEGER,
    INSTUDENTID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_SUBJECT (
    INID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_TARIFF (
    INGRADE INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_TARIFFICATION (
    IN_DATE TIMESTAMP)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_TEACHER (
    INID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_TEACHER_ADDING (
    INID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE EDIT_MAIN_TAB (
    T_ID INTEGER,
    B_Y_TIME DOUBLE PRECISION,
    B_O_TIME DOUBLE PRECISION,
    B_C_TIME DOUBLE PRECISION,
    COMMENTS VARCHAR(256),
    SWP_Y_TIME DOUBLE PRECISION,
    SWP_O_TIME DOUBLE PRECISION,
    SWP_C_TIME DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE FILTRED_STUDENT (
    ID_FILTER INTEGER)
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_CURR_STAGE (
    STAGE_ON_DATE DATE,
    STAGE_Y SMALLINT,
    STAGE_M SMALLINT,
    STAGE_D SMALLINT)
RETURNS (
    CURR_STAGE_Y SMALLINT,
    CURR_STAGE_M SMALLINT,
    CURR_STAGE_D SMALLINT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_CURRS_STUDENTS_QTY (
    CURR_REC_ID INTEGER,
    FINANCING_ID INTEGER,
    CURR_ID INTEGER)
RETURNS (
    Q0 INTEGER,
    Q1 INTEGER,
    Q2 INTEGER,
    Q3 INTEGER,
    Q4 INTEGER,
    Q5 INTEGER,
    Q6 INTEGER,
    Q7 INTEGER,
    Q8 INTEGER,
    OSUM INTEGER,
    OVSUM INTEGER,
    YVSUM INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_FILTERED_TEACHERS (
    FILTER_ID INTEGER)
RETURNS (
    TEACHER_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_FILTRED_STUDENT (
    ID_FILTER INTEGER)
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_QUALIFICATION_ID (
    NAME VARCHAR(256))
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_ST_I_SUBJ_CLOCKS_CSV (
    TEACHER_ID INTEGER,
    STUDENT_ID INTEGER)
RETURNS (
    CLOCKS VARCHAR(3000))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_TEACHER_CAT_LIST (
    ID_TEACHER INTEGER,
    ID_GROUP INTEGER)
RETURNS (
    CATEGORY_LIST VARCHAR(3000))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_TEACHERS_TM
RETURNS (
    TEACHER_ID INTEGER,
    TEACHER_NAME VARCHAR(250),
    TEACHER_POST VARCHAR(250),
    CAT_COEF_P DOUBLE PRECISION,
    CAT_COEF_C DOUBLE PRECISION,
    TITLE_PCT NUMERIC(10,2),
    SUM_CAT_COEF_P NUMERIC(10,2),
    SUM_CAT_COEF_C NUMERIC(10,2),
    SUM_PCT_P NUMERIC(10,2),
    SUM_PCT_C NUMERIC(10,2),
    SUM_PED NUMERIC(10,2),
    SUM_CONC NUMERIC(10,2),
    SUM_TOTAL NUMERIC(10,2),
    SUM_ADD NUMERIC(10,2),
    SUM_WT_ADD NUMERIC(10,2))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE MAIN_TAB_PART_2
RETURNS (
    ABSENCE_CODES VARCHAR(255),
    TEACHER_TAB_NUM INTEGER,
    CLOCK_Y INTEGER,
    CLOCK_O INTEGER,
    CLOCK_C INTEGER,
    CLOCK_SWP_Y INTEGER,
    CLOCK_SWP_O INTEGER,
    CLOCK_SWP_C INTEGER,
    COMMENTS VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NEW_PROCEDURE (
    ID_FILTER INTEGER,
    ID_SPECIALIZATION INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE POS_CHANGE (
    P_TABLE_NAME VARCHAR(150),
    P_ORDER_BY VARCHAR(1000),
    P_ID INTEGER,
    P_STEEP INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE POS_DEC (
    P_TABLE_NAME VARCHAR(150),
    P_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE POS_INC (
    P_TABLE_NAME VARCHAR(150),
    P_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_ALL_TEACHER_GROUP (
    IN_GROUPING_ID INTEGER,
    IN_TEACHER_ID INTEGER)
RETURNS (
    GROUPING_ID INTEGER,
    GROUPING_NAME VARCHAR(30),
    TEACHER_ID INTEGER,
    TEACHER VARCHAR(50),
    GR_QTY_0 INTEGER,
    GR_QTY_1 INTEGER,
    GR_QTY_2 INTEGER,
    GR_QTY_3 INTEGER,
    GR_QTY_4 INTEGER,
    GR_QTY_5 INTEGER,
    GR_QTY_6 INTEGER,
    GR_QTY_7 INTEGER,
    GR_QTY_8 INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CALC_TEACHER_GROUP (
    IN_GROUPING_ID INTEGER,
    IN_CLASS_NUM INTEGER,
    IN_GR_SUBJ_ID INTEGER,
    IN_REPL_TYPE INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_CALC_TEACHER_GROUP_EXT (
    IN_GROUPING_ID INTEGER,
    IN_TEACHER_ID INTEGER,
    IN_REPL_TYPE INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_CURR_REC_REPORT (
    IN_CURR_ID INTEGER,
    IN_FINANCING_ID INTEGER)
RETURNS (
    CURR_REC_ID INTEGER,
    CURR_REC_NUM INTEGER,
    SUBJECT_NAME VARCHAR(30),
    SUBJECT_CODE INTEGER,
    GROUP_QTY INTEGER,
    QTY_0 INTEGER,
    QTY_1 INTEGER,
    QTY_2 INTEGER,
    QTY_3 INTEGER,
    QTY_4 INTEGER,
    QTY_5 INTEGER,
    QTY_6 INTEGER,
    QTY_7 INTEGER,
    QTY_8 INTEGER,
    T_0 DOUBLE PRECISION,
    T_1 DOUBLE PRECISION,
    T_2 DOUBLE PRECISION,
    T_3 DOUBLE PRECISION,
    T_4 DOUBLE PRECISION,
    T_5 DOUBLE PRECISION,
    T_6 DOUBLE PRECISION,
    T_7 DOUBLE PRECISION,
    T_8 DOUBLE PRECISION,
    T_ALL_Y DOUBLE PRECISION,
    T_ALL_O DOUBLE PRECISION,
    T_ALL_C DOUBLE PRECISION,
    T_V_Y DOUBLE PRECISION,
    T_V_O DOUBLE PRECISION,
    T_V_C DOUBLE PRECISION,
    G_QTY_Y INTEGER,
    G_QTY_O INTEGER,
    QTY_Y INTEGER,
    QTY_O INTEGER,
    QTY_C INTEGER,
    QTY_V_Y INTEGER,
    QTY_V_O INTEGER,
    QTY_V_C INTEGER,
    T_V_0 DOUBLE PRECISION,
    T_V_1 DOUBLE PRECISION,
    T_V_2 DOUBLE PRECISION,
    T_V_3 DOUBLE PRECISION,
    T_V_4 DOUBLE PRECISION,
    T_V_5 DOUBLE PRECISION,
    T_V_6 DOUBLE PRECISION,
    T_V_7 DOUBLE PRECISION,
    T_V_8 DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_CURR_REPORT (
    IN_CURR_ID INTEGER,
    IN_FINANCING_ID INTEGER)
RETURNS (
    Q_0 INTEGER,
    Q_1 INTEGER,
    Q_2 INTEGER,
    Q_3 INTEGER,
    Q_4 INTEGER,
    Q_5 INTEGER,
    Q_6 INTEGER,
    Q_7 INTEGER,
    Q_8 INTEGER,
    Q_ALL_Y INTEGER,
    Q_ALL_O INTEGER,
    Q_ALL_C INTEGER,
    Q_V_Y INTEGER,
    Q_V_O INTEGER,
    Q_V_C INTEGER,
    T_V_0 DOUBLE PRECISION,
    T_V_1 DOUBLE PRECISION,
    T_V_2 DOUBLE PRECISION,
    T_V_3 DOUBLE PRECISION,
    T_V_4 DOUBLE PRECISION,
    T_V_5 DOUBLE PRECISION,
    T_V_6 DOUBLE PRECISION,
    T_V_7 DOUBLE PRECISION,
    T_V_8 DOUBLE PRECISION,
    T_0 DOUBLE PRECISION,
    T_1 DOUBLE PRECISION,
    T_2 DOUBLE PRECISION,
    T_3 DOUBLE PRECISION,
    T_4 DOUBLE PRECISION,
    T_5 DOUBLE PRECISION,
    T_6 DOUBLE PRECISION,
    T_7 DOUBLE PRECISION,
    T_8 DOUBLE PRECISION,
    T_A_Y DOUBLE PRECISION,
    T_A_O DOUBLE PRECISION,
    T_A_C DOUBLE PRECISION,
    T_V_Y DOUBLE PRECISION,
    T_V_O DOUBLE PRECISION,
    T_V_C DOUBLE PRECISION,
    G_Y INTEGER,
    G_O INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_EXTRACT_ALL_GROUP (
    IN_GROUPING_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_EXTRACT_GR_SUBJECTS (
    IN_GROUPIND_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_FILL_TEACHER_TM
RETURNS (
    TEACHER_ID INTEGER,
    FINANCING_ID INTEGER,
    YTIME DOUBLE PRECISION,
    OTIME DOUBLE PRECISION,
    CTIME DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_FOR_STUDENT_FILTER (
    ID_FILTER INTEGER)
RETURNS (
    STUDENTID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_GET_TEACHER_GROUP_W_ST_QTY (
    IN_GROUPING_ID INTEGER,
    IN_TEACHER_ID INTEGER,
    IN_GR_SUBJ_ID INTEGER)
RETURNS (
    GROUPING_ID INTEGER,
    GR_SUBJ_ID INTEGER,
    GR_SUBJ_NAME VARCHAR(30),
    GR_SUBJ_CODE INTEGER,
    GR_QTY INTEGER,
    G_QTY_0 INTEGER,
    G_QTY_1 INTEGER,
    G_QTY_2 INTEGER,
    G_QTY_3 INTEGER,
    G_QTY_4 INTEGER,
    G_QTY_5 INTEGER,
    G_QTY_6 INTEGER,
    G_QTY_7 INTEGER,
    G_QTY_8 INTEGER,
    S_QTY_0 INTEGER,
    S_QTY_1 INTEGER,
    S_QTY_2 INTEGER,
    S_QTY_3 INTEGER,
    S_QTY_4 INTEGER,
    S_QTY_5 INTEGER,
    S_QTY_6 INTEGER,
    S_QTY_7 INTEGER,
    S_QTY_8 INTEGER,
    TEACHER_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_LTG_REPORT (
    IN_LTG_ID INTEGER)
RETURNS (
    Q_0 INTEGER,
    Q_1 INTEGER,
    Q_2 INTEGER,
    Q_3 INTEGER,
    Q_4 INTEGER,
    Q_5 INTEGER,
    Q_6 INTEGER,
    Q_7 INTEGER,
    Q_8 INTEGER,
    Q_ALL_Y INTEGER,
    Q_ALL_O INTEGER,
    Q_ALL_C INTEGER,
    Q_V_Y INTEGER,
    Q_V_O INTEGER,
    Q_V_C INTEGER,
    T_V_0 DOUBLE PRECISION,
    T_V_1 DOUBLE PRECISION,
    T_V_2 DOUBLE PRECISION,
    T_V_3 DOUBLE PRECISION,
    T_V_4 DOUBLE PRECISION,
    T_V_5 DOUBLE PRECISION,
    T_V_6 DOUBLE PRECISION,
    T_V_7 DOUBLE PRECISION,
    T_V_8 DOUBLE PRECISION,
    T_0 DOUBLE PRECISION,
    T_1 DOUBLE PRECISION,
    T_2 DOUBLE PRECISION,
    T_3 DOUBLE PRECISION,
    T_4 DOUBLE PRECISION,
    T_5 DOUBLE PRECISION,
    T_6 DOUBLE PRECISION,
    T_7 DOUBLE PRECISION,
    T_8 DOUBLE PRECISION,
    T_A_Y DOUBLE PRECISION,
    T_A_O DOUBLE PRECISION,
    T_A_C DOUBLE PRECISION,
    T_V_Y DOUBLE PRECISION,
    T_V_O DOUBLE PRECISION,
    T_V_C DOUBLE PRECISION,
    G_Y INTEGER,
    G_O INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_LTG_REPORT_REC_G (
    IN_LTG_ID INTEGER)
RETURNS (
    G_SUBJ_ID INTEGER,
    SUBJECT_NAME VARCHAR(30),
    SUBJECT_CODE INTEGER,
    GROUP_QTY INTEGER,
    QTY_0 INTEGER,
    QTY_1 INTEGER,
    QTY_2 INTEGER,
    QTY_3 INTEGER,
    QTY_4 INTEGER,
    QTY_5 INTEGER,
    QTY_6 INTEGER,
    QTY_7 INTEGER,
    QTY_8 INTEGER,
    T_0 DOUBLE PRECISION,
    T_1 DOUBLE PRECISION,
    T_2 DOUBLE PRECISION,
    T_3 DOUBLE PRECISION,
    T_4 DOUBLE PRECISION,
    T_5 DOUBLE PRECISION,
    T_6 DOUBLE PRECISION,
    T_7 DOUBLE PRECISION,
    T_8 DOUBLE PRECISION,
    T_ALL_Y DOUBLE PRECISION,
    T_ALL_O DOUBLE PRECISION,
    T_ALL_C DOUBLE PRECISION,
    T_V_Y DOUBLE PRECISION,
    T_V_O DOUBLE PRECISION,
    T_V_C DOUBLE PRECISION,
    T_V_0 DOUBLE PRECISION,
    T_V_1 DOUBLE PRECISION,
    T_V_2 DOUBLE PRECISION,
    T_V_3 DOUBLE PRECISION,
    T_V_4 DOUBLE PRECISION,
    T_V_5 DOUBLE PRECISION,
    T_V_6 DOUBLE PRECISION,
    T_V_7 DOUBLE PRECISION,
    T_V_8 DOUBLE PRECISION,
    G_QTY_Y INTEGER,
    G_QTY_O INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_LTG_REPORT_REC_I (
    IN_LTG_ID INTEGER)
RETURNS (
    LTG_SUBJ_ID INTEGER,
    LTG_SUBJ_POS INTEGER,
    SUBJECT_NAME VARCHAR(30),
    SUBJECT_CODE INTEGER,
    GROUP_QTY INTEGER,
    QTY_0 INTEGER,
    QTY_1 INTEGER,
    QTY_2 INTEGER,
    QTY_3 INTEGER,
    QTY_4 INTEGER,
    QTY_5 INTEGER,
    QTY_6 INTEGER,
    QTY_7 INTEGER,
    QTY_8 INTEGER,
    T_0 DOUBLE PRECISION,
    T_1 DOUBLE PRECISION,
    T_2 DOUBLE PRECISION,
    T_3 DOUBLE PRECISION,
    T_4 DOUBLE PRECISION,
    T_5 DOUBLE PRECISION,
    T_6 DOUBLE PRECISION,
    T_7 DOUBLE PRECISION,
    T_8 DOUBLE PRECISION,
    T_ALL_Y DOUBLE PRECISION,
    T_ALL_O DOUBLE PRECISION,
    T_ALL_C DOUBLE PRECISION,
    T_V_Y DOUBLE PRECISION,
    T_V_O DOUBLE PRECISION,
    T_V_C DOUBLE PRECISION,
    QTY_Y INTEGER,
    QTY_O INTEGER,
    QTY_C INTEGER,
    QTY_V_Y INTEGER,
    QTY_V_O INTEGER,
    QTY_V_C INTEGER,
    T_V_0 DOUBLE PRECISION,
    T_V_1 DOUBLE PRECISION,
    T_V_2 DOUBLE PRECISION,
    T_V_3 DOUBLE PRECISION,
    T_V_4 DOUBLE PRECISION,
    T_V_5 DOUBLE PRECISION,
    T_V_6 DOUBLE PRECISION,
    T_V_7 DOUBLE PRECISION,
    T_V_8 DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_MAIN_TAB (
    DAYS_QTY INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PROC_NEW_TARIFFICATION (
    IN_INFO VARCHAR(50))
RETURNS (
    OUT_DATE TIMESTAMP)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_PREPARE_GR_CURR (
    GROUPING_ID INTEGER)
RETURNS (
    CURRICULUM_ID INTEGER,
    CURR_REC_NUM INTEGER,
    SUBJECT_ID INTEGER,
    SUBJECT_NAME VARCHAR(30),
    SUBJECT_CODE INTEGER,
    SUBJECT_GROUP INTEGER,
    GROUPING_SUBJ_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_STUDENT_PLAN (
    INID INTEGER,
    INSTUDENTID INTEGER,
    INSPECID INTEGER,
    INCLASSNUM INTEGER)
RETURNS (
    OUTID INTEGER,
    OUTTEACHERID INTEGER,
    OUTSUBJECTID INTEGER,
    OUTSUBJECT VARCHAR(30),
    OUTSUBJECTCODE INTEGER,
    OUTUSE INTEGER,
    OUTTIME DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_TEACHER_GROUP (
    IN_GROUPING_ID INTEGER)
RETURNS (
    GROUPING_ID INTEGER,
    TEACHER_ID INTEGER,
    TEACHER VARCHAR(30),
    GR_QTY_0 INTEGER,
    GR_QTY_1 INTEGER,
    GR_QTY_2 INTEGER,
    GR_QTY_3 INTEGER,
    GR_QTY_4 INTEGER,
    GR_QTY_5 INTEGER,
    GR_QTY_6 INTEGER,
    GR_QTY_7 INTEGER,
    GR_QTY_8 INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_TEACHER_GROUP_CLS (
    GROUPING_ID INTEGER,
    GR_SUBJECT_ID INTEGER,
    CLASS_NUM INTEGER)
RETURNS (
    TEACHER_ID INTEGER,
    TEACHER VARCHAR(30),
    GR_QTY INTEGER,
    ST_QTY INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_TEACHER_GROUP_ST_QTY (
    IN_GROUPING_ID INTEGER,
    IN_TEACHER_ID INTEGER)
RETURNS (
    GROUPING_ID INTEGER,
    TEACHER_ID INTEGER,
    GR_SUBJ_ID INTEGER,
    SUBJECT_ID INTEGER,
    GROUP_QTY INTEGER,
    SUBJECT VARCHAR(30),
    SUBJ_CODE INTEGER,
    G_0 INTEGER,
    Q_0 INTEGER,
    G_1 INTEGER,
    Q_1 INTEGER,
    G_2 INTEGER,
    Q_2 INTEGER,
    G_3 INTEGER,
    Q_3 INTEGER,
    G_4 INTEGER,
    Q_4 INTEGER,
    G_5 INTEGER,
    Q_5 INTEGER,
    G_6 INTEGER,
    Q_6 INTEGER,
    G_7 INTEGER,
    Q_7 INTEGER,
    G_8 INTEGER,
    Q_8 INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_TEACHER_REPORT (
    ID_TEACHER INTEGER,
    ID_DEPARTMENT INTEGER)
RETURNS (
    NAME_SUBJECT VARCHAR(150),
    CLASS_NUMBER INTEGER,
    PERIOD INTEGER,
    QTY_Y INTEGER,
    QTY_O INTEGER,
    TIME_Y DOUBLE PRECISION,
    TIME_O DOUBLE PRECISION,
    TIME_C DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PROC_TEACHER_TM (
    INTEACHERID INTEGER,
    INFINANCING INTEGER)
RETURNS (
    OUTYTIME DOUBLE PRECISION,
    OUTOTIME DOUBLE PRECISION,
    OUTCTIME DOUBLE PRECISION,
    OUTYPAY DOUBLE PRECISION,
    OUTOPAY DOUBLE PRECISION,
    OUTCPAY DOUBLE PRECISION,
    OUTSUMTIME DOUBLE PRECISION,
    OUTSUMPAY DOUBLE PRECISION,
    OUTADDSUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE TABLE_BOOKMARK_D (
    TABLE_NAME VARCHAR(50))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE TABLE_BOOKMARK_IU (
    TABLE_NAME VARCHAR(50),
    BOOKMARK VARCHAR(50))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE TEACHER_ABSENT_CODES (
    TEACHER_ID INTEGER,
    THE_DAY DATE)
RETURNS (
    CODE VARCHAR(150))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE TEACHER_ABSENT_DATA_EDIT (
    TEACHER_ID INTEGER,
    COMMENTS VARCHAR(256))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE TEACHER_ABSENTS_CLEAR (
    TEACHER_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE TEACHER_ABSENTS_EDIT (
    TEACHER_ID INTEGER,
    DATE_FROM DATE,
    DATE_TO DATE,
    ABSENTS VARCHAR(256))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE TEACHER_CAT_EDIT (
    P_ID INTEGER,
    P_ID_TEACHER INTEGER,
    P_ID_CAT_KIND INTEGER,
    P_DATE_BEGIN DATE)
RETURNS (
    OUT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE TT_ADD (
    P_ID_TEACHER INTEGER,
    P_ID_KIND INTEGER,
    P_DATE DATE,
    P_SERIES_NUMBER VARCHAR(3000))
RETURNS (
    ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE UPDATE_CURR_REC_NUMS
AS
BEGIN
  EXIT;
END^






SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE ABSENT_TYPE (
    ID                ID_TYPE NOT NULL,
    NAME              NAME_TYPE,
    CODE              NAME_TYPE_SIZE5,
    IS_CALENDAR_TYPE  SMALLINT_TYPE
);


CREATE TABLE CALC_GROUP (
    ID             ID_TYPE,
    ID_CALC_PACK   ID_TYPE,
    NAME           NAME_TYPE,
    HEADER         LONG_TEXT_TYPE,
    FOOTER         LONG_TEXT_TYPE,
    SHOW_POSITION  INTEGER_TYPE
);


CREATE TABLE CALC_GROUP_CLASS_DETAIL (
    CLASS_NUMBER   INTEGER_TYPE NOT NULL,
    ID_CALC_GROUP  ID_TYPE,
    ID_CALC_PACK   ID_TYPE,
    CATEGORY       SMALLINT_TYPE,
    QTY_STUDENT    SMALLINT_TYPE
);


CREATE TABLE CALC_GROUP_SUBJECT (
    ID                ID_TYPE,
    ID_CALC_GROUP     ID_TYPE,
    ID_CALC_PACK      ID_TYPE,
    NAME              NAME_TYPE,
    ID_GROUPING       ID_TYPE,
    SHOW_POSITION     INTEGER_TYPE,
    IS_CONCERTMASTER  SMALLINT_TYPE,
    ID_GROUPING_SUBJ  ID_TYPE
);


CREATE TABLE CALC_GROUP_SUBJECT_CLASS_DETAIL (
    CLASS_NUMBER           SMALLINT_TYPE NOT NULL,
    ID_CALC_GROUP_SUBJECT  ID_TYPE,
    ID_CALC_GROUP          ID_TYPE,
    ID_CALC_PACK           ID_TYPE,
    CLOCK_CURR             DOUBLE_PREC_TYPE,
    QTY_FACT               SMALLINT_TYPE
);


CREATE TABLE CALC_IND_SUBJ_CLASS_DETAIL (
    CLASS_NUMBER                INTEGER_TYPE NOT NULL,
    ID_CALC_INDIVIDUAL_SUBJECT  ID_TYPE,
    ID_CALC_INDIVIDUAL          ID_TYPE,
    ID_CALC_PACK                ID_TYPE,
    CLOCK_CURRICULUM            DOUBLE_PREC_TYPE,
    QTY_FACT                    SMALLINT_TYPE
);


CREATE TABLE CALC_INDIVIDUAL (
    ID             ID_TYPE,
    ID_CALC_PACK   ID_TYPE NOT NULL,
    NAME           NAME_TYPE NOT NULL,
    HEADER         LONG_TEXT_TYPE,
    FOOTER         LONG_TEXT_TYPE,
    SHOW_POSITION  INTEGER_TYPE
);


CREATE TABLE CALC_INDIVIDUAL_CLASS_DETAIL (
    CLASS_NUMBER        ID_TYPE,
    ID_CALC_INDIVIDUAL  ID_TYPE,
    ID_CALC_PACK        ID_TYPE,
    CATEGORY            SMALLINT_TYPE,
    QTY_STUDENT         SMALLINT_TYPE
);


CREATE TABLE CALC_INDIVIDUAL_SUBJECT (
    ID                  ID_TYPE,
    ID_CALC_INDIVIDUAL  ID_TYPE,
    ID_CALC_PACK        ID_TYPE,
    NAME                NAME_TYPE,
    ID_DEPARTMENT       INTEGER_TYPE,
    ID_CURR_REC         INTEGER_TYPE,
    ID_CURRICULUM       INTEGER_TYPE,
    SHOW_POSITION       INTEGER_TYPE,
    IS_CONCERTMASTER    SMALLINT_TYPE
);


CREATE TABLE CALC_PACK (
    ID             ID_TYPE NOT NULL,
    NAME           NAME_TYPE NOT NULL,
    SHOW_POSITION  INTEGER_TYPE
);


CREATE TABLE CALENDAR (
    THE_DAY     DATE_TYPE NOT NULL,
    IS_HOLIDAY  BYTE_TYPE
);


CREATE TABLE CONST (
    ID      ID_TYPE NOT NULL,
    F_CODE  NAME_TYPE,
    F_NAME  NAME_TYPE,
    F_TYPE  INTEGER
);


CREATE TABLE CONST_DATE (
    F_CONST_ID  ID_TYPE NOT NULL,
    F_VALUE     DATE_TYPE
);


CREATE TABLE CONST_FLOAT (
    F_CONST_ID  ID_TYPE NOT NULL,
    F_VALUE     DOUBLE_PREC_TYPE
);


CREATE TABLE CONST_STRING (
    F_CONST_ID  ID_TYPE NOT NULL,
    F_VALUE     LONG_TEXT_TYPE
);


CREATE TABLE CONST_TYPE (
    ID      ID_TYPE NOT NULL,
    F_NAME  NAME_TYPE
);


CREATE TABLE CONSTANTS (
    YTCOEF                      DOUBLE_PREC_TYPE,
    OTCOEF                      DOUBLE_PREC_TYPE,
    CTCOEF                      DOUBLE_PREC_TYPE,
    VTEACH                      DOUBLE_PREC_TYPE,
    VCONC                       DOUBLE_PREC_TYPE,
    SYSTEM_DATE                 DATE_TYPE,
    PASPORT_CODE                INFO_TYPE,
    PASPORT_NAME                TEXT_TYPE,
    PASPORT_DIRECTOR_SIGN       TEXT_TYPE,
    PASPORT_TARIFFICATION_SIGN  LONG_TEXT_TYPE,
    PASPORT_TAB_SIGN            LONG_TEXT_TYPE
);


CREATE TABLE CURR_CAT (
    CURR_ID    ID_TYPE NOT NULL,
    CLASS_NUM  ID_TYPE NOT NULL,
    CATEGORY   INTEGER_TYPE
);


CREATE TABLE CURR_REC (
    CURR_ID     ID_TYPE NOT NULL,
    ID          ID_TYPE NOT NULL,
    NUM         INTEGER_TYPE,
    SUBJECT_ID  INTEGER_TYPE,
    GROUP_QTY   SMALLINT_TYPE,
    IS_CMASTER  SMALLINT_TYPE
);


CREATE TABLE CURR_REC_TIME (
    CURR_ID      ID_TYPE NOT NULL,
    CURR_REC_ID  ID_TYPE NOT NULL,
    CLASS_NUM    ID_TYPE NOT NULL,
    C_TIME       DOUBLE_PREC_TYPE
);


CREATE TABLE CURRICULUM (
    ID                ID_TYPE NOT NULL,
    NAME              NAME_TYPE,
    PERIOD            SMALLINT_TYPE,
    POS               INTEGER_TYPE,
    PERIOD_FOR_PRINT  NAME_TYPE
);


CREATE TABLE "Department" (
    ID              ID_TYPE NOT NULL,
    "Code"          CODE_TYPE,
    "Name"          NAME_TYPE,
    "CurriculumID"  INTEGER_TYPE,
    "Info"          INFO_TYPE,
    POS             INTEGER_TYPE
);


CREATE TABLE "Education" (
    ID      ID_TYPE,
    "Name"  NAME_TYPE
);


CREATE TABLE "Filial" (
    ID      ID_TYPE,
    "Code"  CODE_TYPE,
    "Name"  NAME_TYPE,
    "Info"  INFO_TYPE
);


CREATE TABLE "Financing" (
    ID      ID_TYPE,
    "Name"  NAME_TYPE
);


CREATE TABLE GROUPING (
    ID            ID_TYPE NOT NULL,
    NAME          NAME_TYPE,
    FINANCING_ID  INTEGER_TYPE
);


CREATE TABLE GROUPING_DEPT (
    GROUPING_ID    ID_TYPE NOT NULL,
    DEPARTMENT_ID  ID_TYPE NOT NULL
);


CREATE TABLE GROUPING_SUBJ (
    GROUPING_ID  ID_TYPE NOT NULL,
    ID           ID_TYPE NOT NULL,
    NAME         NAME_TYPE,
    CODE         SMALLINT_TYPE,
    GROUP_QTY    INTEGER_TYPE,
    POS          INTEGER_TYPE
);


CREATE TABLE GROUPING_SUBJ_CURR_ID (
    GROUPING_ID       ID_TYPE NOT NULL,
    GROUPING_SUBJ_ID  ID_TYPE NOT NULL,
    CURR_ID           ID_TYPE NOT NULL,
    CURR_REC_ID       ID_TYPE NOT NULL
);


CREATE TABLE IBE$REPORTS (
    IBE$REPORT_ID         INTEGER NOT NULL,
    IBE$REPORT_PARENT_ID  INTEGER NOT NULL,
    IBE$REPORT_NAME       VARCHAR(100) NOT NULL,
    IBE$REPORT_SOURCE     BLOB SUB_TYPE 30 SEGMENT SIZE 100,
    IBE$REPORT_RIGHTS     BLOB SUB_TYPE 30 SEGMENT SIZE 100,
    IBE$REPORT_IS_REPORT  SMALLINT DEFAULT 0 NOT NULL
);


CREATE TABLE IBE$SCRIPTS (
    IBE$SCRIPT_NAME           VARCHAR(64) CHARACTER SET UNICODE_FSS NOT NULL,
    IBE$SCRIPT_TYPE           VARCHAR(15) CHARACTER SET UNICODE_FSS NOT NULL,
    IBE$SCRIPT_SOURCE         BLOB SUB_TYPE 1 SEGMENT SIZE 1024,
    IBE$SCRIPT_BLR            BLOB SUB_TYPE 0 SEGMENT SIZE 1024,
    IBE$SCRIPT_DESCRIPTION    BLOB SUB_TYPE 1 SEGMENT SIZE 1024,
    IBE$SCRIPT_STATE          VARCHAR(15) CHARACTER SET UNICODE_FSS DEFAULT 'INVALID' NOT NULL,
    IBE$SCRIPT_ACTION_ID      INTEGER,
    IBE$SCRIPT_FORM           BLOB SUB_TYPE 0 SEGMENT SIZE 1024,
    IBE$SCRIPT_PARAM_HISTORY  BLOB SUB_TYPE 0 SEGMENT SIZE 1024,
    IBE$SCRIPT_ADD_DATA       BLOB SUB_TYPE 1 SEGMENT SIZE 1024
);


CREATE TABLE LEARN_TIME_GRID (
    ID            ID_TYPE,
    FINANCING_ID  INTEGER_TYPE,
    NAME          INFO_TYPE
);


CREATE TABLE LTG_GROUPING (
    LTG_ID       INTEGER_TYPE NOT NULL,
    GROUPING_ID  INTEGER_TYPE NOT NULL
);


CREATE TABLE LTG_I_SUBJ_CURR (
    LTG_ID         INTEGER_TYPE NOT NULL,
    LTG_I_SUBJ_ID  INTEGER_TYPE NOT NULL,
    CURR_ID        INTEGER_TYPE NOT NULL,
    CURR_REC_ID    INTEGER_TYPE NOT NULL
);


CREATE TABLE LTG_I_SUBJECT (
    LTG_ID  INTEGER_TYPE NOT NULL,
    ID      ID_TYPE NOT NULL,
    POS     INTEGER_TYPE,
    NAME    NAME_TYPE
);


CREATE TABLE MAIN_TAB (
    TEACHER_ID    ID_TYPE NOT NULL,
    TAB_NUM       INTEGER_TYPE,
    TEACHER_NAME  INFO_TYPE,
    DAYS_QTY      INTEGER_TYPE,
    B_Y_TIME      DOUBLE_PREC_TYPE,
    B_O_TIME      DOUBLE_PREC_TYPE,
    B_C_TIME      DOUBLE_PREC_TYPE,
    S_Y_TIME      DOUBLE_PREC_TYPE,
    S_O_TIME      DOUBLE_PREC_TYPE,
    S_C_TIME      DOUBLE_PREC_TYPE,
    BEGIN_Y_TIME  DOUBLE_PREC_TYPE,
    BEGIN_C_TIME  DOUBLE_PREC_TYPE,
    T_DATE        DATE_TYPE,
    "SIGN"        INTEGER_TYPE,
    COMMENTS      TEXT_TYPE,
    SWP_Y_TIME    DOUBLE_PREC_TYPE,
    SWP_O_TIME    DOUBLE_PREC_TYPE,
    SWP_C_TIME    DOUBLE_PREC_TYPE
);


CREATE TABLE OBJ_CAT_GROUP (
    F_ID          ID_TYPE,
    F_NAME        NAME_TYPE,
    F_MULTIVALUE  BYTE_TYPE
);


CREATE TABLE OBJ_CAT_KIND (
    F_ID        ID_TYPE,
    F_ID_GROUP  ID_TYPE,
    F_NUMBER    ID_TYPE,
    F_NAME      NAME_TYPE,
    F_PRINT     LONG_TEXT_TYPE
);


CREATE TABLE OBJ_KIND (
    F_ID          ID_TYPE NOT NULL,
    F_NAME        NAME_TYPE,
    F_TABLE_NAME  NAME_TYPE
);


CREATE TABLE OBJ_NOTE_KIND (
    F_ID       ID_TYPE NOT NULL,
    F_ID_TYPE  ID_TYPE,
    F_NAME     NAME_TYPE
);


CREATE TABLE OBJ_NOTE_TYPE (
    F_ID    ID_TYPE NOT NULL,
    F_NAME  NAME_TYPE
);


CREATE TABLE "Post" (
    ID           ID_TYPE,
    "Name"       NAME_TYPE,
    PRINT_SHORT  NAME_TYPE
);


CREATE TABLE QUALIFICATION (
    ID    ID_TYPE NOT NULL,
    NAME  NAME_TYPE
);


CREATE TABLE REP_TAB (
    ID            ID_TYPE,
    TEACHER_ID    ID_TYPE NOT NULL,
    TAB_NUM       INTEGER_TYPE,
    TEACHER_NAME  INFO_TYPE,
    DAYS_QTY      INTEGER_TYPE,
    B_Y_TIME      DOUBLE_PREC_TYPE,
    B_O_TIME      DOUBLE_PREC_TYPE,
    B_C_TIME      DOUBLE_PREC_TYPE,
    S_Y_TIME      DOUBLE_PREC_TYPE,
    S_O_TIME      DOUBLE_PREC_TYPE,
    S_C_TIME      DOUBLE_PREC_TYPE,
    BEGIN_Y_TIME  DOUBLE_PREC_TYPE,
    BEGIN_C_TIME  DOUBLE_PREC_TYPE,
    T_DATE        DATE_TYPE,
    "SIGN"        INTEGER_TYPE
);


CREATE TABLE REP_TAB_EXT (
    REC_TIME      TIMESTAMP NOT NULL,
    TEACHER_NAME  INFO_TYPE,
    TAB_MONTH     DATE,
    Y_T           DOUBLE PRECISION,
    O_T           DOUBLE PRECISION,
    C_T           DOUBLE PRECISION,
    Y_T_OOD       DOUBLE PRECISION,
    O_T_OOD       DOUBLE PRECISION,
    C_T_OOD       DOUBLE PRECISION,
    Y_T_FILIAL    DOUBLE PRECISION,
    O_T_FILIAL    DOUBLE PRECISION,
    C_T_FILIAL    DOUBLE PRECISION
);


CREATE TABLE REP_TAB_EXT_2 (
    REC_TIME      TIMESTAMP NOT NULL,
    TEACHER_NAME  INFO_TYPE,
    TAB_MONTH     DATE,
    Y_T           DOUBLE PRECISION,
    O_T           DOUBLE PRECISION,
    C_T           DOUBLE PRECISION,
    Y_T_OOD       DOUBLE PRECISION,
    O_T_OOD       DOUBLE PRECISION,
    C_T_OOD       DOUBLE PRECISION,
    Y_T_FILIAL    DOUBLE PRECISION,
    O_T_FILIAL    DOUBLE PRECISION,
    C_T_FILIAL    DOUBLE PRECISION
);


CREATE TABLE REPORT_PARAM (
    ID           ID_TYPE NOT NULL,
    NAME         NAME_TYPE,
    PAGE_ORIENT  SMALLINT,
    M_LEFT       INTEGER,
    M_RIGHT      INTEGER,
    M_TOP        INTEGER,
    M_BOTTOM     INTEGER,
    SIZES_1      NAME_TYPE,
    SIZES_2      NAME_TYPE,
    SIZES_3      NAME_TYPE,
    QTY_1        SMALLINT_TYPE,
    QTY_2        SMALLINT_TYPE,
    QTY_3        SMALLINT
);


CREATE TABLE REPORTS (
    ID    ID_TYPE NOT NULL,
    CODE  NAME_TYPE,
    DATA  BLOB SUB_TYPE 1 SEGMENT SIZE 5000
);


CREATE TABLE REPORTS_SQL (
    ID           ID_TYPE NOT NULL,
    CODE         NAME_TYPE,
    REPORT_ID    ID_TYPE,
    ID_PARENT    INTEGER_TYPE,
    SQL_TEXT     LONG_TEXT_TYPE,
    FIELDS_META  LONG_TEXT_TYPE
);


CREATE TABLE SEX (
    F_ID    ID_TYPE NOT NULL,
    F_NAME  NAME_TYPE
);


CREATE TABLE "Specialization" (
    ID                ID_TYPE,
    "DepartmentID"    INTEGER_TYPE,
    "Code"            CODE_TYPE,
    "Name"            NAME_TYPE,
    "Budget"          MONEY_TYPE,
    "Self_Repayment"  MONEY_TYPE,
    "Info"            INFO_TYPE,
    POS               INTEGER_TYPE
);


CREATE TABLE "Student" (
    ID                  ID_TYPE,
    "Code"              INTEGER_TYPE,
    "Name"              NAME_TYPE,
    "SpecializationID"  INTEGER_TYPE,
    "FilialID"          INTEGER_TYPE,
    "FinancingID"       SMALLINT_TYPE,
    "MasterID"          INTEGER_TYPE,
    "Class"             SMALLINT_TYPE,
    "Percent"           SMALLINT_TYPE,
    "BirthDate"         DATE_TYPE,
    "EnterDate"         DATE_TYPE,
    "ReleaseDate"       DATE_TYPE,
    "RestoreDate"       DATE_TYPE,
    "EnterInfo"         NAME_TYPE,
    "ReleaseInfo"       NAME_TYPE,
    "RestoreInfo"       NAME_TYPE,
    "AcademyBDate"      DATE_TYPE,
    "AcademyEDate"      DATE_TYPE,
    "AcademyBInfo"      NAME_TYPE,
    "AcademyEInfo"      NAME_TYPE,
    "Address"           TEXT_TYPE,
    "Telephone"         INFO_TYPE,
    RELEASED            SMALLINT_TYPE,
    ACADEMY             SMALLINT_TYPE,
    F_ID_SEX            D_FK_TYPE
);


CREATE TABLE STUDENT_FILTER (
    ID            ID_TYPE NOT NULL,
    NAME          NAME_TYPE,
    FILIAL_ID     INTEGER_TYPE,
    CLASS_B       INTEGER_TYPE,
    CLASS_E       INTEGER_TYPE,
    CURATOR_ID    INTEGER_TYPE,
    CATEGORY      INTEGER_TYPE,
    PERIOD        INTEGER_TYPE,
    STATUS        INTEGER_TYPE,
    PAY_PERCENT   INTEGER_TYPE,
    AGE_B         INTEGER_TYPE,
    AGE_E         INTEGER_TYPE,
    ENTER_D_B     DATE_TYPE,
    ENTER_D_E     DATE_TYPE,
    RELEASE_D_B   DATE_TYPE,
    RELEASE_D_E   DATE_TYPE,
    RESTORE_D_B   DATE_TYPE,
    RESTORE_D_E   DATE_TYPE,
    ACADEMY_D_B   DATE_TYPE,
    ACADEMY_D_E   DATE_TYPE,
    SUBJECT_ID_1  INTEGER_TYPE,
    TEACHER_ID_1  INTEGER_TYPE,
    SUBJECT_ID_2  INTEGER_TYPE,
    TEACHER_ID_2  INTEGER_TYPE,
    SUBJ_STATE    INTEGER_TYPE,
    FINANCING_ID  INTEGER_TYPE,
    F_ID_SEX      D_FK_TYPE
);


CREATE TABLE STUDENT_FILTER_SPEC (
    ID_FILTER          ID_TYPE NOT NULL,
    ID_SPECIALIZATION  ID_TYPE NOT NULL
);


CREATE TABLE "Student_Plan" (
    "StudentID"  ID_TYPE,
    CURR_REC_ID  ID_TYPE,
    "TeacherID"  INTEGER_TYPE,
    "Use"        SMALLINT_TYPE
);


CREATE TABLE "Subject" (
    ID          ID_TYPE,
    "Code"      CODE_TYPE,
    "Name"      NAME_TYPE,
    "Info"      INFO_TYPE,
    SHORT_NAME  NAME_TYPE
);


CREATE TABLE TABLE_BOOKMARK (
    TABLE_NAME  NAME_TYPE NOT NULL,
    BOOKMARK    INFO_TYPE
);


CREATE TABLE "Tariff" (
    "Grade"   ID_TYPE,
    "Salary"  MONEY_TYPE,
    "Info"    INFO_TYPE
);


CREATE TABLE TARIFFICATION (
    DOC_DATE     DATETIME_TYPE NOT NULL,
    INFO         INFO_TYPE,
    COEF_Y_TIME  DOUBLE_PREC_TYPE,
    COEF_O_TIME  DOUBLE_PREC_TYPE,
    COEF_C_TIME  DOUBLE_PREC_TYPE,
    SYS_DATE     DATE_TYPE
);


CREATE TABLE TARIFFICATION_RECORD (
    DOC_DATE              DATETIME_TYPE NOT NULL,
    TEACHER_ID            INTEGER_TYPE NOT NULL,
    T_NAME                INFO_TYPE,
    T_SUBJ                NAME_TYPE,
    T_POST                NAME_TYPE,
    T_EDUCATION           NAME_TYPE,
    T_DIPLOMA             TEXT_TYPE,
    T_STAGE_D             SMALLINT_TYPE,
    T_STAGE_M             SMALLINT_TYPE,
    T_STAGE_Y             SMALLINT_TYPE,
    T_MAIN_GRADE          SMALLINT_TYPE,
    T_CONCERT_GRADE       SMALLINT_TYPE,
    T_MAIN_SALARY         DOUBLE_PREC_TYPE,
    T_CONCERT_SALARY      DOUBLE_PREC_TYPE,
    T_B_TIME_Y            DOUBLE_PREC_TYPE,
    T_B_TIME_O            DOUBLE_PREC_TYPE,
    T_B_TIME_C            DOUBLE_PREC_TYPE,
    T_S_TIME_Y            DOUBLE_PREC_TYPE,
    T_S_TIME_O            DOUBLE_PREC_TYPE,
    T_S_TIME_C            DOUBLE_PREC_TYPE,
    T_ADDINGS             DOUBLE_PREC_TYPE,
    T_ENTER_DATE          DATE_TYPE,
    T_STAGE_DATE          DATE_TYPE,
    T_MAIN_GRADE_ADD      SMALLINT_TYPE,
    T_CONCERT_GRADE_ADD   SMALLINT_TYPE,
    T_MAIN_SALARY_ADD     DOUBLE_PREC_TYPE,
    T_CONCERT_SALARY_ADD  DOUBLE_PREC_TYPE
);


CREATE TABLE "Teacher" (
    ID                    ID_TYPE,
    TAB_NUM               INTEGER_TYPE,
    "Name"                NAME_TYPE,
    "FilialID"            INTEGER_TYPE,
    "SubjectID"           INTEGER_TYPE,
    "EducationID"         INTEGER_TYPE,
    "PostID"              INTEGER_TYPE,
    "StageDate"           DATE_TYPE,
    "BirthDate"           DATE_TYPE,
    "EnterDate"           DATE_TYPE,
    "ReleaseDate"         DATE_TYPE,
    "GradeID"             INTEGER_TYPE,
    "ConcertGradeID"      INTEGER_TYPE,
    "Diploma"             TEXT_TYPE,
    "Address"             TEXT_TYPE,
    "Telephone"           INFO_TYPE,
    STAGE_Y               SMALLINT_TYPE,
    STAGE_M               SMALLINT_TYPE,
    STAGE_D               SMALLINT_TYPE,
    ID_GRADE_ADD          INTEGER_TYPE,
    ID_GRADE_CONCERT_ADD  INTEGER_TYPE,
    ID_TITLE              INTEGER_TYPE DEFAULT null,
    ID_CATEGORY           INTEGER_TYPE DEFAULT null,
    ID_CATEGORY_CONC      INTEGER_TYPE,
    CATEGORY_DATE         DATE_TYPE,
    CATEGORY_CONC_DATE    DATE_TYPE,
    EDUCATION_2_ID        D_FK_TYPE,
    QUALIFICATION_ID      D_FK_TYPE,
    QUALIFICATION_2_ID    D_FK_TYPE,
    DIPLOMA_2             TEXT_TYPE
);


CREATE TABLE TEACHER_ABSENT (
    TEACHER_ID      ID_TYPE NOT NULL,
    ABSENT_DATE     DATE_TYPE NOT NULL,
    ABSENT_TYPE_ID  ID_TYPE NOT NULL
);


CREATE TABLE TEACHER_ABSENT_MONTH_DATA (
    MON         DATE_TYPE NOT NULL,
    TEACHER_ID  ID_TYPE NOT NULL,
    COMMENTS    INFO_TYPE
);


CREATE TABLE "Teacher_Addings" (
    ID           ID_TYPE,
    "TeacherID"  INTEGER_TYPE,
    "Name"       NAME_TYPE,
    "Percent"    DOUBLE_PREC_TYPE,
    "Sum"        DOUBLE_PREC_TYPE
);


CREATE TABLE TEACHER_CAT (
    F_ID           ID_TYPE NOT NULL,
    F_ID_TEACHER   ID_TYPE NOT NULL,
    F_ID_CAT_KIND  ID_TYPE,
    F_DATE_BEGIN   DATE_TYPE
);


CREATE TABLE TEACHER_CAT_KIND (
    F_ID     INTEGER NOT NULL,
    F_NAME   NAME_TYPE,
    F_PRINT  INFO_TYPE,
    F_COEF   DOUBLE_PREC_TYPE
);


CREATE TABLE TEACHER_FILTER (
    ID            ID_TYPE,
    NAME          NAME_TYPE,
    MAIN_SUBJ_ID  INTEGER_TYPE,
    MAIN_GRADE    INTEGER_TYPE,
    CONC_GRADE    INTEGER_TYPE,
    POST_ID       INFO_TYPE,
    EDUCATION_ID  INFO_TYPE,
    FILIAL_ID     INTEGER_TYPE,
    STATE         INTEGER_TYPE,
    STAGE_B       INTEGER_TYPE,
    STAGE_E       INTEGER_TYPE,
    BIRTH_D_B     DATE_TYPE,
    BIRTH_D_E     DATE_TYPE,
    ENTER_D_B     DATE_TYPE,
    ENTER_D_E     DATE_TYPE,
    RELEASE_D_B   DATE_TYPE,
    RELEASE_D_E   DATE_TYPE,
    STAGE_B_M     INTEGER_TYPE,
    STAGE_E_M     INTEGER_TYPE,
    CAT_ID_PED    INFO_TYPE,
    CAT_ID_CONC   INFO_TYPE,
    TITLE_ID      INFO_TYPE,
    AGE_B         INTEGER_TYPE,
    AGE_E         INTEGER_TYPE
);


CREATE TABLE TEACHER_GROUP (
    GROUPING_ID  ID_TYPE NOT NULL,
    TEACHER_ID   ID_TYPE NOT NULL,
    GR_SUBJ_ID   ID_TYPE NOT NULL,
    CLASS_NUM    ID_TYPE,
    GROUP_Q      INTEGER_TYPE
);


CREATE TABLE TEACHER_NOTE (
    F_ID            ID_TYPE NOT NULL,
    F_ID_NOTE_KIND  ID_TYPE NOT NULL,
    F_ID_TEACHER    ID_TYPE NOT NULL,
    F_DATE_BEGIN    DATE_TYPE,
    F_DATA          LONG_TEXT_TYPE
);


CREATE TABLE TEACHER_TITLE (
    F_ID             ID_TYPE NOT NULL,
    F_ID_TEACHER     ID_TYPE,
    F_ID_KIND        ID_TYPE,
    F_DATE           DATE_TYPE DEFAULT '01.01.2009' NOT NULL,
    F_SERIES_NUMBER  LONG_TEXT_TYPE
);


CREATE TABLE TEACHER_TITLE_KIND (
    F_ID     ID_TYPE NOT NULL,
    F_NAME   NAME_TYPE NOT NULL,
    F_PRINT  TEXT_TYPE
);


CREATE TABLE TMP_CURR (
    ID         ID_TYPE NOT NULL,
    CLASS_NUM  ID_TYPE,
    NAME       NAME_TYPE,
    PERIOD     INTEGER_TYPE,
    CATEGORY   SMALLINT_TYPE
);


CREATE TABLE TMP_CURR_REC (
    CURR_ID     ID_TYPE NOT NULL,
    ID          ID_TYPE NOT NULL,
    NUM         INTEGER_TYPE,
    SUBJECT_ID  INTEGER_TYPE,
    GROUP_QTY   SMALLINT_TYPE
);


CREATE TABLE TMP_CURR_REC_TIME (
    CURR_ID      ID_TYPE,
    CURR_REC_ID  ID_TYPE NOT NULL,
    CLASS_NUM    ID_TYPE NOT NULL,
    "TIME"       DOUBLE_PREC_TYPE
);




/******************************************************************************/
/***                                 Views                                  ***/
/******************************************************************************/


/* View: V_CALC_G_SUBJECT */
CREATE VIEW V_CALC_G_SUBJECT(
    ID,
    ID_CALC_GROUP,
    ID_CALC_PACK,
    NAME_SUBJECT,
    ID_GROUPING,
    NAME_GROUPING,
    ID_GROUPING_SUBJ,
    SHOW_POSITION,
    IS_CONCERTMASTER)
AS
SELECT
  CGS.ID,
  CGS.ID_CALC_GROUP,
  CGS.ID_CALC_PACK,
  CGS.NAME,
  CGS.ID_GROUPING,
  G.NAME,
  CGS.ID_GROUPING_SUBJ,
  CGS.SHOW_POSITION,
  CGS.IS_CONCERTMASTER
FROM CALC_GROUP_SUBJECT CGS
  LEFT JOIN GROUPING G ON
    CGS.ID_GROUPING = G.ID
  LEFT JOIN GROUPING_SUBJ GS ON
    GS.ID = CGS.ID_GROUPING_SUBJ AND
    GS.GROUPING_ID = CGS.ID_GROUPING
;



/* View: V_CALC_GROUP */
CREATE VIEW V_CALC_GROUP(
    ID_CALC_PACK,
    ID,
    SHOW_POSITION,
    NAME,
    HEADER,
    FOOTER,
    CLOCK_CURR_0,
    QTY_0,
    CLOCK_0,
    CAT_0,
    QTY_ST_0,
    CLOCK_CURR_1,
    QTY_1,
    CLOCK_1,
    CAT_1,
    QTY_ST_1,
    CLOCK_CURR_2,
    QTY_2,
    CLOCK_2,
    CAT_2,
    QTY_ST_2,
    CLOCK_CURR_3,
    QTY_3,
    CLOCK_3,
    CAT_3,
    QTY_ST_3,
    CLOCK_CURR_4,
    QTY_4,
    CLOCK_4,
    CAT_4,
    QTY_ST_4,
    CLOCK_CURR_5,
    QTY_5,
    CLOCK_5,
    CAT_5,
    QTY_ST_5,
    CLOCK_CURR_6,
    QTY_6,
    CLOCK_6,
    CAT_6,
    QTY_ST_6,
    CLOCK_CURR_7,
    QTY_7,
    CLOCK_7,
    CAT_7,
    QTY_ST_7,
    CLOCK_CURR_8,
    QTY_8,
    CLOCK_8,
    CAT_8,
    QTY_ST_8,
    QTY_TOTAL,
    CLOCK_Y,
    CLOCK_O,
    CLOCK_C)
AS
SELECT
  cg.ID_CALC_PACK,
  cg.ID, 
  cg.SHOW_POSITION,
  cg.NAME,
  cg.HEADER,
  cg.FOOTER,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 0 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_0,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 0 THEN cgscd.QTY_FACT ELSE NULL END) QTY_0,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 0 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_0,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 0 THEN cgcd.CATEGORY ELSE NULL END) CAT_0,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 0 THEN cgcd.QTY_STUDENT ELSE NULL END) QTY_ST_0,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 1 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_1,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 1 THEN cgscd.QTY_FACT ELSE NULL END) QTY_1,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 1 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_1,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 1 THEN cgcd.CATEGORY ELSE NULL END) CAT_1,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 1 THEN cgcd.QTY_STUDENT ELSE NULL END) QTY_ST_1,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 2 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_2,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 2 THEN cgscd.QTY_FACT ELSE NULL END) QTY_2,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 2 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_2,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 2 THEN cgcd.CATEGORY ELSE NULL END) CAT_2,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 2 THEN cgcd.QTY_STUDENT ELSE NULL END) QTY_ST_2,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 3 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_3,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 3 THEN cgscd.QTY_FACT ELSE NULL END) QTY_3,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 3 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_3,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 3 THEN cgcd.CATEGORY ELSE NULL END) CAT_3,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 3 THEN cgcd.QTY_STUDENT ELSE NULL END) QTY_ST_3,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 4 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_4,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 4 THEN cgscd.QTY_FACT ELSE NULL END) QTY_4,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 4 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_4,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 4 THEN cgcd.CATEGORY ELSE NULL END) CAT_4,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 4 THEN cgcd.QTY_STUDENT ELSE NULL END) QTY_ST_4,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 5 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_5,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 5 THEN cgscd.QTY_FACT ELSE NULL END) QTY_5,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 5 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_5,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 5 THEN cgcd.CATEGORY ELSE NULL END) CAT_5,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 5 THEN cgcd.QTY_STUDENT ELSE NULL END) QTY_ST_5,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 6 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_6,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 6 THEN cgscd.QTY_FACT ELSE NULL END) QTY_6,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 6 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_6,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 6 THEN cgcd.CATEGORY ELSE NULL END) CAT_6,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 6 THEN cgcd.QTY_STUDENT ELSE NULL END) QTY_ST_6,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 7 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_7,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 7 THEN cgscd.QTY_FACT ELSE NULL END) QTY_7,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 7 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_7,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 7 THEN cgcd.CATEGORY ELSE NULL END) CAT_7,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 7 THEN cgcd.QTY_STUDENT ELSE NULL END) QTY_ST_7,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 8 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_8,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 8 THEN cgscd.QTY_FACT ELSE NULL END) QTY_8,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 8 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_8,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 8 THEN cgcd.CATEGORY ELSE NULL END) CAT_8,
  SUM(DISTINCT CASE WHEN cgcd.CLASS_NUMBER = 8 THEN cgcd.QTY_STUDENT ELSE NULL END) QTY_ST_8,

  SUM(cgscd.QTY_FACT) QTY_TOTAL,
  SUM(CASE WHEN cgcd.CATEGORY = 0 AND cgs.IS_CONCERTMASTER = 0 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_Y,
  SUM(CASE WHEN cgcd.CATEGORY = 1 AND cgs.IS_CONCERTMASTER = 0 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_O,
  NULLIF(SUM(CASE WHEN cgs.IS_CONCERTMASTER = 1 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END), 0) CLOCK_C
FROM CALC_GROUP cg
  LEFT JOIN CALC_GROUP_SUBJECT cgs ON
    cgs.ID_CALC_GROUP = cg.ID AND
    cgs.ID_CALC_PACK = cg.ID_CALC_PACK
  LEFT JOIN CALC_GROUP_SUBJECT_CLASS_DETAIL cgscd ON
    cgscd.ID_CALC_GROUP_SUBJECT = cgs.ID AND
    cgscd.ID_CALC_GROUP = cgs.ID_CALC_GROUP AND
    cgscd.ID_CALC_PACK = cgs.ID_CALC_PACK
  LEFT JOIN CALC_GROUP_CLASS_DETAIL cgcd ON
    cgcd.ID_CALC_PACK = cgs.ID_CALC_PACK AND
    cgcd.ID_CALC_GROUP = cgs.ID_CALC_GROUP AND
    cgcd.CLASS_NUMBER = cgscd.CLASS_NUMBER
GROUP BY
  cg.ID_CALC_PACK,
  cg.ID, 
  cg.SHOW_POSITION,
  cg.NAME,
  cg.HEADER,
  cg.FOOTER
;



/* View: V_CALC_GROUP_SUBJECT */
CREATE VIEW V_CALC_GROUP_SUBJECT(
    ID_CALC_PACK,
    ID_CALC_GROUP,
    ID,
    SHOW_POSITION,
    NAME,
    CLOCK_CURR_0,
    QTY_0,
    CLOCK_0,
    CLOCK_CURR_1,
    QTY_1,
    CLOCK_1,
    CLOCK_CURR_2,
    QTY_2,
    CLOCK_2,
    CLOCK_CURR_3,
    QTY_3,
    CLOCK_3,
    CLOCK_CURR_4,
    QTY_4,
    CLOCK_4,
    CLOCK_CURR_5,
    QTY_5,
    CLOCK_5,
    CLOCK_CURR_6,
    QTY_6,
    CLOCK_6,
    CLOCK_CURR_7,
    QTY_7,
    CLOCK_7,
    CLOCK_CURR_8,
    QTY_8,
    CLOCK_8,
    QTY_TOTAL,
    CLOCK_Y,
    CLOCK_O,
    CLOCK_C)
AS
SELECT
  cgs.ID_CALC_PACK,
  cgs.ID_CALC_GROUP,
  cgs.ID,
  cgs.SHOW_POSITION,
  cgs.NAME,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 0 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_0,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 0 THEN cgscd.QTY_FACT ELSE NULL END) QTY_0,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 0 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_0,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 1 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_1,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 1 THEN cgscd.QTY_FACT ELSE NULL END) QTY_1,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 1 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_1,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 2 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_2,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 2 THEN cgscd.QTY_FACT ELSE NULL END) QTY_2,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 2 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_2,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 3 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_3,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 3 THEN cgscd.QTY_FACT ELSE NULL END) QTY_3,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 3 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_3,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 4 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_4,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 4 THEN cgscd.QTY_FACT ELSE NULL END) QTY_4,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 4 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_4,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 5 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_5,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 5 THEN cgscd.QTY_FACT ELSE NULL END) QTY_5,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 5 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_5,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 6 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_6,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 6 THEN cgscd.QTY_FACT ELSE NULL END) QTY_6,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 6 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_6,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 7 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_7,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 7 THEN cgscd.QTY_FACT ELSE NULL END) QTY_7,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 7 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_7,

  SUM(CASE WHEN cgscd.CLASS_NUMBER = 8 THEN cgscd.CLOCK_CURR ELSE NULL END) CLOCK_CURR_8,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 8 THEN cgscd.QTY_FACT ELSE NULL END) QTY_8,
  SUM(CASE WHEN cgscd.CLASS_NUMBER = 8 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_8,

  SUM(cgscd.QTY_FACT) QTY_TOTAL,
  SUM(CASE WHEN cgcd.CATEGORY = 0 AND cgs.IS_CONCERTMASTER = 0 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_Y,
  SUM(CASE WHEN cgcd.CATEGORY = 1 AND cgs.IS_CONCERTMASTER = 0 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END) CLOCK_O,
  NULLIF(SUM(CASE WHEN cgs.IS_CONCERTMASTER = 1 THEN cgscd.QTY_FACT*cgscd.CLOCK_CURR ELSE NULL END), 0) CLOCK_C
FROM CALC_GROUP_SUBJECT cgs
  LEFT JOIN CALC_GROUP_SUBJECT_CLASS_DETAIL cgscd ON
    cgscd.ID_CALC_GROUP_SUBJECT = cgs.ID AND
    cgscd.ID_CALC_GROUP = cgs.ID_CALC_GROUP AND
    cgscd.ID_CALC_PACK = cgs.ID_CALC_PACK
  LEFT JOIN CALC_GROUP_CLASS_DETAIL cgcd ON
    cgcd.ID_CALC_PACK = cgs.ID_CALC_PACK AND
    cgcd.ID_CALC_GROUP = cgs.ID_CALC_GROUP AND
    cgcd.CLASS_NUMBER = cgscd.CLASS_NUMBER
GROUP BY
  cgs.ID_CALC_PACK,
  cgs.ID_CALC_GROUP,
  cgs.ID,
  cgs.SHOW_POSITION,
  cgs.NAME
;



/* View: V_CALC_I_SUBJECT */
CREATE VIEW V_CALC_I_SUBJECT(
    ID,
    ID_CALC_INDIVIDUAL,
    ID_CALC_PACK,
    NAME_SUBJECT,
    ID_DEPARTMENT,
    NAME_DEPARTMENT,
    ID_CURR_REC,
    ID_CURRICULUM,
    NAME_CURRICULUM,
    SHOW_POSITION,
    IS_CONCERTMASTER)
AS
SELECT
  CIS.ID,
  CIS.ID_CALC_INDIVIDUAL,
  CIS.ID_CALC_PACK,
  CIS.NAME,
  CIS.ID_DEPARTMENT,
  D."Name",
  CIS.ID_CURR_REC,
  CIS.ID_CURRICULUM,
  C.NAME,
  CIS.SHOW_POSITION,
  CIS.IS_CONCERTMASTER
FROM CALC_INDIVIDUAL_SUBJECT CIS
  LEFT JOIN "Department" D ON
    CIS.ID_DEPARTMENT = D.ID
  LEFT JOIN CURR_REC CR ON
    CR.ID = CIS.ID_DEPARTMENT AND
    CR.CURR_ID = CIS.ID_CURRICULUM
  LEFT JOIN CURRICULUM C ON
    C.ID = CIS.ID_CURRICULUM
;



/* View: V_CALC_INDIVIDUAL */
CREATE VIEW V_CALC_INDIVIDUAL(
    ID_CALC_PACK,
    ID_CALC_INDIVIDUAL,
    NAME,
    HEADER,
    FOOTER,
    CAT_0,
    QTY_0,
    CLOCK_CURR_0,
    CLOCK_FACT_0,
    CAT_1,
    QTY_1,
    CLOCK_CURR_1,
    CLOCK_FACT_1,
    CAT_2,
    QTY_2,
    CLOCK_CURR_2,
    CLOCK_FACT_2,
    CAT_3,
    QTY_3,
    CLOCK_CURR_3,
    CLOCK_FACT_3,
    CAT_4,
    QTY_4,
    CLOCK_CURR_4,
    CLOCK_FACT_4,
    CAT_5,
    QTY_5,
    CLOCK_CURR_5,
    CLOCK_FACT_5,
    CAT_6,
    QTY_6,
    CLOCK_CURR_6,
    CLOCK_FACT_6,
    CAT_7,
    QTY_7,
    CLOCK_CURR_7,
    CLOCK_FACT_7,
    CAT_8,
    QTY_8,
    CLOCK_CURR_8,
    CLOCK_FACT_8,
    QTY_Y,
    CLOCK_CURR_Y,
    CLOCK_FACT_Y,
    CLOCK_UNALL_Y,
    QTY_O,
    CLOCK_CURR_O,
    CLOCK_FACT_O,
    CLOCK_UNALL_O,
    QTY_C,
    CLOCK_CURR_C,
    CLOCK_FACT_C,
    CLOCK_UNALL_C)
AS
SELECT
  ci.ID_CALC_PACK,
  ci.ID,
  ci.NAME,
  ci.HEADER,
  ci.FOOTER,
  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 0 THEN cicd.CATEGORY ELSE NULL END) CAT_0,
  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 0 THEN cicd.QTY_STUDENT ELSE NULL END) QTY_0,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 0 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_0,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 0 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_0,

  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 1 THEN cicd.CATEGORY ELSE NULL END) CAT_1,
  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 1 THEN cicd.QTY_STUDENT ELSE NULL END) QTY_1,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 1 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_1,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 1 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_1,

  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 2 THEN cicd.CATEGORY ELSE NULL END) CAT_2,
  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 2 THEN cicd.QTY_STUDENT ELSE NULL END) QTY_2,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 2 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_2,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 2 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_2,

  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 3 THEN cicd.CATEGORY ELSE NULL END) CAT_3,
  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 3 THEN cicd.QTY_STUDENT ELSE NULL END) QTY_3,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 3 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_3,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 3 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_3,

  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 4 THEN cicd.CATEGORY ELSE NULL END) CAT_4,
  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 4 THEN cicd.QTY_STUDENT ELSE NULL END) QTY_4,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 4 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_4,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 4 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_4,

  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 5 THEN cicd.CATEGORY ELSE NULL END) CAT_5,
  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 5 THEN cicd.QTY_STUDENT ELSE NULL END) QTY_5,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 5 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_5,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 5 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_5,

  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 6 THEN cicd.CATEGORY ELSE NULL END) CAT_6,
  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 6 THEN cicd.QTY_STUDENT ELSE NULL END) QTY_6,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 6 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_6,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 6 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_6,

  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 7 THEN cicd.CATEGORY ELSE NULL END) CAT_7,
  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 7 THEN cicd.QTY_STUDENT ELSE NULL END) QTY_7,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 7 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_7,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 7 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_7,

  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 8 THEN cicd.CATEGORY ELSE NULL END) CAT_8,
  SUM(DISTINCT CASE WHEN cicd.CLASS_NUMBER = 8 THEN cicd.QTY_STUDENT ELSE NULL END) QTY_8,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 8 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_8,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 8 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_8,

  SUM(DISTINCT CASE WHEN cicd.CATEGORY = 0 AND cis.IS_CONCERTMASTER = 0 THEN cicd.QTY_STUDENT ELSE NULL END) QTY_Y,
  SUM(CASE WHEN cicd.CATEGORY = 0 AND cis.IS_CONCERTMASTER = 0 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_Y,
  SUM(CASE WHEN cicd.CATEGORY = 0 AND cis.IS_CONCERTMASTER = 0 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_Y,
  NULLIF(SUM(CASE WHEN cicd.CATEGORY = 0 AND cis.IS_CONCERTMASTER = 0 THEN (cicd.QTY_STUDENT - COALESCE(ciscd.QTY_FACT, 0))*ciscd.CLOCK_CURRICULUM ELSE NULL END), 0) CLOCK_UNALL_Y,

  SUM(DISTINCT CASE WHEN cicd.CATEGORY = 1 AND cis.IS_CONCERTMASTER = 0 THEN cicd.QTY_STUDENT ELSE NULL END) QTY_O,
  SUM(CASE WHEN cicd.CATEGORY = 1 AND cis.IS_CONCERTMASTER = 0 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_O,
  SUM(CASE WHEN cicd.CATEGORY = 1 AND cis.IS_CONCERTMASTER = 0 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_O,
  NULLIF(SUM(CASE WHEN cicd.CATEGORY = 1 AND cis.IS_CONCERTMASTER = 0 THEN (cicd.QTY_STUDENT - COALESCE(ciscd.QTY_FACT, 0))*ciscd.CLOCK_CURRICULUM ELSE NULL END), 0) CLOCK_UNALL_O,

  SUM(DISTINCT CASE WHEN cis.IS_CONCERTMASTER <> 0 THEN cicd.QTY_STUDENT ELSE NULL END) QTY_C,
  SUM(CASE WHEN cis.IS_CONCERTMASTER <> 0 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_C,
  SUM(CASE WHEN cis.IS_CONCERTMASTER <> 0 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_C,
  NULLIF(SUM(CASE WHEN cis.IS_CONCERTMASTER <> 0 THEN (cicd.QTY_STUDENT - COALESCE(ciscd.QTY_FACT, 0))*ciscd.CLOCK_CURRICULUM ELSE NULL END), 0) CLOCK_UNALL_C
FROM  CALC_INDIVIDUAL ci
  LEFT JOIN CALC_INDIVIDUAL_SUBJECT cis ON
    cis.ID_CALC_INDIVIDUAL = ci.ID AND
    cis.ID_CALC_PACK = ci.ID_CALC_PACK
  LEFT JOIN CALC_IND_SUBJ_CLASS_DETAIL ciscd ON
    ciscd.ID_CALC_INDIVIDUAL_SUBJECT = cis.ID AND
    ciscd.ID_CALC_INDIVIDUAL = cis.ID_CALC_INDIVIDUAL AND
    ciscd.ID_CALC_PACK = cis.ID_CALC_PACK
  LEFT JOIN CALC_INDIVIDUAL_CLASS_DETAIL cicd ON
    cicd.ID_CALC_PACK = cis.ID_CALC_PACK AND
    cicd.ID_CALC_INDIVIDUAL = cis.ID_CALC_INDIVIDUAL AND
    cicd.CLASS_NUMBER = ciscd.CLASS_NUMBER
GROUP BY
  ci.ID_CALC_PACK,
  ci.ID,
  ci.NAME,
  ci.HEADER,
  ci.FOOTER
;



/* View: V_CALC_INDIVIDUAL_SUBJECT */
CREATE VIEW V_CALC_INDIVIDUAL_SUBJECT(
    ID_CALC_PACK,
    ID_CALC_INDIVIDUAL,
    ID,
    SHOW_POSITION,
    NAME,
    CLOCK_CURR_0,
    CLOCK_FACT_0,
    CLOCK_CURR_1,
    CLOCK_FACT_1,
    CLOCK_CURR_2,
    CLOCK_FACT_2,
    CLOCK_CURR_3,
    CLOCK_FACT_3,
    CLOCK_CURR_4,
    CLOCK_FACT_4,
    CLOCK_CURR_5,
    CLOCK_FACT_5,
    CLOCK_CURR_6,
    CLOCK_FACT_6,
    CLOCK_CURR_7,
    CLOCK_FACT_7,
    CLOCK_CURR_8,
    CLOCK_FACT_8,
    CLOCK_CURR_Y,
    CLOCK_FACT_Y,
    CLOCK_UNALL_Y,
    CLOCK_CURR_O,
    CLOCK_FACT_O,
    CLOCK_UNALL_O,
    CLOCK_CURR_C,
    CLOCK_FACT_C,
    CLOCK_UNALL_C)
AS
SELECT
  cis.ID_CALC_PACK,
  cis.ID_CALC_INDIVIDUAL,
  cis.ID,
  cis.SHOW_POSITION,
  cis.NAME,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 0 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_0,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 0 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_0,

  SUM(CASE WHEN ciscd.CLASS_NUMBER = 1 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_1,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 1 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_1,

  SUM(CASE WHEN ciscd.CLASS_NUMBER = 2 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_2,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 2 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_2,

  SUM(CASE WHEN ciscd.CLASS_NUMBER = 3 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_3,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 3 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_3,

  SUM(CASE WHEN ciscd.CLASS_NUMBER = 4 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_4,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 4 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_4,

  SUM(CASE WHEN ciscd.CLASS_NUMBER = 5 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_5,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 5 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_5,

  SUM(CASE WHEN ciscd.CLASS_NUMBER = 6 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_6,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 6 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_6,

  SUM(CASE WHEN ciscd.CLASS_NUMBER = 7 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_7,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 7 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_7,

  SUM(CASE WHEN ciscd.CLASS_NUMBER = 8 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_8,
  SUM(CASE WHEN ciscd.CLASS_NUMBER = 8 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_8,

  SUM(CASE WHEN cicd.CATEGORY = 0 AND cis.IS_CONCERTMASTER = 0 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_Y,
  SUM(CASE WHEN cicd.CATEGORY = 0 AND cis.IS_CONCERTMASTER = 0 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_Y,
  NULLIF(SUM(CASE WHEN cicd.CATEGORY = 0 AND cis.IS_CONCERTMASTER = 0 THEN (cicd.QTY_STUDENT - COALESCE(ciscd.QTY_FACT, 0))*ciscd.CLOCK_CURRICULUM ELSE NULL END), 0) CLOCK_UNALL_Y,

  SUM(CASE WHEN cicd.CATEGORY = 1 AND cis.IS_CONCERTMASTER = 0 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_O,
  SUM(CASE WHEN cicd.CATEGORY = 1 AND cis.IS_CONCERTMASTER = 0 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_O,
  NULLIF(SUM(CASE WHEN cicd.CATEGORY = 1 AND cis.IS_CONCERTMASTER = 0 THEN (cicd.QTY_STUDENT - COALESCE(ciscd.QTY_FACT, 0))*ciscd.CLOCK_CURRICULUM ELSE NULL END), 0) CLOCK_UNALL_O,

  SUM(CASE WHEN cis.IS_CONCERTMASTER <> 0 THEN cicd.QTY_STUDENT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_CURR_C,
  SUM(CASE WHEN cis.IS_CONCERTMASTER <> 0 THEN ciscd.QTY_FACT * ciscd.CLOCK_CURRICULUM ELSE NULL END) CLOCK_FACT_C,
  NULLIF(SUM(CASE WHEN cis.IS_CONCERTMASTER <> 0 THEN (cicd.QTY_STUDENT - COALESCE(ciscd.QTY_FACT, 0))*ciscd.CLOCK_CURRICULUM ELSE NULL END), 0) CLOCK_UNALL_C

FROM CALC_INDIVIDUAL_SUBJECT cis
  LEFT JOIN CALC_IND_SUBJ_CLASS_DETAIL ciscd ON
    ciscd.ID_CALC_INDIVIDUAL_SUBJECT = cis.ID AND
    ciscd.ID_CALC_INDIVIDUAL = cis.ID_CALC_INDIVIDUAL AND
    ciscd.ID_CALC_PACK = cis.ID_CALC_PACK
  LEFT JOIN CALC_INDIVIDUAL_CLASS_DETAIL cicd ON
    cicd.ID_CALC_PACK = cis.ID_CALC_PACK AND
    cicd.ID_CALC_INDIVIDUAL = cis.ID_CALC_INDIVIDUAL AND
    cicd.CLASS_NUMBER = ciscd.CLASS_NUMBER
GROUP BY
  cis.ID_CALC_PACK,
  cis.ID_CALC_INDIVIDUAL,
  cis.ID,
  cis.SHOW_POSITION,
  cis.NAME
;



/* View: V_CONST_FLOAT */
CREATE VIEW V_CONST_FLOAT(
    ID,
    F_CODE,
    F_NAME,
    F_VALUE)
AS
select
  c.id,
  c.f_code,
  c.f_name,
  cf.f_value
from const c
  left join const_float cf on cf.f_const_id = c.id
where c.f_type = 2
;



/* View: V_CURR_INDIVIDUAL */
CREATE VIEW V_CURR_INDIVIDUAL(
    CURRICULUM_ID,
    SUBJECT_ID,
    SUBJECT_NAME,
    Q_0,
    T_0,
    Q_V_0,
    T_V_0,
    Q_1,
    T_1,
    Q_V_1,
    T_V_1,
    Q_2,
    T_2,
    Q_V_2,
    T_V_2,
    Q_3,
    T_3,
    Q_V_3,
    T_V_3,
    Q_4,
    T_4,
    Q_V_4,
    T_V_4,
    Q_5,
    T_5,
    Q_V_5,
    T_V_5,
    Q_6,
    T_6,
    Q_V_6,
    T_V_6,
    Q_7,
    T_7,
    Q_V_7,
    T_V_7,
    Q_8,
    T_8,
    Q_V_8,
    T_V_8,
    Q_Y_TOTAL,
    T_Y_TOTAL,
    Q_V_Y_TOTAL,
    T_V_Y_TOTAL,
    Q_O_TOTAL,
    T_O_TOTAL,
    Q_V_O_TOTAL,
    T_V_O_TOTAL,
    Q_C_TOTAL,
    T_C_TOTAL,
    Q_V_C_TOTAL,
    T_V_C_TOTAL,
    Q_TOTAL,
    T_TOTAL,
    Q_V_TOTAL,
    T_V_TOTAL)
AS
select
    D."CurriculumID",
    CR.SUBJECT_ID,
    SUBJ."Name",
    SUM(CASE WHEN S."Class" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 0 AND STP."TeacherID" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 0 AND STP."TeacherID" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),

    SUM(CASE WHEN S."Class" = 1 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 1 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 1 AND STP."TeacherID" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 1 AND STP."TeacherID" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),

    SUM(CASE WHEN S."Class" = 2 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 2 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 2 AND STP."TeacherID" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 2 AND STP."TeacherID" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),

    SUM(CASE WHEN S."Class" = 3 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 3 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 3 AND STP."TeacherID" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 3 AND STP."TeacherID" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),

    SUM(CASE WHEN S."Class" = 4 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 4 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 4 AND STP."TeacherID" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 4 AND STP."TeacherID" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),

    SUM(CASE WHEN S."Class" = 5 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 5 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 5 AND STP."TeacherID" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 5 AND STP."TeacherID" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),

    SUM(CASE WHEN S."Class" = 6 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 6 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 6 AND STP."TeacherID" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 6 AND STP."TeacherID" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),

    SUM(CASE WHEN S."Class" = 7 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 7 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 7 AND STP."TeacherID" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 7 AND STP."TeacherID" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),

    SUM(CASE WHEN S."Class" = 8 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 8 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 8 AND STP."TeacherID" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN S."Class" = 8 AND STP."TeacherID" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),

    SUM(CASE WHEN CC.CATEGORY = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN CC.CATEGORY = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),
    SUM(CASE WHEN CC.CATEGORY = 0 AND STP."TeacherID" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN CC.CATEGORY = 0 AND STP."TeacherID" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),

    SUM(CASE WHEN CC.CATEGORY = 1 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN CC.CATEGORY = 1 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),
    SUM(CASE WHEN CC.CATEGORY = 1 AND STP."TeacherID" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN CC.CATEGORY = 1 AND STP."TeacherID" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),

    SUM(CASE WHEN SUBJ."Code" = 1 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN SUBJ."Code" = 1 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),
    SUM(CASE WHEN SUBJ."Code" = 1 AND STP."TeacherID" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN SUBJ."Code" = 1 AND STP."TeacherID" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END),

    SUM(CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END),
    SUM(CRT.c_time),
    SUM(CASE WHEN STP."TeacherID" = 0 THEN (CASE COALESCE(CRT.c_time, 0) WHEN 0 THEN 0 ELSE 1 END) ELSE 0 END),
    SUM(CASE WHEN STP."TeacherID" = 0 THEN COALESCE(CRT.c_time, 0) ELSE 0 END)
from "Student_Plan" STP
    join "Student" S on STP."StudentID" = S.id
    join "Specialization" SP on SP.id = S."SpecializationID"
    join "Department" D on D.id = SP."DepartmentID"
    join CURR_CAT CC ON
      CC.CURR_ID = D."CurriculumID" AND
      CC.CLASS_NUM = S."Class"
    join curr_rec CR on
      D."CurriculumID" = CR.curr_id AND
      CR.id = STP.curr_rec_id AND
      CR.GROUP_QTY = 1
    join "Subject" SUBJ ON
      SUBJ.ID = CR.SUBJECT_ID
    join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id
        and CRT.class_num = S."Class"
where
  STP."Use" > 0 and STP."TeacherID" is not null and
  S."ReleaseDate" is null and (S."AcademyBDate" is null or S."AcademyEDate" is not null)
group by D."CurriculumID", CR.SUBJECT_ID, SUBJ."Name"
;



/* View: V_CURRICULUM */
CREATE VIEW V_CURRICULUM(
    ID,
    NAME,
    PERIOD_FOR_PRINT,
    PERIOD,
    POS,
    CAT_0,
    CAT_1,
    CAT_2,
    CAT_3,
    CAT_4,
    CAT_5,
    CAT_6,
    CAT_7,
    CAT_8,
    CAT_9)
AS
select c.id, c.name, coalesce(c.period_for_print, c.period), c.period, c.pos,
  sum(case cc.class_num when 0 then cc.category else null end),
  sum(case cc.class_num when 1 then cc.category else null end),
  sum(case cc.class_num when 2 then cc.category else null end),
  sum(case cc.class_num when 3 then cc.category else null end),
  sum(case cc.class_num when 4 then cc.category else null end),
  sum(case cc.class_num when 5 then cc.category else null end),
  sum(case cc.class_num when 6 then cc.category else null end),
  sum(case cc.class_num when 7 then cc.category else null end),
  sum(case cc.class_num when 8 then cc.category else null end),
  sum(case cc.class_num when 9 then cc.category else null end)
from curriculum c
  join curr_cat cc on c.id = cc.curr_id
group by c.id, c.name, c.period_for_print, c.period, c.pos
;



/* View: V_CURRICULUM_CAT */
CREATE VIEW V_CURRICULUM_CAT(
    ID,
    C_0,
    C_1,
    C_2,
    C_3,
    C_4,
    C_5,
    C_6,
    C_7,
    C_8,
    C_9,
    C_NAME_0,
    C_NAME_1,
    C_NAME_2,
    C_NAME_3,
    C_NAME_4,
    C_NAME_5,
    C_NAME_6,
    C_NAME_7,
    C_NAME_8,
    C_NAME_9)
AS
select CC.curr_id,
  sum(case CC.class_num when 0 then CC.category else null end),
  sum(case CC.class_num when 1 then CC.category else null end),
  sum(case CC.class_num when 2 then CC.category else null end),
  sum(case CC.class_num when 3 then CC.category else null end),
  sum(case CC.class_num when 4 then CC.category else null end),
  sum(case CC.class_num when 5 then CC.category else null end),
  sum(case CC.class_num when 6 then CC.category else null end),
  sum(case CC.class_num when 7 then CC.category else null end),
  sum(case CC.class_num when 8 then CC.category else null end),
  sum(case CC.class_num when 9 then CC.category else null end),

  min(case CC.class_num when 0 then c_name else null end),
  min(case CC.class_num when 1 then c_name else null end),
  min(case CC.class_num when 2 then c_name else null end),
  min(case CC.class_num when 3 then c_name else null end),
  min(case CC.class_num when 4 then c_name else null end),
  min(case CC.class_num when 5 then c_name else null end),
  min(case CC.class_num when 6 then c_name else null end),
  min(case CC.class_num when 7 then c_name else null end),
  min(case CC.class_num when 8 then c_name else null end),
  min(case CC.class_num when 9 then c_name else null end)
from
  (
    select
      cc.curr_id,
      cc.class_num,
      cc.category,
      case cc.category
        when 0 then 'мл'
        when 1 then 'ст'
        else ''
      end c_name
    from curr_cat cc
  ) cc
group by cc.curr_id
;



/* View: V_CURRICULUM_REC */
CREATE VIEW V_CURRICULUM_REC(
    ID,
    CURR_ID,
    NUM,
    SUBJ_ID,
    SUBJ_CODE,
    SUBJ_NAME,
    GROUP_QTY,
    CLOCK_0,
    CLOCK_1,
    CLOCK_2,
    CLOCK_3,
    CLOCK_4,
    CLOCK_5,
    CLOCK_6,
    CLOCK_7,
    CLOCK_8,
    CLOCK_9,
    YT,
    OT,
    CT)
AS
select CR.id, CR.curr_id, CR.num, CR.subject_id, S."Code", S."Name", CR.group_qty,
  sum(case CRT.class_num when 0 then CRT.c_time else null end),
  sum(case CRT.class_num when 1 then CRT.c_time else null end),
  sum(case CRT.class_num when 2 then CRT.c_time else null end),
  sum(case CRT.class_num when 3 then CRT.c_time else null end),
  sum(case CRT.class_num when 4 then CRT.c_time else null end),
  sum(case CRT.class_num when 5 then CRT.c_time else null end),
  sum(case CRT.class_num when 6 then CRT.c_time else null end),
  sum(case CRT.class_num when 7 then CRT.c_time else null end),
  sum(case CRT.class_num when 8 then CRT.c_time else null end),
  sum(case CRT.class_num when 9 then CRT.c_time else null end),
  sum(case when S."Code" <> 1 and c.category = 0 then CRT.c_time end),
  sum(case when S."Code" <> 1 and c.category = 1 then CRT.c_time end),
  sum(case when S."Code" = 1 then CRT.c_time end)
from curr_rec CR
  inner join "Subject"     S   on S.id = CR.subject_id
  left  join curr_rec_time CRT on CR.curr_id = CRT.curr_id and CR.id = CRT.curr_rec_id
  left  join curr_cat      C   on C.curr_id = CRT.curr_id and C.class_num = CRT.class_num
group by cr.id, CR.curr_id, CR.num, CR.subject_id, S."Code", S."Name", CR.group_qty
;
;



/* View: V_CURRICULUM_SUM */
CREATE VIEW V_CURRICULUM_SUM(
    ID,
    T0YO,
    T1YO,
    T2YO,
    T3YO,
    T4YO,
    T5YO,
    T6YO,
    T7YO,
    T8YO,
    T9YO,
    T0C,
    T1C,
    T2C,
    T3C,
    T4C,
    T5C,
    T6C,
    T7C,
    T8C,
    T9C,
    T0A,
    T1A,
    T2A,
    T3A,
    T4A,
    T5A,
    T6A,
    T7A,
    T8A,
    T9A,
    YT_SUM,
    OT_SUM,
    CT_SUM,
    T_SUM,
    GR_YO,
    GR_C,
    GR_ALL)
AS
select
  c.id,

  sum(case when CRT.class_num = 0 and S."Code" <> 1 then CRT.c_time else 0 end) T0YO,
  sum(case when CRT.class_num = 1 and S."Code" <> 1 then CRT.c_time else 0 end) T1YO,
  sum(case when CRT.class_num = 2 and S."Code" <> 1 then CRT.c_time else 0 end) T2YO,
  sum(case when CRT.class_num = 3 and S."Code" <> 1 then CRT.c_time else 0 end) T3YO,
  sum(case when CRT.class_num = 4 and S."Code" <> 1 then CRT.c_time else 0 end) T4YO,
  sum(case when CRT.class_num = 5 and S."Code" <> 1 then CRT.c_time else 0 end) T5YO,
  sum(case when CRT.class_num = 6 and S."Code" <> 1 then CRT.c_time else 0 end) T6YO,
  sum(case when CRT.class_num = 7 and S."Code" <> 1 then CRT.c_time else 0 end) T7YO,
  sum(case when CRT.class_num = 8 and S."Code" <> 1 then CRT.c_time else 0 end) T8YO,
  sum(case when CRT.class_num = 9 and S."Code" <> 1 then CRT.c_time else 0 end) T9YO,

  sum(case when CRT.class_num = 0 and S."Code" = 1  then CRT.c_time else 0 end) T0C,
  sum(case when CRT.class_num = 1 and S."Code" = 1  then CRT.c_time else 0 end) T1C,
  sum(case when CRT.class_num = 2 and S."Code" = 1  then CRT.c_time else 0 end) T2C,
  sum(case when CRT.class_num = 3 and S."Code" = 1  then CRT.c_time else 0 end) T3C,
  sum(case when CRT.class_num = 4 and S."Code" = 1  then CRT.c_time else 0 end) T4C,
  sum(case when CRT.class_num = 5 and S."Code" = 1  then CRT.c_time else 0 end) T5C,
  sum(case when CRT.class_num = 6 and S."Code" = 1  then CRT.c_time else 0 end) T6C,
  sum(case when CRT.class_num = 7 and S."Code" = 1  then CRT.c_time else 0 end) T7C,
  sum(case when CRT.class_num = 8 and S."Code" = 1  then CRT.c_time else 0 end) T8C,
  sum(case when CRT.class_num = 9 and S."Code" = 1  then CRT.c_time else 0 end) T9C,

  sum(case when CRT.class_num = 0                   then CRT.c_time else 0 end) T0A,
  sum(case when CRT.class_num = 1                   then CRT.c_time else 0 end) T1A,
  sum(case when CRT.class_num = 2                   then CRT.c_time else 0 end) T2A,
  sum(case when CRT.class_num = 3                   then CRT.c_time else 0 end) T3A,
  sum(case when CRT.class_num = 4                   then CRT.c_time else 0 end) T4A,
  sum(case when CRT.class_num = 5                   then CRT.c_time else 0 end) T5A,
  sum(case when CRT.class_num = 6                   then CRT.c_time else 0 end) T6A,
  sum(case when CRT.class_num = 7                   then CRT.c_time else 0 end) T7A,
  sum(case when CRT.class_num = 8                   then CRT.c_time else 0 end) T8A,
  sum(case when CRT.class_num = 9                   then CRT.c_time else 0 end) T9A,

  sum(case when S."Code" <> 1 then coalesce(CRT.c_time, 0)*(1 - CC.category) end) YT_SUM,
  sum(case when S."Code" <> 1 then coalesce(CRT.c_time, 0)*CC.category       end) OT_SUM,
  sum(case when S."Code" =  1 then coalesce(CRT.c_time, 0)                   end) CT_SUM,
  sum(coalesce(CRT.c_time, 0))                                                    T_SUM,

  sum(case when S."Code" <> 1 and CRT.class_num = 1 then CR.group_qty        end) GR_YO,
  sum(case when S."Code" =  1 and CRT.class_num = 1 then CR.group_qty        end) GR_C,
  sum(case when CRT.class_num = 1                   then cr.group_qty        end) GR_ALL

from curriculum c
  left join curr_rec      cr  on cr.curr_id = c.id
  left join curr_rec_time crt on crt.curr_id = c.id and cr.id = crt.curr_rec_id
  left join curr_cat      cc  on cc.curr_id = c.id  and cc.class_num = crt.class_num
  left join "Subject"     s   on s."ID" = cr.subject_id
group by c.id
;



/* View: V_DEPARTMENT */
CREATE VIEW V_DEPARTMENT(
    ID,
    CODE,
    NAME,
    INFO,
    CURR_ID,
    CURR_NAME,
    CURR_PERIOD)
AS
select
  d.id     id,
  d."Code" code,
  d."Name" name,
  d."Info" info,
  c.id     curr_id,
  c.name   curr_name,
  c.period curr_period
from "Department" d
  left join curriculum c on c.id = d."CurriculumID"
order by d.pos, d."Name"
;



/* View: V_DEPT_IND_QTY */
CREATE VIEW V_DEPT_IND_QTY(
    ID,
    DEPT_NAME,
    PERIOD,
    CAT_0,
    CAT_1,
    CAT_2,
    CAT_3,
    CAT_4,
    CAT_5,
    CAT_6,
    CAT_7,
    CAT_8,
    CAT_9,
    Q_0,
    Q_1,
    Q_01,
    Q_2,
    Q_3,
    Q_4,
    Q_5,
    Q_6,
    Q_7,
    Q_8,
    Q_9,
    Q_Y,
    Q_O,
    Q_C)
AS
select d.id, d."Name", vc.period,
  vc.cat_0, vc.cat_1, vc.cat_2, vc.cat_3, vc.cat_4, vc.cat_5, vc.cat_6, vc.cat_7, vc.cat_8, vc.cat_9,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and si."Class" = 0 and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class"
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class")) q_0,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and si."Class" = 1 and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class"
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class")) q_1,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and si."Class" in (0, 1) and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class"
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class")) q_01,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and si."Class" = 2 and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class"
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class")) q_2,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and si."Class" = 3 and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class"
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class")) q_3,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and si."Class" = 4 and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class"
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class")) q_4,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and si."Class" = 5 and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class"
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class")) q_5,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and si."Class" = 6 and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class"
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class")) q_6,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and si."Class" = 7 and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class"
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class")) q_7,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and si."Class" = 8 and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class"
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class"
    )) q_8,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and si."Class" = 9 and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class"
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class"
    )) q_9,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class" and cci.category = 0
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id and subji."Code" = 0
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class")) q_y,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class" and cci.category = 1
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id and subji."Code" = 0
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class")) q_o,
    sum((
      select count(distinct si.id)
      from "Student_Plan" stpi
        join "Student" si on stpi."StudentID" = si.id and stpi."Use" = 1 and
          si."ReleaseDate" is null and (si."AcademyBDate" is null or si."AcademyEDate" is not null)
        join "Specialization" spi on spi.id = si."SpecializationID"
        join "Department" di on di.id = spi."DepartmentID" and di.id = d.id
        join curr_cat cci on cci.curr_id = di."CurriculumID" and cci.class_num = si."Class"
        join curr_rec cri on di."CurriculumID" = cri.curr_id and cri.id = stpi.curr_rec_id and cri.group_qty = 1
        join "Subject" subji on subji.id = cri.subject_id and subji."Code" = 1
        join curr_rec_time crti on crti.curr_id = cri.curr_id and crti.curr_rec_id = cri.id and
          crti.class_num = si."Class")) q_c
from "Department" d
  left join v_curriculum vc on d."CurriculumID" = vc.id
group by d.id, d."Name", vc.period,
  vc.cat_0, vc.cat_1, vc.cat_2, vc.cat_3, vc.cat_4,
  vc.cat_5, vc.cat_6, vc.cat_7, vc.cat_8, vc.cat_9
;



/* View: V_LTG_I_SUBJ_RECORD */
CREATE VIEW V_LTG_I_SUBJ_RECORD(
    LTG_ID,
    LTG_SUBJECT_ID,
    POS_SUBJECT,
    NAME_SUBJECT,
    CURR_ID,
    CURR_REC_ID,
    SUBJECT_ID,
    GROUP_QTY)
AS
SELECT
  LTG.ID,
  LTGIS.ID,
  LTGIS.POS,
  LTGIS.NAME,
  LTGISC.CURR_ID,
  LTGISC.CURR_REC_ID,
  CR.SUBJECT_ID,
  CR.GROUP_QTY
FROM LEARN_TIME_GRID LTG
  LEFT JOIN LTG_I_SUBJECT LTGIS ON
    LTG.ID = LTGIS.LTG_ID
  LEFT JOIN LTG_I_SUBJ_CURR LTGISC ON
    LTGISC.LTG_ID = LTG.ID AND
    LTGISC.LTG_I_SUBJ_ID = LTGIS.ID
  LEFT JOIN CURR_REC CR ON
    CR.CURR_ID = LTGISC.CURR_ID AND
    CR.ID = LTGISC.CURR_REC_ID
;



/* View: V_LTG_TOTAL_TABLE */
CREATE VIEW V_LTG_TOTAL_TABLE(
    T5_Y,
    T5_O,
    T5_C,
    T5_V_Y,
    T5_V_O,
    T5_V_C,
    T7_Y,
    T7_O,
    T7_C,
    T7_V_Y,
    T7_V_O,
    T7_V_C,
    TOOD_Y,
    TOOD_O,
    TOOD_C,
    TOOD_V_Y,
    TOOD_V_O,
    TOOD_V_C)
AS
SELECT
  SUM(CASE WHEN LISC.LTG_ID = 1 AND CC.category = 0 AND SBJ."Code" = 0 AND STP."TeacherID" <> 0 THEN CRT.c_time else null end) T5_Y,
  SUM(CASE WHEN LISC.LTG_ID = 1 AND CC.category = 1 AND SBJ."Code" = 0 AND STP."TeacherID" <> 0 THEN CRT.c_time else null end) T5_O,
  SUM(CASE WHEN LISC.LTG_ID = 1 AND SBJ."Code" = 1 AND STP."TeacherID" <> 0 THEN CRT.c_time ELSE NULL END) T5_C,
  SUM(CASE WHEN LISC.LTG_ID = 1 AND CC.category = 0 AND SBJ."Code" = 0 AND STP."TeacherID" = 0 THEN CRT.c_time else null end) T5_V_Y,
  SUM(CASE WHEN LISC.LTG_ID = 1 AND CC.category = 1 AND SBJ."Code" = 0 AND STP."TeacherID" = 0 THEN CRT.c_time else null end) T5_V_O,
  SUM(CASE WHEN LISC.LTG_ID = 1 AND SBJ."Code" = 1 AND STP."TeacherID" = 0 THEN CRT.c_time ELSE NULL END) T5_V_C,

  SUM(CASE WHEN LISC.LTG_ID = 2 AND CC.category = 0 AND SBJ."Code" = 0 AND STP."TeacherID" <> 0 THEN CRT.c_time else null end) T7_Y,
  SUM(CASE WHEN LISC.LTG_ID = 2 AND CC.category = 1 AND SBJ."Code" = 0 AND STP."TeacherID" <> 0 THEN CRT.c_time else null end) T7_O,
  SUM(CASE WHEN LISC.LTG_ID = 2 AND SBJ."Code" = 1 AND STP."TeacherID" <> 0 THEN CRT.c_time ELSE NULL END) T7_C,
  SUM(CASE WHEN LISC.LTG_ID = 2 AND CC.category = 0 AND SBJ."Code" = 0 AND STP."TeacherID" = 0 THEN CRT.c_time else null end) T7_V_Y,
  SUM(CASE WHEN LISC.LTG_ID = 2 AND CC.category = 1 AND SBJ."Code" = 0 AND STP."TeacherID" = 0 THEN CRT.c_time else null end) T7_V_O,
  SUM(CASE WHEN LISC.LTG_ID = 2 AND SBJ."Code" = 1 AND STP."TeacherID" = 0 THEN CRT.c_time ELSE NULL END) T7_V_C,

  SUM(CASE WHEN LISC.LTG_ID = 3 AND CC.category = 0 AND SBJ."Code" = 0 AND STP."TeacherID" <> 0 THEN CRT.c_time else null end) TOOD_Y,
  SUM(CASE WHEN LISC.LTG_ID = 3 AND CC.category = 1 AND SBJ."Code" = 0 AND STP."TeacherID" <> 0 THEN CRT.c_time else null end) TOOD_O,
  SUM(CASE WHEN LISC.LTG_ID = 3 AND SBJ."Code" = 1 AND STP."TeacherID" <> 0 THEN CRT.c_time ELSE NULL END) TOOD_C,
  SUM(CASE WHEN LISC.LTG_ID = 3 AND CC.category = 0 AND SBJ."Code" = 0 AND STP."TeacherID" = 0 THEN CRT.c_time else null end) TOOD_V_Y,
  SUM(CASE WHEN LISC.LTG_ID = 3 AND CC.category = 1 AND SBJ."Code" = 0 AND STP."TeacherID" = 0 THEN CRT.c_time else null end) TOOD_V_O,
  SUM(CASE WHEN LISC.LTG_ID = 3 AND SBJ."Code" = 1 AND STP."TeacherID" = 0 THEN CRT.c_time ELSE NULL END) TOOD_V_C
FROM LTG_I_SUBJ_CURR LISC
  INNER JOIN CURR_REC CR ON
    CR.curr_id = LISC.curr_id AND
    CR.id = LISC.curr_rec_id
  INNER JOIN "Subject" SBJ ON
    SBJ.id = CR.subject_id
  INNER JOIN CURR_REC_TIME CRT ON
    CRT.curr_id = LISC.curr_id and
    CRT.curr_rec_id = LISC.curr_rec_id and CRT.c_time > 0
  INNER JOIN CURR_CAT CC ON
    CC.curr_id = LISC.curr_id and
    CRT.class_num = CC.class_num
  INNER JOIN "Department" D ON
    D."CurriculumID" = LISC.curr_id
  INNER JOIN "Specialization" SP ON
    D.id = SP."DepartmentID"
  INNER JOIN "Student" S ON
    S."SpecializationID" = SP.id AND
    S.released = 0 AND S.academy = 0 AND
    S."Class" = CRT.class_num
  INNER JOIN "Student_Plan" STP ON
    STP."Use" > 0 AND STP."StudentID" = S.id AND
    STP.curr_rec_id = CR.id AND STP."TeacherID" IS NOT NULL
UNION ALL
SELECT
  SUM(CASE WHEN LTGG.LTG_ID = 1 AND CC.category = 0 AND S."Code" = 0 AND TG.TEACHER_ID <> 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) T5_Y,
  SUM(CASE WHEN LTGG.LTG_ID = 1 AND CC.category = 1 AND S."Code" = 0 AND TG.TEACHER_ID <> 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) T5_O,
  SUM(CASE WHEN LTGG.LTG_ID = 1 AND S."Code" = 1 AND TG.TEACHER_ID <> 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) T5_C,
  SUM(CASE WHEN LTGG.LTG_ID = 1 AND CC.category = 0 AND S."Code" = 0 AND TG.TEACHER_ID = 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) T5_V_Y,
  SUM(CASE WHEN LTGG.LTG_ID = 1 AND CC.category = 1 AND S."Code" = 0 AND TG.TEACHER_ID = 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) T5_V_O,
  SUM(CASE WHEN LTGG.LTG_ID = 1 AND S."Code" = 1 AND TG.TEACHER_ID = 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) T5_V_C,

  SUM(CASE WHEN LTGG.LTG_ID = 2 AND CC.category = 0 AND S."Code" = 0 AND TG.TEACHER_ID <> 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) T7_Y,
  SUM(CASE WHEN LTGG.LTG_ID = 2 AND CC.category = 1 AND S."Code" = 0 AND TG.TEACHER_ID <> 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) T7_O,
  SUM(CASE WHEN LTGG.LTG_ID = 2 AND S."Code" = 1 AND TG.TEACHER_ID <> 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) T7_C,
  SUM(CASE WHEN LTGG.LTG_ID = 2 AND CC.category = 0 AND S."Code" = 0 AND TG.TEACHER_ID = 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) T7_V_Y,
  SUM(CASE WHEN LTGG.LTG_ID = 2 AND CC.category = 1 AND S."Code" = 0 AND TG.TEACHER_ID = 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) T7_V_O,
  SUM(CASE WHEN LTGG.LTG_ID = 2 AND S."Code" = 1 AND TG.TEACHER_ID = 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) T7_V_C,

  SUM(CASE WHEN LTGG.LTG_ID = 3 AND CC.category = 0 AND S."Code" = 0 AND TG.TEACHER_ID <> 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) TOOD_Y,
  SUM(CASE WHEN LTGG.LTG_ID = 3 AND CC.category = 1 AND S."Code" = 0 AND TG.TEACHER_ID <> 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) TOOD_O,
  SUM(CASE WHEN LTGG.LTG_ID = 3 AND S."Code" = 1 AND TG.TEACHER_ID <> 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) TOOD_C,
  SUM(CASE WHEN LTGG.LTG_ID = 3 AND CC.category = 0 AND S."Code" = 0 AND TG.TEACHER_ID = 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) TOOD_V_Y,
  SUM(CASE WHEN LTGG.LTG_ID = 3 AND CC.category = 1 AND S."Code" = 0 AND TG.TEACHER_ID = 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) TOOD_V_O,
  SUM(CASE WHEN LTGG.LTG_ID = 3 AND S."Code" = 1 AND TG.TEACHER_ID = 0 THEN TG.GROUP_Q*CRT.C_TIME ELSE NULL END) TOOD_V_C
FROM LTG_GROUPING LTGG
  INNER JOIN GROUPING_SUBJ_CURR_ID GSCI ON
    LTGG.GROUPING_ID = GSCI.GROUPING_ID
  LEFT JOIN TEACHER_GROUP TG ON
    TG.GROUPING_ID = LTGG.GROUPING_ID AND
    TG.GR_SUBJ_ID = GSCI.GROUPING_SUBJ_ID AND
    TG.GROUP_Q > 0
  LEFT JOIN CURR_REC CR ON
    CR.CURR_ID = GSCI.CURR_ID AND
    CR.ID = GSCI.CURR_REC_ID
  LEFT JOIN "Subject" S ON
    S.ID = CR.SUBJECT_ID
  LEFT JOIN CURR_REC_TIME CRT ON
    CRT.CURR_ID = GSCI.CURR_ID AND
    CRT.CURR_REC_ID = GSCI.CURR_REC_ID AND
    CRT.CLASS_NUM = TG.CLASS_NUM AND
    CRT.C_TIME > 0
  LEFT JOIN CURR_CAT CC ON
    CC.CURR_ID = CRT.CURR_ID AND
    TG.CLASS_NUM = CC.CLASS_NUM
WHERE CRT.CURR_ID = (
  SELECT MIN(GSCI2.CURR_ID)
  FROM GROUPING_SUBJ_CURR_ID GSCI2
  WHERE GSCI2.GROUPING_ID = LTGG.GROUPING_ID AND GSCI2.GROUPING_SUBJ_ID = TG.GR_SUBJ_ID)
;



/* View: V_MAIN_TAB_PARAMS */
CREATE VIEW V_MAIN_TAB_PARAMS(
    CURR_MONTH_DAYS_QTY,
    CURR_MONTH_WORK_DAYS_QTY)
AS
select
  extract(day from (dateadd(1 month to cn.system_date - extract(day from cn.system_date) + 1) - 1)) curr_month_days_qty,
  (
    select count(*)
    from calendar ca
    where ca.the_day between
      cn.system_date - extract(day from cn.system_date) + 1
      and
      cn.system_date - extract(day from cn.system_date) + 32 - extract(day from cn.system_date - extract(day from cn.system_date) + 32)
      and
      ca.is_holiday is null
  ) curr_month_work_days_qty
from constants cn
;



/* View: V_TEACHER_ABSENT_CODES */
CREATE VIEW V_TEACHER_ABSENT_CODES(
    TEACHER_ID,
    ABSENT_DATE,
    CODES)
AS
select
  ta.teacher_id,
  ta.absent_date,
  list(a.code, ' ') codes
from teacher_absent ta
  left join absent_type a on a.id = ta.absent_type_id
group by ta.teacher_id, ta.absent_date
;



/* View: V_MAIN_TAB_PART_1 */
CREATE VIEW V_MAIN_TAB_PART_1(
    TEACHER_ID,
    TEACHER_NAME,
    TEACHER_POST,
    DAY_1,
    DAY_2,
    DAY_3,
    DAY_4,
    DAY_5,
    DAY_6,
    DAY_7,
    DAY_8,
    DAY_9,
    DAY_10,
    DAY_11,
    DAY_12,
    DAY_13,
    DAY_14,
    DAY_15,
    DAY_16,
    DAY_17,
    DAY_18,
    DAY_19,
    DAY_20,
    DAY_21,
    DAY_22,
    DAY_23,
    DAY_24,
    DAY_25,
    DAY_26,
    DAY_27,
    DAY_28,
    DAY_29,
    DAY_30,
    DAY_31,
    PRECENCE_QTY)
AS
select
  t.id,
  t."Name" teacher_name,
  p.print_short teacher_post,
  list(case when extract(day from c.the_day) =  1 and tac.codes is not null then tac.codes when extract(day from c.the_day) =  1 and c.is_holiday = 'Y' then 'В' end) day_1,
  list(case when extract(day from c.the_day) =  2 and tac.codes is not null then tac.codes when extract(day from c.the_day) =  2 and c.is_holiday = 'Y' then 'В' end) day_2,
  list(case when extract(day from c.the_day) =  3 and tac.codes is not null then tac.codes when extract(day from c.the_day) =  3 and c.is_holiday = 'Y' then 'В' end) day_3,
  list(case when extract(day from c.the_day) =  4 and tac.codes is not null then tac.codes when extract(day from c.the_day) =  4 and c.is_holiday = 'Y' then 'В' end) day_4,
  list(case when extract(day from c.the_day) =  5 and tac.codes is not null then tac.codes when extract(day from c.the_day) =  5 and c.is_holiday = 'Y' then 'В' end) day_5,
  list(case when extract(day from c.the_day) =  6 and tac.codes is not null then tac.codes when extract(day from c.the_day) =  6 and c.is_holiday = 'Y' then 'В' end) day_6,
  list(case when extract(day from c.the_day) =  7 and tac.codes is not null then tac.codes when extract(day from c.the_day) =  7 and c.is_holiday = 'Y' then 'В' end) day_7,
  list(case when extract(day from c.the_day) =  8 and tac.codes is not null then tac.codes when extract(day from c.the_day) =  8 and c.is_holiday = 'Y' then 'В' end) day_8,
  list(case when extract(day from c.the_day) =  9 and tac.codes is not null then tac.codes when extract(day from c.the_day) =  9 and c.is_holiday = 'Y' then 'В' end) day_9,
  list(case when extract(day from c.the_day) = 10 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 10 and c.is_holiday = 'Y' then 'В' end) day_10,
  list(case when extract(day from c.the_day) = 11 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 11 and c.is_holiday = 'Y' then 'В' end) day_11,
  list(case when extract(day from c.the_day) = 12 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 12 and c.is_holiday = 'Y' then 'В' end) day_12,
  list(case when extract(day from c.the_day) = 13 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 13 and c.is_holiday = 'Y' then 'В' end) day_13,
  list(case when extract(day from c.the_day) = 14 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 14 and c.is_holiday = 'Y' then 'В' end) day_14,
  list(case when extract(day from c.the_day) = 15 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 15 and c.is_holiday = 'Y' then 'В' end) day_15,
  list(case when extract(day from c.the_day) = 16 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 16 and c.is_holiday = 'Y' then 'В' end) day_16,
  list(case when extract(day from c.the_day) = 17 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 17 and c.is_holiday = 'Y' then 'В' end) day_17,
  list(case when extract(day from c.the_day) = 18 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 18 and c.is_holiday = 'Y' then 'В' end) day_18,
  list(case when extract(day from c.the_day) = 19 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 19 and c.is_holiday = 'Y' then 'В' end) day_19,
  list(case when extract(day from c.the_day) = 20 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 20 and c.is_holiday = 'Y' then 'В' end) day_20,
  list(case when extract(day from c.the_day) = 21 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 21 and c.is_holiday = 'Y' then 'В' end) day_21,
  list(case when extract(day from c.the_day) = 22 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 22 and c.is_holiday = 'Y' then 'В' end) day_22,
  list(case when extract(day from c.the_day) = 23 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 23 and c.is_holiday = 'Y' then 'В' end) day_23,
  list(case when extract(day from c.the_day) = 24 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 24 and c.is_holiday = 'Y' then 'В' end) day_24,
  list(case when extract(day from c.the_day) = 25 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 25 and c.is_holiday = 'Y' then 'В' end) day_25,
  list(case when extract(day from c.the_day) = 26 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 26 and c.is_holiday = 'Y' then 'В' end) day_26,
  list(case when extract(day from c.the_day) = 27 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 27 and c.is_holiday = 'Y' then 'В' end) day_27,
  list(case when extract(day from c.the_day) = 28 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 28 and c.is_holiday = 'Y' then 'В' end) day_28,
  list(case when extract(day from c.the_day) = 29 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 29 and c.is_holiday = 'Y' then 'В' end) day_29,
  list(case when extract(day from c.the_day) = 30 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 30 and c.is_holiday = 'Y' then 'В' end) day_30,
  list(case when extract(day from c.the_day) = 31 and tac.codes is not null then tac.codes when extract(day from c.the_day) = 31 and c.is_holiday = 'Y' then 'В' end) day_31,
  sum(case when c.is_holiday = 'Y' or tac.codes is not null then null else 1 end) precence_qty
from "Teacher" t
  inner join main_tab       mt on mt.teacher_id = t.id
  cross join constants      cn
  left  join "Post"         p   on p.id = t."PostID"
  inner join calendar       c   on
    c.the_day
      between
        cn.system_date - extract(day from cn.system_date) + 1
        and
        cn.system_date - extract(day from cn.system_date) + 32 - extract(day from cn.system_date - extract(day from cn.system_date) + 32)
  left join v_teacher_absent_codes tac on tac.teacher_id = t.id and tac.absent_date = c.the_day
where t.id != 0
group by t."Name", t.id, p.print_short
order by t."Name", t.id, p.print_short
;



/* View: V_TEACHER */
CREATE VIEW V_TEACHER(
    ID,
    TAB_NUM,
    "Name",
    "FilialID",
    "SubjectID",
    SUBJECT_NAME,
    "EducationID",
    "PostID",
    POST_NAME,
    "StageDate",
    "BirthDate",
    "EnterDate",
    "ReleaseDate",
    "GradeID",
    "ConcertGradeID",
    "Diploma",
    "Address",
    "Telephone",
    STAGE_Y,
    STAGE_M,
    STAGE_D,
    ID_GRADE_ADD,
    ID_GRADE_CONCERT_ADD,
    ID_TITLE,
    TITLE_NAME,
    ID_CATEGORY,
    ID_CATEGORY_CONC,
    CATEGORY_T,
    CATEGORY_C,
    CATEGORY_T_DATE,
    CATEGORY_C_DATE,
    QUALIFICATION_ID,
    EDUCATION_2_ID,
    QUALIFICATION_2_ID,
    DIPLOMA_2,
    EDUCATION_NAME,
    EDUCATION_2_NAME,
    QUALIFICATION_NAME,
    QUALIFICATION_2_NAME,
    REAL_STAGE_M,
    REAL_STAGE_Y)
AS
select
  t.id, t.tab_num, t."Name", t."FilialID",
  t."SubjectID", s."Name",
  t."EducationID",
  t."PostID", p."Name",
  t."StageDate", t."BirthDate", t."EnterDate", t."ReleaseDate",
  t."GradeID", t."ConcertGradeID",
  t."Diploma", t."Address", t."Telephone",
  t.stage_y, t.stage_m, t.stage_d,
  t.id_grade_add, t.id_grade_concert_add,
  t.id_title, tk.f_name, t.id_category, t.id_category_conc,
  tckt.f_name, tckc.f_name, t.category_date, t.category_conc_date,
  t.qualification_id, t.education_2_id, t.qualification_2_id, t.diploma_2,
  (select "Name" from "Education" where id = t."EducationID"),
  (select "Name" from "Education" where id = t.education_2_id),
  (select name from qualification where id = t.qualification_id),
  (select name from qualification where id = t.qualification_2_id),
  cast(
    mod(
      cast(current_date as date) - cast(addday(addyear(addmonth(t."StageDate", -coalesce(t.stage_m, 0)), -coalesce(t.stage_y, 0)), -coalesce(t.stage_d, 0)) as date),
      365
    )*12/365
    as integer
  ),
  cast(
    div(
      cast(current_date as date) - cast(addday(addyear(addmonth(t."StageDate", -coalesce(t.stage_m, 0)), -coalesce(t.stage_y, 0)), -coalesce(t.stage_d, 0)) as date),
      365
    )
    as integer
  )
from "Teacher" t
  left join teacher_title_kind tk on tk.f_id = t.id_title
  left join teacher_cat_kind tckt on
    tckt.f_id = t.id_category
  left join teacher_cat_kind tckc on
    tckc.f_id = t.id_category_conc
  left join "Post" p on p.id = t."PostID"
  left join "Subject" s on s.id = t."SubjectID"
;



/* View: V_R_EDUCATION */
CREATE VIEW V_R_EDUCATION(
    TEACHER_ID,
    TEACHER_NAME,
    POST_NAME,
    SUBJECT_NAME,
    IS_MIDDLE,
    MIDDLE_DIPLOMA,
    MIDDLE_QUALIFICATION,
    IS_HIGH,
    HIGH_DIPLOMA,
    HIGH_QUALIFICATION)
AS
select
  t.id,
  t."Name",
  t.post_name,
  t.subject_name, 
  -- среднее образование
  case
    when t."EducationID"  in (3) then 1
    when t.education_2_id in (3) then 1
    else null
  end,
  case
    when t."EducationID"  in (3) then t."Diploma"
    when t.education_2_id in (3) then t.diploma_2
    else null
  end,
  case
    when t."EducationID"  in (3) then t.qualification_name
    when t.education_2_id in (3) then t.qualification_2_name
    else null
  end,
  -- высшее образование
  case
    when t."EducationID"  in (1) then 1
    when t.education_2_id in (1) then 1
    else null
  end,
  case
    when t."EducationID"  in (1) then t."Diploma"
    when t.education_2_id in (1) then t.diploma_2
    else null
  end,
  case
    when t."EducationID"  in (1) then t.qualification_name
    when t.education_2_id in (1) then t.qualification_2_name
    else null
  end
from v_teacher t
order by t."Name"
;



/* View: V_R_STAGE */
CREATE VIEW V_R_STAGE(
    TEACHER_ID,
    TEACHER_NAME,
    POST_NAME,
    SUBJECT_NAME,
    BIRTHDATE,
    CURR_STAGE_Y,
    CURR_STAGE_M)
AS
select
  t.id,
  t."Name",
  t.post_name,
  t.subject_name,
  t."BirthDate",
  stage.curr_stage_y,
  stage.curr_stage_m
from v_teacher t
  cross join get_curr_stage(t."StageDate", t.stage_y, t.stage_m, t.stage_d) stage
order by t."Name"
;



/* View: V_TARIFFICATION */
CREATE VIEW V_TARIFFICATION(
    DOC_DATE,
    INFO,
    SYS_DATE,
    COEF_Y_TIME,
    COEF_O_TIME,
    COEF_C_TIME,
    T_RATE_B,
    T_RATE_T,
    T_RATE_C,
    T_INC_C_T,
    T_INC_C_C,
    T_B_TIME_Y,
    T_B_TIME_O,
    T_B_TIME_C,
    VSUM_Y,
    VSUM_O,
    VSUM_C,
    VSUM_TOTAL)
AS
select
  t.doc_date,
  t.info,
  t.sys_date,
  t.coef_y_time,
  t.coef_o_time,
  t.coef_c_time,
  (select cf.f_value from v_const_float cf where cf.f_code = 'Rate.Basic'),
  rate_t.f_value,
  rate_c.f_value,
  (select cf.f_value from v_const_float cf where cf.f_code = 'IncreasingCoef.Teacher'),
  (select cf.f_value from v_const_float cf where cf.f_code = 'IncreasingCoef.Concertmaster'),
  tr.t_b_time_y,
  tr.t_b_time_o,
  tr.t_b_time_c,
  tr.t_b_time_y * rate_t.f_value / t.coef_y_time,
  tr.t_b_time_o * rate_t.f_value / t.coef_o_time,
  tr.t_b_time_c * rate_c.f_value / t.coef_c_time,
  tr.t_b_time_y * rate_t.f_value / t.coef_y_time +
  tr.t_b_time_o * rate_t.f_value / t.coef_o_time +
  tr.t_b_time_c * rate_c.f_value / t.coef_c_time
from tariffication t
  left join tariffication_record tr on
    t.doc_date = tr.doc_date and
    tr.teacher_id = 0
  left join v_const_float rate_t on rate_t.f_code = 'Rate.Teacher'
  left join v_const_float rate_c on rate_c.f_code = 'Rate.Concertmaster'
;



/* View: V_TAR_RECORD */
CREATE VIEW V_TAR_RECORD(
    DOC_DATE,
    TEACHER_ID,
    T_NAME,
    T_POST,
    T_SUBJ,
    T_EDUCATION,
    T_DIPLOMA,
    T_EDUCATION_2,
    T_DIPLOMA_2,
    T_STAGE_M,
    T_STAGE_Y,
    T_B_TIME_Y,
    T_B_TIME_O,
    T_B_TIME_C,
    T_MAIN_SALARY,
    T_CONC_SALARY,
    TITLE_NAME,
    CATEGORY_NAME,
    CATEGORY_DATE,
    CATEGORY_CONC_NAME,
    CATEGORY_CONC_DATE,
    PKU_T,
    PKU_C,
    SUM_Y,
    SUM_O,
    SUM_C,
    SUM_TOTAL,
    IS_FULL_TIME_TEACHER)
AS
select
  t.doc_date,
  --CONST.SYSTEM_DATE - addyear(addmonth(tr.t_stage_date, coalesce(tr.t_stage_m, 0)), coalesce(tr.t_stage_y, 0)),
  tr.teacher_id,
  tr.t_name,
  tr.t_post,
  tr.t_subj,
  tr.t_education,
  tr.t_diploma,
  tch.education_2_name,
  tch.diploma_2,
  tr.t_stage_m,
  tr.t_stage_y,
  tr.t_b_time_y,
  tr.t_b_time_o,
  tr.t_b_time_c,
  tr.t_main_salary,
  tr.t_concert_salary,
  ttk.f_print,
  tck.f_print,
  tch.category_t_date,
  tckc.f_print,
  tch.category_c_date,
  case when tch."PostID" in (4, 5, 6, 7, 8, 9) then 4 else null end,
  case when tch."PostID" in (1, 2, 3, 4, 5, 6) then 2 else null end,
  trunc(tr.t_b_time_y * tr.t_main_salary / cnst.ytcoef, 2),
  trunc(tr.t_b_time_o * tr.t_main_salary / cnst.otcoef, 2),
  trunc(tr.t_b_time_c * tr.t_concert_salary / cnst.ctcoef, 2),
  trunc(tr.t_b_time_y * tr.t_main_salary / cnst.ytcoef, 2) +
  trunc(tr.t_b_time_o * tr.t_main_salary / cnst.otcoef, 2) +
  trunc(tr.t_b_time_c * tr.t_concert_salary / cnst.ctcoef, 2),
  case when tch."PostID" in (1, 4, 7) then 1 else 0 end
from tariffication t
  inner join tariffication_record tr on
    t.doc_date = tr.doc_date
  inner join constants cnst on 1 = 1
  left join v_teacher tch on tch.id = tr.teacher_id
  left join teacher_title_kind ttk on ttk.f_id = tch.id_title
  left join teacher_cat_kind tck on tck.f_id = tch.id_category
  left join teacher_cat_kind tckc on tckc.f_id = tch.id_category_conc
where tr.teacher_id <> 0
;



/* View: V_R_TEACHER_PERCENTS */
CREATE VIEW V_R_TEACHER_PERCENTS(
    TEACHER_NAME,
    TEACHER_POST,
    TEACHER_CAT_NAME,
    TEACHER_CAT_CONC_NAME,
    CAT_COEF,
    CAT_COEF_SUM,
    PCT,
    PCT_SUM,
    TAR_SUM,
    TOTAL_SUM)
AS
select
  t."Name",
  p."Name",
  tk.f_print,
  tkc.f_print,
  case
    when t.id_category = 3 or t.id_category_conc = 3 then 0.2
    when t.id_category = 2 or t.id_category_conc = 2 then 0.15
    when t.id_category = 1 or t.id_category_conc = 1 then 0.1
    else null
  end                                                                 cat_coeff,
  case
    when t.id_category = 3 or t.id_category_conc = 3 then 0.2
    when t.id_category = 2 or t.id_category_conc = 2 then 0.15
    when t.id_category = 1 or t.id_category_conc = 1 then 0.1
    else null
  end * tr.sum_total                                                  cat_coef_sum,
  case
    when t.id_title is not null then 0.1
    else null
  end * 100                                                           pct,
  case
    when t.id_title is not null then 0.1
    else null
  end * tr.sum_total                                                  pct_sum,
  tr.sum_total                                                        tar_sum,
  (
    coalesce(
      case
        when t.id_category = 3 or t.id_category_conc = 3 then 0.2
        when t.id_category = 2 or t.id_category_conc = 2 then 0.15
        when t.id_category = 1 or t.id_category_conc = 1 then 0.1
        else null
      end,
      0
    )
    +
    coalesce(
      case
        when t.id_title is not null then 0.1
        else null
      end,
      0
    )
    +
    1
  )
  *
  tr.sum_total                                                                   total_sum
from "Teacher" t
  left join "Post" p on p.id = t."PostID"
  left join teacher_cat_kind  tk on t.id_category = tk.f_id
  left join teacher_cat_kind tkc on t.id_category_conc = tkc.f_id
  -- данные из последней тарификации
  left join v_tariffication  tar on tar.doc_date = (select max(doc_date) from tariffication)
  left join v_tar_record      tr on tr.teacher_id = t.id and tr.doc_date = tar.doc_date
where t."ReleaseDate" is null
  and t.id != 0
;



/* View: V_STUDENT_CURATOR_CLOCK */
CREATE VIEW V_STUDENT_CURATOR_CLOCK(
    ID_STUDENT,
    ID_TEACHER,
    TIME_Y,
    TIME_O,
    TIME_C)
AS
select
  st.id,
  stp."TeacherID",
  sum(CASE WHEN cc.category = 0 AND s."Code" = 0 THEN CRT.c_time ELSE NULL END),
  sum(CASE WHEN cc.category = 1 AND s."Code" = 0 THEN CRT.c_time ELSE NULL END),
  sum(CASE WHEN s."Code" != 0 THEN CRT.c_time ELSE NULL END)
from "Student" st
  LEFT JOIN "Specialization" SP ON
    SP.id = ST."SpecializationID"
  LEFT JOIN "Department" D ON D.id = SP."DepartmentID"
  LEFT JOIN curriculum C ON D."CurriculumID" = C.id
  LEFT JOIN "Student_Plan" STP ON ST.id = STP."StudentID"
  LEFT JOIN curr_rec CR ON CR.curr_id = C.id AND STP.curr_rec_id = CR.id and CR.GROUP_QTY = 1
  LEFT JOIN curr_rec_time CRT on CRT.curr_id = C.id and CRT.curr_rec_id = CR.id and
    ST."Class" = CRT.class_num and CRT.c_time > 0
  LEFT JOIN curr_cat cc on cc.curr_id = c.id AND st."Class" = cc.class_num
  LEFT JOIN "Subject" s ON s.id = cr.subject_id
WHERE ST.released = 0 and ST.academy = 0 and STP."Use" > 0
GROUP BY st.id, stp."TeacherID"
HAVING
    sum(CASE WHEN cc.category = 0 AND s."Code" = 0 THEN CRT.c_time ELSE NULL END) IS NOT NULL OR
    sum(CASE WHEN cc.category = 1 AND s."Code" = 0 THEN CRT.c_time ELSE NULL END) IS NOT NULL OR
    sum(CASE WHEN s."Code" != 0 THEN CRT.c_time ELSE NULL END) IS NOT NULL
;



/* View: V_STUDENT_CURRENT */
CREATE VIEW V_STUDENT_CURRENT(
    ID,
    CODE,
    NAME,
    SPECIALIZATIONID,
    SPECIALIZATION,
    DEPARTMENTID,
    DEPARTMENT,
    FILIALID,
    FILIAL,
    FINANCINGID,
    CURATORID,
    CURATOR,
    CLASS,
    PERCENT,
    BIRTHDATE,
    ENTERDATE,
    RELEASEDATE,
    RESTOREDATE,
    ENTERINFO,
    RELEASEINFO,
    RESTOREINFO,
    ACADEMYBDATE,
    ACADEMYEDATE,
    ACADEMYBINFO,
    ACADEMYEINFO,
    ADDRESS,
    TELEPHONE,
    PAY_SUM,
    CURRICULUMID,
    CATEGORY,
    PERIOD,
    RELEASED,
    ACADEMY)
AS
SELECT S.ID, S."Code", S."Name", S."SpecializationID", SP."Name", D.ID, D."Name",
  F.ID, F."Name", S."FinancingID", S."MasterID", T."Name", S."Class", S."Percent",
  S."BirthDate", S."EnterDate", S."ReleaseDate", S."RestoreDate", S."EnterInfo",
  S."ReleaseInfo", S."RestoreInfo", S."AcademyBDate", S."AcademyEDate",
  S."AcademyBInfo", S."AcademyEInfo", S."Address", S."Telephone",
  CASE S."FinancingID" WHEN 0 THEN SP."Budget" WHEN 1 THEN SP."Self_Repayment" END PAY_SUM,
  C.ID, CC.CATEGORY, C.PERIOD, S.RELEASED, S.ACADEMY
FROM "Student" S
  LEFT JOIN "Specialization" SP ON SP.ID = S."SpecializationID"
  LEFT JOIN "Department" D ON D.ID = SP."DepartmentID"
  LEFT JOIN CURRICULUM C ON C.ID = D."CurriculumID"
  LEFT JOIN CURR_CAT CC ON CC.CURR_ID = D."CurriculumID" AND S."Class" = CC.CLASS_NUM
  LEFT JOIN "Filial" F ON F.ID = S."FilialID"
  LEFT JOIN "Teacher" T ON S."MasterID" = T.ID
  LEFT JOIN CONSTANTS CONST ON 1 = 1
WHERE
  (S."ReleaseDate" IS NULL OR S."ReleaseDate" <  CONST.SYSTEM_DATE OR S."RestoreDate" <= CONST.SYSTEM_DATE) AND
  (S."AcademyBDate" IS NULL OR
    (
      S."AcademyEDate" IS NOT NULL AND S."AcademyEDate" <= CONST.SYSTEM_DATE OR
      S."AcademyEDate" IS NULL AND S."AcademyBDate" > CONST.SYSTEM_DATE
    )
  ) AND
  S.RELEASED <> 1 AND S.ACADEMY <> 1 AND
  EXISTS (
    SELECT 1
    FROM "Student_Plan" SP
      INNER JOIN CURR_REC_TIME CRT ON
        CRT.CURR_ID = C.ID AND
        CRT.CLASS_NUM = S."Class" AND
        CRT.CURR_REC_ID = SP.CURR_REC_ID AND
        COALESCE(CRT.C_TIME, 0) <> 0
    WHERE SP."StudentID" = S.ID AND SP."Use" = 1
  )
;



/* View: V_STUDENT_FILTER */
CREATE VIEW V_STUDENT_FILTER(
    ID,
    NAME,
    FILIAL_ID,
    FILIAL_NAME,
    CLASS_B,
    CLASS_E,
    CURATOR_ID,
    CURATOR_NAME,
    CATEGORY,
    PERIOD,
    STATUS,
    PAY_PERCENT,
    AGE_B,
    AGE_E,
    ENTER_D_B,
    ENTER_D_E,
    RELEASE_D_B,
    RELEASE_D_E,
    RESTORE_D_B,
    RESTORE_D_E,
    ACADEMY_D_B,
    ACADEMY_D_E,
    SUBJECT_ID_1,
    SUBJECT_NAME_1,
    TEACHER_ID_1,
    TEACHER_NAME_1,
    SUBJECT_ID_2,
    SUBJECT_NAME_2,
    TEACHER_ID_2,
    TEACHER_NAME_2,
    SUBJ_STATE,
    FINANCING_ID,
    ID_SEX)
AS
SELECT
  SF.ID,
  SF.NAME,
  SF.FILIAL_ID, COALESCE(F."Name", 'ЛЮБОЙ'),
  SF.CLASS_B, SF.CLASS_E,
  SF.CURATOR_ID,  COALESCE(T_C."Name", 'ЛЮБОЙ'),
  SF.CATEGORY,
  SF.PERIOD,
  SF.STATUS,
  SF.PAY_PERCENT,
  SF.AGE_B, SF.AGE_E,
  SF.ENTER_D_B, SF.ENTER_D_E,
  SF.RELEASE_D_B, SF.RELEASE_D_E,
  SF.RESTORE_D_B, SF.RESTORE_D_E,
  SF.ACADEMY_D_B, SF.ACADEMY_D_E,
  SF.SUBJECT_ID_1, COALESCE(S1."Name", 'ЛЮБОЙ'),
  SF.TEACHER_ID_1, COALESCE(T1."Name", 'ЛЮБОЙ'),
  SF.SUBJECT_ID_2, COALESCE(S2."Name", 'ЛЮБОЙ'),
  SF.TEACHER_ID_2, COALESCE(T2."Name", 'ЛЮБОЙ'),
  SF.SUBJ_STATE,
  SF.FINANCING_ID,
  SF.f_id_sex
FROM STUDENT_FILTER SF
  LEFT JOIN "Filial" F ON SF.FILIAL_ID = F.ID
  LEFT JOIN "Teacher" T_C ON SF.CURATOR_ID = T_C.ID
  LEFT JOIN "Subject" S1 ON SF.SUBJECT_ID_1 = S1.ID
  LEFT JOIN "Subject" S2 ON SF.SUBJECT_ID_2 = S2.ID
  LEFT JOIN "Teacher" T1 ON SF.TEACHER_ID_1 = T1.ID
  LEFT JOIN "Teacher" T2 ON SF.TEACHER_ID_2 = T2.ID
;



/* View: V_STUDENT_FILTER_SPEC */
CREATE VIEW V_STUDENT_FILTER_SPEC(
    ID_FILTER,
    ID_SPECIALIZATION,
    SPEC_NAME)
AS
SELECT
  SFS.ID_FILTER,
  SFS.ID_SPECIALIZATION,
  SP."Name"
FROM STUDENT_FILTER_SPEC SFS
  LEFT JOIN "Specialization" SP ON SFS.ID_SPECIALIZATION = SP.ID
;



/* View: V_T_MATERIAL_STIMULUS */
CREATE VIEW V_T_MATERIAL_STIMULUS(
    NAME,
    TAB_NUMBER,
    POST_NAME,
    MONEY)
AS
select
  t.name, t.tab_num, t.post_name, t.money
from (
  select
    t."Name" name,
    1 row_order,
    t.tab_num,
    'преподаватель' post_name,
    tm.sum_ped money
  from v_teacher t
    inner join get_teachers_tm tm on t.id = tm.teacher_id and tm.sum_ped > 0
  union all
  select
    t."Name" name,
    2 row_order,
    t.tab_num,
    'концертмейстер' post_name,
    tm.sum_conc money
  from v_teacher t
    inner join get_teachers_tm tm on t.id = tm.teacher_id and tm.sum_conc > 0
) t
order by t.name, t.row_order
;



/* View: V_T_MATERIAL_STIMULUS_XML */
CREATE VIEW V_T_MATERIAL_STIMULUS_XML(
    ROW)
AS
select '<row name="' || s.name || '" tab="' || s.tab_number || '" post="' || s.post_name || '" value="' || cast(trunc(s.money, 2) as numeric(10, 2)) || '"/>'
from v_t_material_stimulus s
;



/* View: V_TAR_TOTALS */
CREATE VIEW V_TAR_TOTALS(
    DOC_DATE,
    T_Y_PT,
    T_Y_FT,
    T_O_PT,
    T_O_FT,
    T_C_PT,
    T_C_FT,
    T_Y_V,
    T_O_V,
    T_C_V,
    M_Y_PT,
    M_Y_FT,
    M_O_PT,
    M_O_FT,
    M_C_PT,
    M_C_FT,
    M_Y_V,
    M_O_V,
    M_C_V)
AS
select
  tr.doc_date,
  nullif(sum(case when tr.teacher_id <> 0 and tr.full_time = 0 then tr.t_y else null end), 0) t_y_pt,
  nullif(sum(case when tr.teacher_id <> 0 and tr.full_time = 1 then tr.t_y else null end), 0) t_y_ft,
  nullif(sum(case when tr.teacher_id <> 0 and tr.full_time = 0 then tr.t_o else null end), 0) t_o_pt,
  nullif(sum(case when tr.teacher_id <> 0 and tr.full_time = 1 then tr.t_o else null end), 0) t_o_ft,
  nullif(sum(case when tr.teacher_id <> 0 and tr.full_time = 0 then tr.t_c else null end), 0) t_c_pt,
  nullif(sum(case when tr.teacher_id <> 0 and tr.full_time = 1 then tr.t_c else null end), 0) t_c_ft,

  nullif(sum(case when tr.teacher_id = 0 then tr.t_y else null end), 0) t_y_v,
  nullif(sum(case when tr.teacher_id = 0 then tr.t_o else null end), 0) t_o_v,
  nullif(sum(case when tr.teacher_id = 0 then tr.t_c else null end), 0) t_c_v,

  sum(case when tr.teacher_id <> 0 and tr.full_time = 0 then tr.m_y else null end) m_y_pt,
  sum(case when tr.teacher_id <> 0 and tr.full_time = 1 then tr.m_y else null end) m_y_ft,
  sum(case when tr.teacher_id <> 0 and tr.full_time = 0 then tr.m_o else null end) m_o_pt,
  sum(case when tr.teacher_id <> 0 and tr.full_time = 1 then tr.m_o else null end) m_o_ft,
  sum(case when tr.teacher_id <> 0 and tr.full_time = 0 then tr.m_c else null end) m_c_pt,
  sum(case when tr.teacher_id <> 0 and tr.full_time = 1 then tr.m_c else null end) m_c_ft,

  sum(case when tr.teacher_id = 0 then tr.m_y else null end) m_y_v,
  sum(case when tr.teacher_id = 0 then tr.m_o else null end) m_o_v,
  sum(case when tr.teacher_id = 0 then tr.m_c else null end) m_c_v
from (
  select
    t.doc_date,
    tr.teacher_id,
    coalesce(tr.t_b_time_y, 0) + coalesce(tr.t_s_time_y, 0) t_y,
    coalesce(tr.t_b_time_o, 0) + coalesce(tr.t_s_time_o, 0) t_o,
    coalesce(tr.t_b_time_c, 0) + coalesce(tr.t_s_time_c, 0) t_c,
    trunc(
        nullif(coalesce(tr.t_b_time_y, 0) + coalesce(tr.t_s_time_y, 0), 0)
        * coalesce(tr.t_main_salary_add, tr.t_main_salary)
        / t.coef_y_time
      , 2
    ) m_y,
    trunc(
        nullif(coalesce(tr.t_b_time_o, 0) + coalesce(tr.t_s_time_o, 0), 0)
        * coalesce(tr.t_main_salary_add, tr.t_main_salary)
        / t.coef_o_time
      , 2
    ) m_o,
    trunc(
        nullif(coalesce(tr.t_b_time_c, 0) + coalesce(tr.t_s_time_c, 0), 0)
        * coalesce(tr.t_concert_salary_add, tr.t_concert_salary)
        / t.coef_c_time
      , 2
    ) m_c,
    case when te."PostID" in (1, 4, 7) then 1 else 0 end full_time
  from tariffication t
    inner join tariffication_record tr on t.doc_date = tr.doc_date
    left  join "Teacher"            te on te.id = tr.teacher_id
) tr
group by tr.doc_date
;



/* View: V_TEACHER_ABSENT_MONTH_DATA */
CREATE VIEW V_TEACHER_ABSENT_MONTH_DATA(
    TEACHER_ID,
    COMMENTS)
AS
select d.teacher_id, d.comments
from teacher_absent_month_data d
where d.mon = (select c.system_date - extract(day from c.system_date) + 1 from constants c)
;



/* View: V_TEACHER_CAT_KIND */
CREATE VIEW V_TEACHER_CAT_KIND(
    ID,
    NAME)
AS
select cat.f_id, cat.f_name
from teacher_cat_kind cat
;



/* View: V_TEACHER_GROUP_TIME */
CREATE VIEW V_TEACHER_GROUP_TIME(
    ID_TEACHER,
    ID_GROUPING,
    ID_GROUPING_SUBJ,
    CLASS_NUM,
    PERIOD,
    QTY_Y,
    QTY_O,
    TIME_Y,
    TIME_O,
    TIME_C)
AS
SELECT TG.teacher_id, G.ID, GS.id, TG.class_num,
  c.period,
  CASE WHEN cc.category = 0 THEN TG.group_q ELSE NULL END,
  CASE WHEN cc.category = 1 THEN TG.group_q ELSE NULL END,
  CASE WHEN cc.category = 0 AND gs.code = 0 THEN CRT.c_time*TG.group_q ELSE NULL END,
  CASE WHEN cc.category = 1 AND gs.code = 0 THEN CRT.c_time*TG.group_q ELSE NULL END,
  CASE WHEN gs.code != 0 THEN CRT.c_time*TG.group_q ELSE NULL END
from teacher_group TG
  INNER JOIN grouping_subj GS on TG.grouping_id = GS.grouping_id and GS.ID = TG.gr_subj_id
  INNER JOIN curriculum C ON
    c.id =
      ( SELECT MIN(gscii.curr_id) FROM grouping_subj_curr_id gscii
        WHERE gscii.grouping_id = gs.grouping_id AND gscii.grouping_subj_id = gs.id
      )
  INNER JOIN grouping_subj_curr_id GSCI on
    GSCI.grouping_id = TG.grouping_id AND
    GSCI.grouping_subj_id = TG.gr_subj_id AND
    GSCI.curr_id = C.id
  INNER JOIN curr_rec_time CRT on
    CRT.curr_id = C.id AND
    CRT.curr_rec_id = GSCI.curr_rec_id and
    CRT.class_num = TG.class_num
  LEFT JOIN grouping g ON g.id = tg.grouping_id
  LEFT JOIN curr_cat cc ON cc.curr_id = GSCI.curr_id AND cc.class_num = crt.class_num
;



/* View: V_TEACHER_TITLE_KIND */
CREATE VIEW V_TEACHER_TITLE_KIND(
    ID,
    NAME)
AS
select tk.f_id, tk.f_name
from teacher_title_kind tk
;



/* View: V_TF_CAT */
CREATE VIEW V_TF_CAT(
    F_TF_ID,
    F_ID,
    F_NAME,
    F_CHECKED_PED,
    F_CHECKED_CONC)
AS
select
  tf.id F_TF_ID,
  f_id F_ID,
  f_name F_NAME,
  case when ',' || tf.cat_id_ped || ',' like '%,' || f_id || ',%' then 1 else 0 end F_CHECKED_PED,
  case when ',' || tf.cat_id_conc || ',' like '%,' || f_id || ',%' then 1 else 0 end F_CHECKED_CONC
from TEACHER_CAT_KIND
  inner join teacher_filter tf on 1=1
;



/* View: V_TF_EDUCATION */
CREATE VIEW V_TF_EDUCATION(
    F_TF_ID,
    F_ID,
    F_NAME,
    F_CHECKED)
AS
select
  tf.id F_TF_ID,
  e.id F_ID,
  e."Name" F_NAME,
  case when ',' || tf.education_id || ',' like '%,' || e.id || ',%' then 1 else 0 end F_CHECKED
from "Education" e
  inner join teacher_filter tf on 1=1
;



/* View: V_TF_POST */
CREATE VIEW V_TF_POST(
    F_TF_ID,
    F_ID,
    F_NAME,
    F_CHECKED)
AS
select
  tf.id F_TF_ID,
  p.id F_ID,
  p."Name" F_NAME,
  case when ',' || tf.post_id || ',' like '%,' || p.id || ',%' then 1 else 0 end F_CHECKED
from "Post" p
  inner join teacher_filter tf on 1=1
;



/* View: V_TF_TITLE */
CREATE VIEW V_TF_TITLE(
    F_TF_ID,
    F_ID,
    F_NAME,
    F_CHECKED)
AS
select
  tf.id F_TF_ID,
  t.f_id F_ID,
  t.f_name F_NAME,
  case when ',' || tf.title_id || ',' like '%,' || f_id || ',%' then 1 else 0 end F_CHECKED
from teacher_title_kind t
  inner join teacher_filter tf on 1=1
;



/* View: VIEW_CURR_CAT */
CREATE VIEW VIEW_CURR_CAT(
    CURR_ID,
    C_0,
    C_1,
    C_2,
    C_3,
    C_4,
    C_5,
    C_6,
    C_7,
    C_8)
AS
select CC.curr_id,
  sum(case CC.class_num when 0 then CC.category else null end),
  sum(case CC.class_num when 1 then CC.category else null end),
  sum(case CC.class_num when 2 then CC.category else null end),
  sum(case CC.class_num when 3 then CC.category else null end),
  sum(case CC.class_num when 4 then CC.category else null end),
  sum(case CC.class_num when 5 then CC.category else null end),
  sum(case CC.class_num when 6 then CC.category else null end),
  sum(case CC.class_num when 7 then CC.category else null end),
  sum(case CC.class_num when 8 then CC.category else null end)
from curr_cat CC
group by curr_id
;



/* View: VIEW_GROUP_CURR_SUBJ */
CREATE VIEW VIEW_GROUP_CURR_SUBJ(
    CURR_ID,
    CURR_REC_ID,
    CURR_REC_NUM,
    SUBJECT_ID,
    SUBJECT_NAME,
    SUBJECT_CODE,
    GR_QTY)
AS
select CR.curr_id, CR.id, CR.num, CR.subject_id, S."Name", S."Code", CR.group_qty
from curr_rec CR
  join "Subject" S on S.id = CR.subject_id
where CR.group_qty > 1
;



/* View: VIEW_GROUPING_CURR */
CREATE VIEW VIEW_GROUPING_CURR(
    GROUPING_ID,
    CURR_ID,
    CURR_NAME)
AS
select distinct GD.grouping_id, C.id, C.name
from grouping_dept GD
  join "Department" D on GD.department_id = D.id
  join curriculum C on C.id = D."CurriculumID"
;



/* View: VIEW_GROUPING_DEPT */
CREATE VIEW VIEW_GROUPING_DEPT(
    GROUPING_ID,
    DEPT_ID,
    DEPT_NAME,
    DEPT_INFO)
AS
select GD.grouping_id, GD.department_id, D."Name", D."Info"
from grouping_dept GD join "Department" D on GD.department_id = D.id
;



/* View: VIEW_GROUPING_SUBJ */
CREATE VIEW VIEW_GROUPING_SUBJ(
    GROUPING_ID,
    GR_SUBJ_ID,
    GR_SUBJ_NAME,
    GR_SUBJ_CODE,
    GR_QTY)
AS
select distinct GS.grouping_id, GS.id, GS.name, GS.code, GS.group_qty
from grouping_subj GS
;



/* View: VIEW_GROUPING_SUBJS */
CREATE VIEW VIEW_GROUPING_SUBJS(
    GROUPING_ID,
    GROUPING_SUBJ_ID,
    CURR_ID,
    CURR_NAME,
    CURR_REC_ID,
    SUBJECT_ID,
    SUBJECT_NAME,
    SUBJECT_CODE,
    SUBJECT_GR_QTY,
    POS)
AS
select GSCI.grouping_id, GSCI.grouping_subj_id, GSCI.curr_id, C.name,
  GSCI.curr_rec_id, CR.subject_id, S."Name", S."Code", CR.group_qty,
  GS.pos
from grouping_subj GS
  join grouping_subj_curr_id GSCI on GS.grouping_id = GSCI.grouping_id and
    GS.id = GSCI.grouping_subj_id
  join curr_rec CR on GSCI.curr_id = CR.curr_id and
    GSCI.curr_rec_id = CR.id
  join "Subject" S on S.id = CR.subject_id
  join curriculum C on C.id = CR.curr_id
;



/* View: VIEW_STUDENT */
CREATE VIEW VIEW_STUDENT(
    ID,
    CODE,
    NAME,
    SPECIALIZATIONID,
    SPECIALIZATION,
    DEPARTMENTID,
    DEPARTMENT,
    FILIALID,
    FILIAL,
    FINANCINGID,
    CURATORID,
    CURATOR,
    CLASS,
    PERCENT,
    BIRTHDATE,
    ENTERDATE,
    RELEASEDATE,
    RESTOREDATE,
    ENTERINFO,
    RELEASEINFO,
    RESTOREINFO,
    ACADEMYBDATE,
    ACADEMYEDATE,
    ACADEMYBINFO,
    ACADEMYEINFO,
    ADDRESS,
    TELEPHONE,
    PAY_SUM,
    CURRICULUMID,
    CATEGORY,
    PERIOD,
    PERIOD_FOR_PRINT,
    RELEASED,
    ACADEMY,
    SEX_ID,
    SEX_NAME)
AS
select S.id, S."Code", S."Name", S."SpecializationID", SP."Name", D.id, D."Name",
  F.id, F."Name", S."FinancingID", S."MasterID", T."Name", S."Class", S."Percent",
  S."BirthDate", S."EnterDate", S."ReleaseDate", S."RestoreDate", S."EnterInfo",
  S."ReleaseInfo", S."RestoreInfo", S."AcademyBDate", S."AcademyEDate",
  S."AcademyBInfo", S."AcademyEInfo", S."Address", S."Telephone",
  case S."FinancingID" when 0 then SP."Budget" when 1 then SP."Self_Repayment" end Pay_Sum,
  C.id, CC.category, C.period, C.period_for_print, S.released, S.academy, s.f_id_sex, sex.f_name
from "Student" S
  left join "Specialization" SP on SP.id = S."SpecializationID"
  left join "Department" D on D.id = SP."DepartmentID"
  left join curriculum C on C.id = D."CurriculumID"
  left join curr_cat CC on CC.curr_id = D."CurriculumID" and S."Class" = CC.class_num
  left join "Filial" F on F.id = S."FilialID"
  left join "Teacher" T on S."MasterID" = T.id
  left join SEX on sex.f_id = s.f_id_sex
;



/* View: VIEW_STUDENT_CATEGORY */
CREATE VIEW VIEW_STUDENT_CATEGORY(
    STUDENTID,
    CATEGORY)
AS
select ST."ID", C.category Category
from "Student" ST join "Specialization" SP on ST."SpecializationID" = SP."ID"
    join "Department" D on SP."DepartmentID" = D."ID"
    join curr_cat C on C.curr_id = D."CurriculumID" and C.class_num = ST."Class"
;



/* View: VIEW_STUDENT_PLAN */
CREATE VIEW VIEW_STUDENT_PLAN(
    STUDENT_ID,
    ID,
    NUM,
    USE,
    SUBJ_ID,
    SUBJ_NAME,
    SUBJ_CODE,
    TEACHER_ID,
    TEACHER_NAME,
    CLASS_TIME,
    GR_QTY,
    CURR_ID)
AS
SELECT DISTINCT ST."ID", CR.id, CR.num, "Use", S."ID", S."Name", S."Code", STP."TeacherID",
  T."Name", CRT.c_time ClassTime, CR.group_qty, D."CurriculumID"
FROM "Student" ST
  join "Specialization" SP on SP."ID" = ST."SpecializationID"
  join "Department" D on SP."DepartmentID" = D."ID"
  join curr_rec CR on CR.curr_id = D."CurriculumID"
  left join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id and
    CRT.class_num = ST."Class"
  left join "Student_Plan" STP on STP."StudentID"=ST."ID" and STP.curr_rec_id = CR.id
  left join "Subject" S on S."ID" = CR.subject_id
  left join "Teacher" T on T.id = STP."TeacherID"
where CRT.c_time > 0
;



/* View: VIEW_STUDENT_QTY */
CREATE VIEW VIEW_STUDENT_QTY(
    GROUPING_ID,
    TEACHER_ID,
    GR_SUBJ_ID,
    QTY_0,
    QTY_1,
    QTY_2,
    QTY_3,
    QTY_4,
    QTY_5,
    QTY_6,
    QTY_7,
    QTY_8)
AS
select
    G.ID,
    STP."TeacherID",
    GSCN.grouping_subj_id,
    sum(case S."Class" when 0 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 1 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 2 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 3 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 4 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 5 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 6 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 7 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 8 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end)
from "Student_Plan" STP
     join "Student" S on STP."StudentID" = S.id
     join "Specialization" SP on SP.id = S."SpecializationID"
     join "Department" D on D.id = SP."DepartmentID"
     join curr_rec CR on D."CurriculumID" = CR.curr_id and CR.id = STP.curr_rec_id
     join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id
        and CRT.class_num = S."Class"
     join grouping_subj_curr_id GSCN on
       GSCN.curr_id = D."CurriculumID" and GSCN.curr_rec_id = STP.curr_rec_id
     join grouping G on GSCN.grouping_id = G.id and G.financing_id = S."FinancingID"
where
  STP."Use" > 0 and STP."TeacherID" is not null and
  S."ReleaseDate" is null and (S."AcademyBDate" is null or S."AcademyEDate" is not null)
group by G.ID, STP."TeacherID", GSCN.grouping_subj_id
;



/* View: VIEW_TEACHER */
CREATE VIEW VIEW_TEACHER(
    ID,
    TAB_NUM,
    NAME,
    FILIALID,
    FILIAL,
    SUBJECTID,
    SUBJECTCODE,
    SUBJECT,
    EDUCATIONID,
    EDUCATION,
    POSTID,
    POST,
    STAGEDATE,
    BIRTHDATE,
    ENTERDATE,
    RELEASEDATE,
    DIPLOMA,
    ADDRESS,
    TELEPHONE,
    STAGE_Y,
    STAGE_M,
    STAGE_D)
AS
select T.ID, T.tab_num, T."Name", T."FilialID", F."Name", T."SubjectID",
  S."Code", S."Name", T."EducationID", E."Name", T."PostID", P."Name",
  T."StageDate", T."BirthDate", T."EnterDate", T."ReleaseDate", T."Diploma", T."Telephone",
  T."Address", T.stage_y, T.stage_m, T.stage_d
from "Teacher" T
  left join "Filial" F on F.id = T."FilialID"
  left join "Subject" S on S.id = T."SubjectID"
  left join "Education" E on E.id = T."EducationID"
  left join "Post" P on P.id = T."PostID"
;



/* View: VIEW_TEACHER_FILTER */
CREATE VIEW VIEW_TEACHER_FILTER(
    ID,
    NAME,
    MAIN_SUBJ_ID,
    MAIN_SUBJ_NAME,
    MAIN_GRADE,
    CONC_GRADE,
    FILIAL_ID,
    FILIAL_NAME,
    STATE,
    STAGE_B,
    STAGE_E,
    BIRTH_D_B,
    BIRTH_D_E,
    ENTER_D_B,
    ENTER_D_E,
    RELEASE_D_B,
    RELEASE_D_E,
    STAGE_B_M,
    STAGE_E_M,
    AGE_B,
    AGE_E)
AS
select tf.id, tf.name, tf.main_subj_id, s."Name", tf.main_grade,
  tf.conc_grade, tf.filial_id, f."Name", tf.state,
  tf.stage_b, tf.stage_e, tf.birth_d_b, tf.birth_d_e, tf.enter_d_b,
  tf.enter_d_e, tf.release_d_b, tf.release_d_e,
  tf.stage_b_m, tf.stage_e_m, tf.age_b, tf.age_e
from teacher_filter tf
  left join "Subject" s on s.id = tf.main_subj_id
  left join "Filial" f on f.id = tf.filial_id
;



/* View: VIEW_TEACHER_GROUP */
CREATE VIEW VIEW_TEACHER_GROUP(
    GROUPING_ID,
    TEACHER_ID,
    TEACHER_NAME,
    GS_0,
    GS_1,
    GS_2,
    GS_3,
    GS_4,
    GS_5,
    GS_6,
    GS_7,
    GS_8)
AS
select G.ID, T.id, T."Name",
 sum(case TG.class_num when 0 then TG.group_q else 0 end),
 sum(case TG.class_num when 1 then TG.group_q else 0 end),
 sum(case TG.class_num when 2 then TG.group_q else 0 end),
 sum(case TG.class_num when 3 then TG.group_q else 0 end),
 sum(case TG.class_num when 4 then TG.group_q else 0 end),
 sum(case TG.class_num when 5 then TG.group_q else 0 end),
 sum(case TG.class_num when 6 then TG.group_q else 0 end),
 sum(case TG.class_num when 7 then TG.group_q else 0 end),
 sum(case TG.class_num when 8 then TG.group_q else 0 end)
from "Student_Plan" STP
  join "Student" S on S.id = STP."StudentID" and STP."Use" > 0 and
    S."ReleaseDate" is null  and ((S."AcademyBDate" is null) or (S."AcademyEDate" is not null))
  join "Specialization" SP on SP.id = S."SpecializationID"
  join "Department" D on D.id = SP."DepartmentID"
  join grouping_subj_curr_id GSCI on GSCI.curr_id = D."CurriculumID" and
    STP.curr_rec_id = GSCI.curr_rec_id
  join grouping G1 on G1.id = GSCI.grouping_id and G1.financing_id = S."FinancingID"
  full join teacher_group TG on TG.teacher_id = STP."TeacherID" and
    TG.class_num = S."Class" and G1.id = TG.grouping_id and
    GSCI.grouping_subj_id = TG.gr_subj_id
  join "Teacher" T on (TG.teacher_id = T.id and STP."TeacherID" is null) or
    (STP."TeacherID" = T.id and TG.teacher_id is null)
  join grouping G on (TG.grouping_id = G.id and G1.id = G.ID)
group by G.id, T.id, T."Name"
;



/* View: VIEW_TEACHER_GROUP_AND_ST_QTY */
CREATE VIEW VIEW_TEACHER_GROUP_AND_ST_QTY(
    GROUPING_ID,
    GR_SUBJ_ID,
    GR_SUBJ_NAME,
    GR_SUBJ_CODE,
    GR_QTY,
    TEACHER_ID,
    S_QTY_0,
    S_QTY_1,
    S_QTY_2,
    S_QTY_3,
    S_QTY_4,
    S_QTY_5,
    S_QTY_6,
    S_QTY_7,
    S_QTY_8,
    G_QTY_0,
    G_QTY_1,
    G_QTY_2,
    G_QTY_3,
    G_QTY_4,
    G_QTY_5,
    G_QTY_6,
    G_QTY_7,
    G_QTY_8)
AS
select
    G.id,
    GS.id,
    GS.name,
    GS.code,
    GS.group_qty,
    T.id,
    sum(case S."Class" when 0 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 1 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 2 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 3 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 4 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 5 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 6 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 7 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case S."Class" when 8 then (case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end) else 0 end),
    sum(case TG.class_num when 0 then coalesce(TG.group_q, 0) else 0 end),
    sum(case TG.class_num when 1 then coalesce(TG.group_q, 0) else 0 end),
    sum(case TG.class_num when 2 then coalesce(TG.group_q, 0) else 0 end),
    sum(case TG.class_num when 3 then coalesce(TG.group_q, 0) else 0 end),
    sum(case TG.class_num when 4 then coalesce(TG.group_q, 0) else 0 end),
    sum(case TG.class_num when 5 then coalesce(TG.group_q, 0) else 0 end),
    sum(case TG.class_num when 6 then coalesce(TG.group_q, 0) else 0 end),
    sum(case TG.class_num when 7 then coalesce(TG.group_q, 0) else 0 end),
    sum(case TG.class_num when 8 then coalesce(TG.group_q, 0) else 0 end)
from grouping G
  join grouping_subj GS on GS.grouping_id = G.id
  join grouping_subj_curr_id GSCI on GS.grouping_id = GSCI.grouping_id and
    GS.id = GSCI.grouping_subj_id
  join curr_rec CR on CR.curr_id = GSCI.curr_id and CR.id = GSCI.curr_rec_id
  join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id
  join "Department" D on D."CurriculumID" = CR.curr_id
  join "Specialization" SP on SP."DepartmentID" = D.id
  left join "Student" S on S."SpecializationID" = SP.id and
    S."FinancingID" = G.financing_id and
    S."ReleaseDate" is null and (S."AcademyBDate" is null or S."AcademyEDate" is not null)
  left join "Student_Plan" STP on S.id = STP."StudentID" and
    STP."Use" > 0 and STP."TeacherID" is not null
  left join teacher_group TG on TG.grouping_id = G.id and TG.gr_subj_id = GS.id
  join "Teacher" T on (TG.teacher_id = T.id) or (STP."TeacherID" = T.id)
group by G.id, GS.id, GS.name, GS.code, GS.group_qty, T.id
;




/******************************************************************************/
/***                           Unique Constraints                           ***/
/******************************************************************************/

ALTER TABLE ABSENT_TYPE ADD CONSTRAINT UNQ_ABSENT_TYPE_CODE UNIQUE (CODE);
ALTER TABLE CONST ADD CONSTRAINT UNQ_CONST_CODE UNIQUE (F_CODE);
ALTER TABLE TEACHER_CAT ADD CONSTRAINT UQ_TC UNIQUE (F_ID_TEACHER, F_ID_CAT_KIND, F_DATE_BEGIN);
ALTER TABLE TEACHER_NOTE ADD CONSTRAINT UNIQ_TN UNIQUE (F_ID_NOTE_KIND, F_ID_TEACHER, F_DATE_BEGIN);
ALTER TABLE TEACHER_TITLE ADD CONSTRAINT UNQ1_TEACHER_TITLE UNIQUE (F_ID_TEACHER, F_ID_KIND, F_DATE);
ALTER TABLE TEACHER_TITLE_KIND ADD CONSTRAINT UNQ1_TEACHER_TITLE_KIND UNIQUE (F_NAME);


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE ABSENT_TYPE ADD CONSTRAINT PK_ABSENT_TYPE PRIMARY KEY (ID);
ALTER TABLE CALC_GROUP ADD CONSTRAINT PK_CALC_GROUP PRIMARY KEY (ID, ID_CALC_PACK);
ALTER TABLE CALC_GROUP_CLASS_DETAIL ADD CONSTRAINT PK_CALC_GROUP_CLASS_DETAIL PRIMARY KEY (CLASS_NUMBER, ID_CALC_GROUP, ID_CALC_PACK);
ALTER TABLE CALC_GROUP_SUBJECT ADD CONSTRAINT PK_CALC_GROUP_SUBJECT PRIMARY KEY (ID, ID_CALC_GROUP, ID_CALC_PACK);
ALTER TABLE CALC_GROUP_SUBJECT_CLASS_DETAIL ADD CONSTRAINT PK_CALC_GROUP_SUBJECT_CLOCK PRIMARY KEY (CLASS_NUMBER, ID_CALC_GROUP_SUBJECT, ID_CALC_GROUP, ID_CALC_PACK);
ALTER TABLE CALC_INDIVIDUAL ADD CONSTRAINT PK_CALC_INDIVIDUAL PRIMARY KEY (ID, ID_CALC_PACK);
ALTER TABLE CALC_INDIVIDUAL_CLASS_DETAIL ADD CONSTRAINT PK_CALC_INDIVIDUAL_CLASS_DETAIL PRIMARY KEY (CLASS_NUMBER, ID_CALC_INDIVIDUAL, ID_CALC_PACK);
ALTER TABLE CALC_INDIVIDUAL_SUBJECT ADD CONSTRAINT PK_CALC_INDIVIDUAL_SUBJECT PRIMARY KEY (ID, ID_CALC_INDIVIDUAL, ID_CALC_PACK);
ALTER TABLE CALC_IND_SUBJ_CLASS_DETAIL ADD CONSTRAINT PK_CALC_IND_SUBJ_DETAIL PRIMARY KEY (CLASS_NUMBER, ID_CALC_INDIVIDUAL_SUBJECT, ID_CALC_INDIVIDUAL, ID_CALC_PACK);
ALTER TABLE CALC_PACK ADD CONSTRAINT PK_CALC_PACK PRIMARY KEY (ID);
ALTER TABLE CALENDAR ADD CONSTRAINT PK_CALENDAR PRIMARY KEY (THE_DAY);
ALTER TABLE CONST ADD CONSTRAINT PK_CONST PRIMARY KEY (ID);
ALTER TABLE CONST_DATE ADD CONSTRAINT PK_CONST_DATE PRIMARY KEY (F_CONST_ID);
ALTER TABLE CONST_FLOAT ADD CONSTRAINT PK_CONST_FLOAT PRIMARY KEY (F_CONST_ID);
ALTER TABLE CONST_STRING ADD CONSTRAINT PK_CONST_STRING PRIMARY KEY (F_CONST_ID);
ALTER TABLE CONST_TYPE ADD CONSTRAINT PK_CONST_TYPE PRIMARY KEY (ID);
ALTER TABLE CURRICULUM ADD CONSTRAINT PK_CURRICULUM PRIMARY KEY (ID);
ALTER TABLE CURR_CAT ADD CONSTRAINT PK_CURR_CAT PRIMARY KEY (CURR_ID, CLASS_NUM);
ALTER TABLE CURR_REC ADD CONSTRAINT PK_CURR_REC PRIMARY KEY (CURR_ID, ID);
ALTER TABLE CURR_REC_TIME ADD CONSTRAINT PK_CURR_REC_TIME PRIMARY KEY (CURR_ID, CURR_REC_ID, CLASS_NUM);
ALTER TABLE "Department" ADD PRIMARY KEY (ID);
ALTER TABLE "Education" ADD PRIMARY KEY (ID);
ALTER TABLE "Filial" ADD PRIMARY KEY (ID);
ALTER TABLE "Financing" ADD PRIMARY KEY (ID);
ALTER TABLE GROUPING ADD CONSTRAINT PK_GROUPING PRIMARY KEY (ID);
ALTER TABLE GROUPING_DEPT ADD CONSTRAINT PK_GROUPING_DEPT PRIMARY KEY (GROUPING_ID, DEPARTMENT_ID);
ALTER TABLE GROUPING_SUBJ ADD CONSTRAINT PK_GROUPING_SUBJ PRIMARY KEY (GROUPING_ID, ID);
ALTER TABLE GROUPING_SUBJ_CURR_ID ADD CONSTRAINT PK_GROUPING_SUBJ_CURR_ID PRIMARY KEY (GROUPING_ID, GROUPING_SUBJ_ID, CURR_ID, CURR_REC_ID);
ALTER TABLE IBE$REPORTS ADD PRIMARY KEY (IBE$REPORT_ID);
ALTER TABLE LEARN_TIME_GRID ADD CONSTRAINT PK_LEARN_TIME_GRID PRIMARY KEY (ID);
ALTER TABLE LTG_GROUPING ADD CONSTRAINT PK_LTG_GROUPING PRIMARY KEY (LTG_ID, GROUPING_ID);
ALTER TABLE LTG_I_SUBJECT ADD CONSTRAINT PK_LTG_I_SUBJECT PRIMARY KEY (LTG_ID, ID);
ALTER TABLE LTG_I_SUBJ_CURR ADD CONSTRAINT PK_LTG_I_SUBJ_CURR PRIMARY KEY (LTG_ID, LTG_I_SUBJ_ID, CURR_ID, CURR_REC_ID);
ALTER TABLE MAIN_TAB ADD CONSTRAINT PK_MAIN_TAB PRIMARY KEY (TEACHER_ID);
ALTER TABLE OBJ_CAT_GROUP ADD CONSTRAINT PK_OBJ_CAT_GROUP PRIMARY KEY (F_ID);
ALTER TABLE OBJ_CAT_KIND ADD CONSTRAINT PK_OBJ_CAT_KIND PRIMARY KEY (F_ID);
ALTER TABLE OBJ_KIND ADD CONSTRAINT PK_OBJECT_KIND PRIMARY KEY (F_ID);
ALTER TABLE OBJ_NOTE_KIND ADD CONSTRAINT PK_OBJECT_NOTE_KIND PRIMARY KEY (F_ID);
ALTER TABLE OBJ_NOTE_TYPE ADD CONSTRAINT PK_OBJ_NOTE_TYPE PRIMARY KEY (F_ID);
ALTER TABLE "Post" ADD PRIMARY KEY (ID);
ALTER TABLE QUALIFICATION ADD CONSTRAINT PK_QUALIFICATION PRIMARY KEY (ID);
ALTER TABLE REPORTS ADD CONSTRAINT PK_REPORTS PRIMARY KEY (ID);
ALTER TABLE REPORTS_SQL ADD CONSTRAINT PK_REPORTS_SQL PRIMARY KEY (ID);
ALTER TABLE REPORT_PARAM ADD CONSTRAINT PK_REPORT_PARAM PRIMARY KEY (ID);
ALTER TABLE REP_TAB_EXT ADD CONSTRAINT PK_REP_TAB_EXT PRIMARY KEY (REC_TIME);
ALTER TABLE REP_TAB_EXT_2 ADD CONSTRAINT PK_REP_TAB_EXT_2 PRIMARY KEY (REC_TIME);
ALTER TABLE SEX ADD CONSTRAINT PK_SEX PRIMARY KEY (F_ID);
ALTER TABLE STUDENT_FILTER ADD CONSTRAINT PK_STUDENT_FILTER PRIMARY KEY (ID);
ALTER TABLE STUDENT_FILTER_SPEC ADD CONSTRAINT PK_STUDENT_FILTER_SPEC PRIMARY KEY (ID_FILTER, ID_SPECIALIZATION);
ALTER TABLE "Specialization" ADD PRIMARY KEY (ID);
ALTER TABLE "Student" ADD PRIMARY KEY (ID);
ALTER TABLE "Student_Plan" ADD CONSTRAINT PK_STUDENT_PLAN PRIMARY KEY ("StudentID", CURR_REC_ID);
ALTER TABLE "Subject" ADD PRIMARY KEY (ID);
ALTER TABLE TARIFFICATION ADD CONSTRAINT PK_TARIFFICATION PRIMARY KEY (DOC_DATE);
ALTER TABLE TARIFFICATION_RECORD ADD CONSTRAINT PK_TARIFFICATION_RECORD PRIMARY KEY (DOC_DATE, TEACHER_ID);
ALTER TABLE TEACHER_ABSENT ADD CONSTRAINT PK_TEACHER_ABSENT PRIMARY KEY (TEACHER_ID, ABSENT_DATE, ABSENT_TYPE_ID);
ALTER TABLE TEACHER_ABSENT_MONTH_DATA ADD CONSTRAINT PK_TEACHER_ABSENT_MONTH_DATA PRIMARY KEY (TEACHER_ID, MON);
ALTER TABLE TEACHER_CAT ADD CONSTRAINT PK_TEACHER_CAT PRIMARY KEY (F_ID);
ALTER TABLE TEACHER_CAT_KIND ADD CONSTRAINT PK_TEACHER_CAT_KIND PRIMARY KEY (F_ID);
ALTER TABLE TEACHER_GROUP ADD CONSTRAINT PK_TEACHER_GROUP PRIMARY KEY (GROUPING_ID, TEACHER_ID, GR_SUBJ_ID, CLASS_NUM);
ALTER TABLE TEACHER_NOTE ADD CONSTRAINT PK_TEACHER_NOTE PRIMARY KEY (F_ID);
ALTER TABLE TEACHER_TITLE ADD CONSTRAINT PK_TEACHER_TITLE PRIMARY KEY (F_ID);
ALTER TABLE TEACHER_TITLE_KIND ADD CONSTRAINT PK_TEACHER_TITLE_KIND PRIMARY KEY (F_ID);
ALTER TABLE TMP_CURR ADD CONSTRAINT PK_TMP_CURR PRIMARY KEY (ID, CLASS_NUM);
ALTER TABLE TMP_CURR_REC ADD CONSTRAINT PK_TMP_CURR_REC PRIMARY KEY (CURR_ID, ID);
ALTER TABLE TMP_CURR_REC_TIME ADD CONSTRAINT PK_TMP_CURR_REC_TIME PRIMARY KEY (CURR_ID, CURR_REC_ID, CLASS_NUM);
ALTER TABLE "Tariff" ADD PRIMARY KEY ("Grade");
ALTER TABLE "Teacher" ADD PRIMARY KEY (ID);
ALTER TABLE "Teacher_Addings" ADD PRIMARY KEY (ID);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE CALC_GROUP ADD CONSTRAINT FK_CG_CALC_PACK FOREIGN KEY (ID_CALC_PACK) REFERENCES CALC_PACK (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALC_GROUP_CLASS_DETAIL ADD CONSTRAINT FK_CGCD_CALC_GROUP FOREIGN KEY (ID_CALC_GROUP, ID_CALC_PACK) REFERENCES CALC_GROUP (ID, ID_CALC_PACK) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALC_GROUP_SUBJECT ADD CONSTRAINT FK_CGS_CALC_GROUP FOREIGN KEY (ID_CALC_GROUP, ID_CALC_PACK) REFERENCES CALC_GROUP (ID, ID_CALC_PACK) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALC_GROUP_SUBJECT ADD CONSTRAINT FK_CGS_GROUPING_SUBJECT FOREIGN KEY (ID_GROUPING, ID_GROUPING_SUBJ) REFERENCES GROUPING_SUBJ (GROUPING_ID, ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALC_GROUP_SUBJECT_CLASS_DETAIL ADD CONSTRAINT FK_CGSD_CALC_GROUP_SUBJECT FOREIGN KEY (ID_CALC_GROUP_SUBJECT, ID_CALC_GROUP, ID_CALC_PACK) REFERENCES CALC_GROUP_SUBJECT (ID, ID_CALC_GROUP, ID_CALC_PACK) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALC_INDIVIDUAL ADD CONSTRAINT FK_CI_CALC_PACK FOREIGN KEY (ID_CALC_PACK) REFERENCES CALC_PACK (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALC_INDIVIDUAL_CLASS_DETAIL ADD CONSTRAINT FK_CISCD_CALC_INDIVIDUAL FOREIGN KEY (ID_CALC_INDIVIDUAL, ID_CALC_PACK) REFERENCES CALC_INDIVIDUAL (ID, ID_CALC_PACK) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALC_INDIVIDUAL_SUBJECT ADD CONSTRAINT FK_CIS_CALC_INDIVIDUAL FOREIGN KEY (ID_CALC_INDIVIDUAL, ID_CALC_PACK) REFERENCES CALC_INDIVIDUAL (ID, ID_CALC_PACK) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALC_INDIVIDUAL_SUBJECT ADD CONSTRAINT FK_CIS_CURRICULUM_RECORD FOREIGN KEY (ID_CURRICULUM, ID_CURR_REC) REFERENCES CURR_REC (CURR_ID, ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALC_INDIVIDUAL_SUBJECT ADD CONSTRAINT FK_CIS_DEPARTMENT FOREIGN KEY (ID_DEPARTMENT) REFERENCES "Department" (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CALC_IND_SUBJ_CLASS_DETAIL ADD CONSTRAINT FK_CISCD_C_I_S FOREIGN KEY (ID_CALC_INDIVIDUAL_SUBJECT, ID_CALC_INDIVIDUAL, ID_CALC_PACK) REFERENCES CALC_INDIVIDUAL_SUBJECT (ID, ID_CALC_INDIVIDUAL, ID_CALC_PACK) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CONST ADD CONSTRAINT FK_CONST_TYPE FOREIGN KEY (F_TYPE) REFERENCES CONST_TYPE (ID);
ALTER TABLE CONST_DATE ADD CONSTRAINT FK_CD_CONST_ID FOREIGN KEY (F_CONST_ID) REFERENCES CONST (ID);
ALTER TABLE CONST_FLOAT ADD CONSTRAINT FK_CF_CONST_ID FOREIGN KEY (F_CONST_ID) REFERENCES CONST (ID);
ALTER TABLE CONST_STRING ADD CONSTRAINT FK_CS_CONST_ID FOREIGN KEY (F_CONST_ID) REFERENCES CONST (ID);
ALTER TABLE CURR_CAT ADD CONSTRAINT FK_CURR_CAT FOREIGN KEY (CURR_ID) REFERENCES CURRICULUM (ID) ON DELETE CASCADE;
ALTER TABLE CURR_REC ADD CONSTRAINT FK_CURR_REC FOREIGN KEY (CURR_ID) REFERENCES CURRICULUM (ID) ON DELETE CASCADE;
ALTER TABLE CURR_REC_TIME ADD CONSTRAINT FK_CURR_REC_TIME FOREIGN KEY (CURR_ID, CURR_REC_ID) REFERENCES CURR_REC (CURR_ID, ID) ON DELETE CASCADE;
ALTER TABLE "Department" ADD FOREIGN KEY ("CurriculumID") REFERENCES CURRICULUM (ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE GROUPING_DEPT ADD CONSTRAINT FK_GROUPING_DEPT_1 FOREIGN KEY (GROUPING_ID) REFERENCES GROUPING (ID) ON DELETE CASCADE;
ALTER TABLE GROUPING_SUBJ ADD CONSTRAINT FK_GROUPING_SUBJ_1 FOREIGN KEY (GROUPING_ID) REFERENCES GROUPING (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE GROUPING_SUBJ_CURR_ID ADD CONSTRAINT FK_GROUPING_SUBJ_CURR_ID_1 FOREIGN KEY (GROUPING_ID, GROUPING_SUBJ_ID) REFERENCES GROUPING_SUBJ (GROUPING_ID, ID) ON DELETE CASCADE;
ALTER TABLE GROUPING_SUBJ_CURR_ID ADD CONSTRAINT FK_GROUPING_SUBJ_CURR_ID_2 FOREIGN KEY (CURR_ID, CURR_REC_ID) REFERENCES CURR_REC (CURR_ID, ID) ON DELETE CASCADE;
ALTER TABLE LTG_GROUPING ADD CONSTRAINT FK_LTG_GROUPING_LTG_GR_ID FOREIGN KEY (GROUPING_ID) REFERENCES GROUPING (ID) ON DELETE CASCADE;
ALTER TABLE LTG_GROUPING ADD CONSTRAINT FK_LTG_GROUPING_LTG_ID FOREIGN KEY (LTG_ID) REFERENCES LEARN_TIME_GRID (ID) ON DELETE CASCADE;
ALTER TABLE LTG_I_SUBJECT ADD CONSTRAINT FK_LTG_I_SUBJECT_LTG_ID FOREIGN KEY (LTG_ID) REFERENCES LEARN_TIME_GRID (ID) ON DELETE CASCADE;
ALTER TABLE LTG_I_SUBJ_CURR ADD CONSTRAINT FK_LTG_I_SUBJ_CURR_CURR FOREIGN KEY (CURR_ID, CURR_REC_ID) REFERENCES CURR_REC (CURR_ID, ID) ON DELETE CASCADE;
ALTER TABLE LTG_I_SUBJ_CURR ADD CONSTRAINT FK_LTG_I_SUBJ_CURR_SUBJ FOREIGN KEY (LTG_ID, LTG_I_SUBJ_ID) REFERENCES LTG_I_SUBJECT (LTG_ID, ID) ON DELETE CASCADE;
ALTER TABLE OBJ_CAT_KIND ADD CONSTRAINT FK_OBJCATKIND_OBJCATGROUP FOREIGN KEY (F_ID_GROUP) REFERENCES OBJ_CAT_GROUP (F_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE OBJ_NOTE_KIND ADD CONSTRAINT FK_ONK_NOTE_TYPE FOREIGN KEY (F_ID_TYPE) REFERENCES OBJ_NOTE_TYPE (F_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE REPORTS_SQL ADD CONSTRAINT FK_REPORTS_SQL_PARENT FOREIGN KEY (ID_PARENT) REFERENCES REPORTS_SQL (ID);
ALTER TABLE REPORTS_SQL ADD CONSTRAINT FK_REPORTS_SQL_REP FOREIGN KEY (REPORT_ID) REFERENCES REPORTS (ID);
ALTER TABLE STUDENT_FILTER_SPEC ADD CONSTRAINT FK_ST_F_SP_ID_FILTER FOREIGN KEY (ID_FILTER) REFERENCES STUDENT_FILTER (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "Specialization" ADD FOREIGN KEY ("DepartmentID") REFERENCES "Department" (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "Student" ADD FOREIGN KEY ("SpecializationID") REFERENCES "Specialization" (ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE "Student" ADD FOREIGN KEY ("FilialID") REFERENCES "Filial" (ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE "Student" ADD FOREIGN KEY ("MasterID") REFERENCES "Teacher" (ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE "Student_Plan" ADD FOREIGN KEY ("StudentID") REFERENCES "Student" (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "Student_Plan" ADD FOREIGN KEY ("TeacherID") REFERENCES "Teacher" (ID) ON DELETE SET DEFAULT ON UPDATE CASCADE;
ALTER TABLE TARIFFICATION_RECORD ADD CONSTRAINT FK_TARIFFICATION_RECORD_1 FOREIGN KEY (DOC_DATE) REFERENCES TARIFFICATION (DOC_DATE) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TEACHER_ABSENT ADD CONSTRAINT FK_TEACHER_ABSENT_A FOREIGN KEY (ABSENT_TYPE_ID) REFERENCES ABSENT_TYPE (ID) ON DELETE CASCADE;
ALTER TABLE TEACHER_ABSENT ADD CONSTRAINT FK_TEACHER_ABSENT_T FOREIGN KEY (TEACHER_ID) REFERENCES "Teacher" (ID) ON DELETE CASCADE;
ALTER TABLE TEACHER_CAT ADD CONSTRAINT FK_TC_CAT_KIND FOREIGN KEY (F_ID_CAT_KIND) REFERENCES OBJ_CAT_KIND (F_ID);
ALTER TABLE TEACHER_CAT ADD CONSTRAINT FK_TC_TEACHER FOREIGN KEY (F_ID_TEACHER) REFERENCES "Teacher" (ID);
ALTER TABLE TEACHER_GROUP ADD CONSTRAINT FK_TEACHER_GROUP_GS FOREIGN KEY (GROUPING_ID, GR_SUBJ_ID) REFERENCES GROUPING_SUBJ (GROUPING_ID, ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TEACHER_GROUP ADD CONSTRAINT FK_TEACHER_GROUP_TID FOREIGN KEY (TEACHER_ID) REFERENCES "Teacher" (ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TEACHER_NOTE ADD CONSTRAINT FK_TN_NOTE_KIND FOREIGN KEY (F_ID_NOTE_KIND) REFERENCES OBJ_NOTE_KIND (F_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE TEACHER_TITLE ADD CONSTRAINT FK_TT_KIND FOREIGN KEY (F_ID_KIND) REFERENCES TEACHER_TITLE_KIND (F_ID);
ALTER TABLE TEACHER_TITLE ADD CONSTRAINT FK_TT_TEACHER FOREIGN KEY (F_ID_TEACHER) REFERENCES "Teacher" (ID);
ALTER TABLE "Teacher" ADD CONSTRAINT FK_TEACHER_CAT FOREIGN KEY (ID_CATEGORY) REFERENCES TEACHER_CAT_KIND (F_ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE "Teacher" ADD CONSTRAINT FK_TEACHER_CAT_CONC FOREIGN KEY (ID_CATEGORY_CONC) REFERENCES TEACHER_CAT_KIND (F_ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE "Teacher" ADD CONSTRAINT FK_TEACHER_EDUCATION_2 FOREIGN KEY (EDUCATION_2_ID) REFERENCES "Education" (ID);
ALTER TABLE "Teacher" ADD CONSTRAINT FK_TEACHER_QUALIFICATION FOREIGN KEY (QUALIFICATION_ID) REFERENCES QUALIFICATION (ID);
ALTER TABLE "Teacher" ADD CONSTRAINT FK_TEACHER_QUALIFICATION_2 FOREIGN KEY (QUALIFICATION_2_ID) REFERENCES QUALIFICATION (ID);
ALTER TABLE "Teacher" ADD CONSTRAINT FK_TEACHER_TITLE FOREIGN KEY (ID_TITLE) REFERENCES TEACHER_TITLE_KIND (F_ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE "Teacher" ADD FOREIGN KEY ("SubjectID") REFERENCES "Subject" (ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE "Teacher" ADD FOREIGN KEY ("FilialID") REFERENCES "Filial" (ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE "Teacher_Addings" ADD FOREIGN KEY ("TeacherID") REFERENCES "Teacher" (ID) ON DELETE CASCADE ON UPDATE CASCADE;


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE INDEX "IdxID" ON "Department" (ID);
CREATE INDEX "Ind1" ON "Department" (ID);
CREATE INDEX IBE$SCRIPTS_BY_ACTION_ID ON IBE$SCRIPTS (IBE$SCRIPT_ACTION_ID);
CREATE UNIQUE INDEX IBE$SCRIPTS_BY_NAME ON IBE$SCRIPTS (IBE$SCRIPT_NAME);
CREATE UNIQUE INDEX REPORTS_IDX_CODE ON REPORTS (CODE);
CREATE UNIQUE INDEX REPORTS_SQL_IDX_CODE ON REPORTS_SQL (CODE, REPORT_ID);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: CURR_REC_AD0 */
CREATE TRIGGER CURR_REC_AD0 FOR CURR_REC
ACTIVE AFTER DELETE POSITION 0
AS
begin
  delete from "Student_Plan" STP where
    STP.curr_rec_id = OLD.id and STP."StudentID" in
      (select S.id from "Student" S
         join "Specialization" SP on SP.id = S."SpecializationID"
         join "Department" D on SP."DepartmentID" = D.id and
          D."CurriculumID" = old.curr_id);
end
^


/* Trigger: GROUPING_SUBJ_AD0 */
CREATE TRIGGER GROUPING_SUBJ_AD0 FOR GROUPING_SUBJ
ACTIVE AFTER DELETE POSITION 0
AS
begin
  delete from teacher_group TG
  where TG.grouping_id = old.grouping_id and TG.gr_subj_id = old.ID;

  update grouping_subj GS
  set GS.pos = GS.pos - 1
  where GS.pos > old.pos;
end
^


/* Trigger: LTG_I_SUBJECT_AD0 */
CREATE TRIGGER LTG_I_SUBJECT_AD0 FOR LTG_I_SUBJECT
ACTIVE AFTER DELETE POSITION 0
AS
begin
  update ltg_i_subject LIS
  set LIS.pos = LIS.pos - 1
  where LIS.pos > old.pos;
end
^


/* Trigger: OBJECT_KIND_BI */
CREATE TRIGGER OBJECT_KIND_BI FOR OBJ_KIND
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.f_id is null) then
    new.f_id = gen_id(gen_object_kind_id,1);
end
^


/* Trigger: OBJECT_NOTE_KIND_BI */
CREATE TRIGGER OBJECT_NOTE_KIND_BI FOR OBJ_NOTE_KIND
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.f_id is null) then
    new.f_id = gen_id(gen_object_note_kind_id,1);
end
^


/* Trigger: OBJ_CAT_GROUP_BI */
CREATE TRIGGER OBJ_CAT_GROUP_BI FOR OBJ_CAT_GROUP
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.f_id is null) then
    new.f_id = gen_id(gen_obj_cat_group_id,1);
end
^


/* Trigger: SEX_BI */
CREATE TRIGGER SEX_BI FOR SEX
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.f_id is null) then
    new.f_id = gen_id(gen_sex_id,1);
end
^


/* Trigger: TBI_CGS */
CREATE TRIGGER TBI_CGS FOR CALC_GROUP_SUBJECT
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.SHOW_POSITION IS NULL) THEN
    SELECT COALESCE(MAX(CGS.SHOW_POSITION), 0) + 1
    FROM CALC_GROUP_SUBJECT CGS
    WHERE
      CGS.ID_CALC_GROUP = NEW.ID_CALC_GROUP AND
      CGS.ID_CALC_PACK = NEW.ID_CALC_PACK
    INTO NEW.SHOW_POSITION;
END
^


/* Trigger: TEACHER_CAT_KIND_BI */
CREATE TRIGGER TEACHER_CAT_KIND_BI FOR TEACHER_CAT_KIND
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.f_id is null) then
    new.f_id = gen_id(gen_teacher_cat_kind_id,1);
end
^


/* Trigger: TEACHER_TITLE_KIND_BI */
CREATE TRIGGER TEACHER_TITLE_KIND_BI FOR TEACHER_TITLE_KIND
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.f_id is null) then
    new.f_id = gen_id(gen_teacher_title_kind_id,1);
end
^


/* Trigger: T_BI_OCK */
CREATE TRIGGER T_BI_OCK FOR OBJ_CAT_KIND
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.f_id is null) then
    new.f_id = gen_id(gen_obj_cat_kind_id,1);
end
^


/* Trigger: T_BI_ONT */
CREATE TRIGGER T_BI_ONT FOR OBJ_NOTE_TYPE
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.f_id is null) then
    new.f_id = gen_id(gen_obj_note_id, 1);
end
^


/* Trigger: T_BI_TN */
CREATE TRIGGER T_BI_TN FOR TEACHER_NOTE
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.f_id is null) then
    new.f_id = gen_id(gen_teacher_note_id, 1);
end
^


/* Trigger: T_CIS_CURRICULUM */
CREATE TRIGGER T_CIS_CURRICULUM FOR CALC_INDIVIDUAL_SUBJECT
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  IF (new.ID_CURRICULUM IS NULL) THEN
    SELECT D."CurriculumID" FROM "Department" D WHERE D.ID = NEW.ID_DEPARTMENT INTO NEW.ID_CURRICULUM;
  IF (NEW.SHOW_POSITION IS NULL) THEN
    SELECT COALESCE(MAX(CIS.SHOW_POSITION), 0) + 1
    FROM CALC_INDIVIDUAL_SUBJECT CIS
    WHERE
      CIS.ID_CALC_INDIVIDUAL = NEW.ID_CALC_INDIVIDUAL AND
      CIS.ID_CALC_PACK = NEW.ID_CALC_PACK
    INTO NEW.SHOW_POSITION;
end
^


SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

ALTER PROCEDURE ABSENT_TAB_PART_2
RETURNS (
    ABSENCE_CODES VARCHAR(255),
    TEACHER_TAB_NUM INTEGER,
    CLOCK_Y INTEGER,
    CLOCK_O INTEGER,
    CLOCK_C INTEGER,
    CLOCK_SWP_Y INTEGER,
    CLOCK_SWP_O INTEGER,
    CLOCK_SWP_C INTEGER)
AS
  declare variable v_date_begin date;
  declare variable v_date_end   date;
  declare variable v_id         integer;
  declare variable v_qty        integer;
  declare variable v_code       varchar(150);
begin
  select c.system_date from constants c into :v_date_begin;

  v_date_begin = v_date_begin - extract(day from v_date_begin) + 1;
  v_date_end = dateadd(1 month to v_date_begin) - 1;

  for
    select t.tab_num, t.id
    from "Teacher" t
    order by t."Name"
    into :teacher_tab_num, :v_id
  do
  begin
    absence_codes = '';
    for
      select abt.code, count(*)
      from teacher_absent ta
        left join absent_type abt on abt.id = ta.absent_type_id
      where ta.teacher_id = :v_id and ta.absent_date between :v_date_begin and :v_date_end
      group by abt.code
      into :v_code, :v_qty
    do
      absence_codes = absence_codes || v_qty || ' ' || v_code || ' ';

    suspend;
  end
end^


ALTER PROCEDURE ADD_CURR_CAT (
    CURR_ID INTEGER,
    CLASS_NUM INTEGER,
    CAT INTEGER)
AS
DECLARE VARIABLE TMP INTEGER;
begin
  
  select CC.curr_id
  from curr_cat CC
  where CC.curr_id = :curr_id and CC.class_num = :class_num
  into :tmp;

  if (:tmp is not null) then
  begin
    update curr_cat CC
    set CC.category = :cat
    where CC.curr_id = :curr_id and CC.class_num = :class_num;
  end
  else
    insert into curr_cat values(:curr_id, :class_num, :cat);
end^


ALTER PROCEDURE ADD_CURR_REC (
    CURR_ID INTEGER,
    ID INTEGER,
    SUBJ_ID INTEGER,
    GROUP_QTY INTEGER,
    R_POS INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
declare variable m integer;
declare variable i integer;
begin
    OUT_ID = 0;
    if (:ID=0) then
    begin 
        select Max(CR.ID) from curr_rec CR where CR.curr_id = :curr_id into :ID;
        if (:ID is not NULL) then ID = ID + 1; else ID = 1;
        out_id = id;

        select Max(CR.num) from curr_rec CR where CR.curr_id = :curr_id into :M;
        if (:M is not NULL) then M = M + 1; else M = 1;

        if ((:r_pos is not null) and (:r_pos < :m)) then
        begin
          update curr_rec CR
          set CR.num = CR.num + 1
          where CR.num >= :r_pos and CR.curr_id = :curr_id;

          insert into curr_rec (curr_id, id, num, subject_id, group_qty, is_cmaster)
          values (:curr_id, :id, :r_pos, :subj_id, :group_qty, case when :subj_id = 1 then 1 else 0 end);
        end
        else
        begin
          insert into curr_rec (curr_id, id, num, subject_id, group_qty, is_cmaster)
          values (:curr_id, :ID , :M, :subj_id, :group_qty, case when :subj_id = 1 then 1 else 0 end);
          OUT_ID = :ID;
        end
    end
    else
    begin
        select CR.ID
        from curr_rec CR
        where (CR.curr_id = :curr_id) and (CR.ID = :ID)
        into :out_id;
               
        if (out_id is not NULL) then
            update curr_rec CR
            set CR.subject_id = :subj_id,
                CR.group_qty  = :group_qty,
                cr.is_cmaster = case when :subj_id = 1 then 1 else 0 end
            where (CR.curr_id = :curr_id) and (ID = :ID);
        else
            out_id = 0;
    end
end^


ALTER PROCEDURE ADD_CURR_REC_TIME (
    CURR_ID INTEGER,
    CURR_REC_ID INTEGER,
    CLASS_NUM INTEGER,
    C_TIME DOUBLE PRECISION)
AS
DECLARE VARIABLE TMP INTEGER;
begin
  select CRT.curr_id
  from curr_rec_time CRT
  where CRT.curr_id = :curr_id and CRT.curr_rec_id = :curr_rec_id and
    CRT.class_num = :class_num
  into :tmp;

  if (:tmp is not null) then
  begin
    update curr_rec_time CRT
    set CRT.c_time = :c_time
    where CRT.curr_id = :curr_id and CRT.curr_rec_id = :curr_rec_id and
      CRT.class_num = :class_num;
  end
  else
    insert into curr_rec_time values (:curr_id, :curr_rec_id, :class_num, :c_time);
end^


ALTER PROCEDURE ADD_CURRICULUM (
    INID INTEGER,
    INNAME VARCHAR(150),
    INPERIOD INTEGER,
    IN_PERIOD_FOR_PRINT VARCHAR(150))
RETURNS (
    OUTID INTEGER)
AS
begin
    OUTID = 0;
    if (:InID=0) then
    begin  InID = Gen_ID(GEN_CURRICULUM_ID,1);
        insert into curriculum (id, name, period, pos, period_for_print)
        values (:InID , :InName, :InPeriod, 0, coalesce(:in_period_for_print, :INPERIOD));
        OUTID = :InID;
    end
    else
    begin
        select ID
        from curriculum
        where ID = :InID
        into :OutID;
               
        if (OutID is not NULL) then
            update curriculum
            set name = :InName,
                period =: InPeriod,
                period_for_print = coalesce(:in_period_for_print, :INPERIOD)
            where ID =: InID;
        else
            OutID=0;
    end
end^


ALTER PROCEDURE ADD_DEPARTMENT (
    INID INTEGER,
    INCODE INTEGER,
    INNAME VARCHAR(30),
    INCURRICULUMID INTEGER,
    ININFO VARCHAR(50))
RETURNS (
    OUTID INTEGER)
AS
begin
    OUTID=0;
    if (:InID=0) then
    begin  InID=Gen_ID(GEN_DEPARTMENT_ID,1);
        insert into "Department" 
            values (:InID ,  :InCode ,  :InName, :InCurriculumID, :InInfo);
        OUTID=:InID;
    end
    else
    begin
        select "ID"
        from "Department"
        where "ID" = :InID
        into :OutID;
               
        if (OutID is not NULL) then
            update "Department"
            set "Code" =: InCode,   
                "Name" =: InName,
                "CurriculumID" =: InCurriculumID,    
                "Info" =: InInfo
            where "ID" =: InID;
        else
            OutID=0;
    end
end^


ALTER PROCEDURE ADD_EDUCATION (
    INID INTEGER,
    INNAME VARCHAR(30))
RETURNS (
    OUTID INTEGER)
AS
begin
    OUTID = 0;
    if (:InID=0) then
    begin  InID = Gen_ID(GEN_EDUCATION_ID, 1);
        insert into "Education" 
            values (:InID , :InName);
        OUTID = :InID;
    end
    else
    begin
        select "ID"
        from "Education"
        where "ID" = :InID
        into :OutID;
               
        if (OutID is not NULL) then
            update "Education"
            set "Name" =: InName 
            where "ID" =: InID;
        else
            OutID=0;
    end
end^


ALTER PROCEDURE ADD_FILIAL (
    INID INTEGER,
    INCODE INTEGER,
    INNAME VARCHAR(30),
    ININFO VARCHAR(50))
RETURNS (
    OUTID INTEGER)
AS
begin
    OUTID = 0;
    if (:InID=0) then
    begin  InID = Gen_ID(GEN_FILIAL_ID,1);
        insert into "Filial" 
            values (:InID ,  :InCode ,   :InName, :InInfo);
        OUTID = :InID;
    end
    else
    begin
        select "ID"
        from "Filial"
        where "ID" = :InID
        into :OutID;
               
        if (OutID is not NULL) then
            update "Filial"
            set "Code" =: InCode,   
                "Name" =: InName, 
                "Info" =: InInfo
            where "ID" =: InID;
        else
            OutID=0;
    end
end^


ALTER PROCEDURE ADD_GROUPING (
    IN_ID INTEGER,
    IN_NAME VARCHAR(30),
    IN_FINANC_ID INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
begin
  /* Procedure Text */
  if (:in_id = 0) then /* add*/
  begin in_id = gen_id(gen_grouping_id, 1);
    insert into grouping values (:in_id, :in_name, :in_financ_id);
    out_id = in_id;
  end
  else
  begin
    select ID from grouping
    where ID = :in_id
    into :out_id;

    if (:out_id is not null) then
      update grouping set Name = :in_name, Financing_ID = :in_financ_id
      where ID = :in_id;
    else
      out_id = 0;
  end
end^


ALTER PROCEDURE ADD_GROUPING_DEPT (
    IN_GROUPING_ID INTEGER,
    IN_DEPT_ID INTEGER)
AS
DECLARE VARIABLE TMP_GR_ID INTEGER;
begin
  /* Procedure Text */
  select GROUPING_ID
  from grouping_dept G
  where G.grouping_id = :in_grouping_id and
        G.department_id = :in_dept_id
  into :TMP_GR_ID;
  if (:tmp_gr_id is null) then /* add*/
    insert into grouping_dept values (:in_grouping_id, :in_dept_id);
end^


ALTER PROCEDURE ADD_GROUPING_SUBJ (
    IN_GROUPING_ID INTEGER,
    IN_SUBJ_ID INTEGER,
    IN_SUBJ_NAME VARCHAR(30),
    IN_CODE INTEGER,
    IN_GR_QTY INTEGER,
    IN_POS INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
DECLARE VARIABLE CURR_POS INTEGER;
DECLARE VARIABLE MIN_POS INTEGER;
DECLARE VARIABLE MAX_POS INTEGER;
begin
  if (in_subj_id is null) then
  --Add
  begin
    select max(GS.id) from grouping_subj GS
    where GS.grouping_id = :in_grouping_id
    into :OUT_ID;    

    if (:out_id is null) then out_id = 1;
    else out_id = out_id + 1;

    if (:in_pos is null) then
    begin
      select max(GS.pos) from grouping_subj GS
      where GS.grouping_id = :in_grouping_id
      into :in_pos;

      if (:in_pos is null) then in_pos = 1;
      else in_pos = in_pos + 1;
    end
    else
      update grouping_subj GS set GS.pos = GS.pos + 1
      where GS.grouping_id = :in_grouping_id and GS.pos >= :in_pos;
    insert into grouping_subj values (:in_grouping_id, :out_id, :in_subj_name, :in_code, :in_gr_qty, 
:in_pos);
  end
  else
  --Update
  begin
    select GS.id, GS.pos
    from grouping_subj GS
    where GS.grouping_id = :in_grouping_id and GS.id = :in_subj_id
    into :out_id, :curr_pos;

    select max(GS.pos) from grouping_subj GS
    where GS.grouping_id = :in_grouping_id
    into :max_pos;

    select min(GS.pos) from grouping_subj GS
    where GS.grouping_id = :in_grouping_id
    into :min_pos;

    if (:in_pos < :min_pos) then in_pos = min_pos;
    if ((:in_pos > :max_pos) or (:in_pos is null)) then in_pos = max_pos;

    if (:out_id is not null) then
    begin
      if (:curr_pos < :in_pos) then
        update grouping_subj GS set GS.pos = GS.pos - 1
        where GS.grouping_id = :in_grouping_id and GS.pos > :curr_pos and GS.pos <= :in_pos;
      else if (:curr_pos > :in_pos) then
        update grouping_subj GS set GS.pos = GS.pos + 1
        where GS.grouping_id = :in_grouping_id and GS.pos < :curr_pos and GS.pos >= :in_pos;
      update grouping_subj GS set
        GS.pos = :in_pos, GS.name = :in_subj_name,
        GS.code = :in_code, GS.group_qty = :in_gr_qty
      where GS.grouping_id = :in_grouping_id and GS.id = :in_subj_id;
    end
  end
end^


ALTER PROCEDURE ADD_GROUPING_SUBJ_CURR (
    IN_GROUPING_ID INTEGER,
    IN_GR_SUBJ_ID INTEGER,
    IN_CURR_ID INTEGER,
    IN_CURR_REC_ID INTEGER)
AS
begin
  insert into grouping_subj_curr_id values
  (:in_grouping_id, :in_gr_subj_id, :in_curr_id, :in_curr_rec_id);
end^


ALTER PROCEDURE ADD_LEARN_TIME_GRID (
    ID INTEGER,
    FINANCING_ID INTEGER,
    NAME VARCHAR(50))
RETURNS (
    OUT_ID INTEGER)
AS
begin
  if (:ID is null) then
  begin
    out_id = gen_id(gen_learn_time_grid, 1);
    insert into learn_time_grid values (:out_id, :financing_id, :name);
  end
  else
  begin
    select LTG.id from learn_time_grid LTG where LTG.id = :ID
    into :out_id;

    if (:out_id is not null) then
      update learn_time_grid LTG set
        LTG.name = :name,
        LTG.financing_id = :financing_id
      where LTG.id = :id;
  end
end^


ALTER PROCEDURE ADD_LTG_GROUPING (
    LTG_ID INTEGER,
    GROUPING_ID INTEGER)
AS
DECLARE VARIABLE TMP INTEGER;
begin
  select LG.ltg_id from ltg_grouping LG
  where LG.ltg_id = :ltg_id and LG.grouping_id = :grouping_id
  into :tmp;

  if (:tmp is null) then
    insert into ltg_grouping values (:ltg_id, :grouping_id);
end^


ALTER PROCEDURE ADD_LTG_I_SUBJ_CURR (
    LTG_ID INTEGER,
    LTG_I_SUBJ_ID INTEGER,
    CURR_ID INTEGER,
    CURR_REC_ID INTEGER)
AS
DECLARE VARIABLE TMP INTEGER;
begin
  select LISC.ltg_id
  from ltg_i_subj_curr LISC
  where LISC.ltg_id = :ltg_id and LISC.ltg_i_subj_id = :ltg_i_subj_id and
    LISC.curr_id = :curr_id and LISC.curr_rec_id = :curr_rec_id
  into :tmp;

  if (:tmp is null) then
    insert into ltg_i_subj_curr values (:LTG_ID, :ltg_i_subj_id, :curr_id, :curr_rec_id);
end^


ALTER PROCEDURE ADD_LTG_I_SUBJECT (
    LTG_ID INTEGER,
    I_SUBJ_ID INTEGER,
    I_SUBJ_NAME VARCHAR(30),
    POS INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
DECLARE VARIABLE MAX_POS INTEGER;
DECLARE VARIABLE MIN_POS INTEGER;
DECLARE VARIABLE CURR_POS INTEGER;
begin
  if (:i_subj_id is null) then
  begin
    select max(LIS.id) from ltg_i_subject LIS
    where LIS.ltg_id = :ltg_id
    into :out_id;

    if (:out_id is null) then out_id = 1;
    else out_id = out_id + 1;

    if (:pos is null) then
    begin
      select max(LIS.pos) from ltg_i_subject LIS
      where LIS.ltg_id = :ltg_id
      into :pos;
      if (:pos is null) then pos = 1;
      else pos = pos + 1;
    end
    else
      update ltg_i_subject LIS set LIS.pos = LIS.pos + 1
      where LIS.ltg_id = :ltg_id and LIS.pos >= :pos;

    insert into ltg_i_subject values (:ltg_id, :out_id, :pos, :i_subj_name);
  end
  else
  begin
    select LIS.id, LIS.pos
    from ltg_i_subject LIS
    where LIS.ltg_id = :ltg_id and LIS.id = :i_subj_id
    into :out_id, :curr_pos;

    select max(LIS.pos) from ltg_i_subject LIS
    where LIS.ltg_id = :ltg_id
    into :max_pos;

    select min(LIS.pos) from ltg_i_subject LIS
    where LIS.ltg_id = :ltg_id
    into :min_pos;

    if (:pos < :min_pos) then pos = min_pos;
    if ((:pos > :max_pos) or (:pos is null)) then pos = max_pos;

    if (:out_id is not null) then
    begin
      if (:curr_pos < :pos) then
        update ltg_i_subject LIS set LIS.pos = LIS.pos - 1
        where LIS.ltg_id = :ltg_id and LIS.pos > :curr_pos and LIS.pos <= :pos;
      else if (:curr_pos > :pos) then
        update ltg_i_subject LIS set LIS.pos = LIS.pos + 1
        where LIS.ltg_id = :ltg_id and LIS.pos < :curr_pos and LIS.pos >= :pos;
      update ltg_i_subject LIS set LIS.pos = :pos, LIS.name = :i_subj_name
      where LIS.ltg_id = :ltg_id and LIS.id = :i_subj_id;
    end
  end
end^


ALTER PROCEDURE ADD_POST (
    INID INTEGER,
    INNAME VARCHAR(30))
RETURNS (
    OUTID INTEGER)
AS
begin
  OUTID = 0;
  if (:InID=0) then
  begin  InID = Gen_ID(GEN_POST_ID, 1);
    insert into "Post"(id, "Name")
    values (:InID , :InName);
      OUTID = :InID;
    end
  else
  begin
    select "ID"
    from "Post"
    where "ID" = :InID
    into :OutID;
               
    if (OutID is not NULL) then
      update "Post"
      set "Name" =: InName
      where "ID" =: InID;
    else
      OutID=0;
  end
end^


ALTER PROCEDURE ADD_REP_TAB (
    ID INTEGER,
    T_ID INTEGER,
    TAB_NUM INTEGER,
    T_NAME VARCHAR(100),
    D_QTY INTEGER,
    B_Y_T DOUBLE PRECISION,
    B_O_T DOUBLE PRECISION,
    B_C_T DOUBLE PRECISION,
    S_Y_T DOUBLE PRECISION,
    S_O_T DOUBLE PRECISION,
    S_C_T DOUBLE PRECISION,
    BE_Y_T DOUBLE PRECISION,
    BE_C_T DOUBLE PRECISION,
    T_DATE DATE)
RETURNS (
    O_ID INTEGER)
AS
begin
  /* Procedure Text */

  if (id = 0) then
  begin
    id = gen_id(gen_rep_tab, 1);
      insert into rep_tab values (:id, :t_id, :tab_num, :t_name, :d_qty, :b_y_t, :b_o_t,
      :b_c_t, :s_y_t, :s_o_t, :s_c_t, :be_y_t, :be_c_t, :t_date, null);
    o_id = id;
  end
  else
  begin
    update rep_tab RT set
      RT.teacher_id = :t_id,
      RT.tab_num = :tab_num,
      RT.teacher_name = :t_name,
      RT.days_qty = :d_qty,
      RT.b_y_time = :b_y_t,
      RT.b_o_time = :b_o_t,
      RT.b_c_time = :b_c_t,
      RT.s_y_time = :s_y_t,
      RT.s_o_time = :s_o_t,
      RT.s_c_time = :s_c_t,
      RT.begin_y_time = :be_y_t,
      RT.begin_c_time = :be_c_t
    where RT.id = :id;
    o_id = id;
  end
end^


ALTER PROCEDURE ADD_REP_TAB_EXT (
    IN_REC_TIME TIMESTAMP,
    IN_TEACHER_NAME VARCHAR(100),
    IN_TAB_MONTH DATE,
    IN_Y_T DOUBLE PRECISION,
    IN_O_T DOUBLE PRECISION,
    IN_C_T DOUBLE PRECISION,
    IN_Y_T_OOD DOUBLE PRECISION,
    IN_O_T_OOD DOUBLE PRECISION,
    IN_C_T_OOD DOUBLE PRECISION,
    IN_Y_T_FILIAL DOUBLE PRECISION,
    IN_O_T_FILIAL DOUBLE PRECISION,
    IN_C_T_FILIAL DOUBLE PRECISION)
RETURNS (
    OUT_REC_TIME TIMESTAMP)
AS
declare variable tmp integer;
begin
  if (:in_rec_time is not null) then /*edit mode*/
  begin
    select RTE.rec_time
    from rep_tab_ext RTE
    where RTE.rec_time = :in_rec_time
    into :out_rec_time;

    if (:out_rec_time is not null) then
      update rep_tab_ext RTE
      set RTE.teacher_name = :in_teacher_name,
          RTE.tab_month = :in_tab_month,
          RTE.y_t = :in_y_t,
          RTE.o_t = :in_o_t,
          RTE.c_t = :in_c_t,
          RTE.y_t_ood = :in_y_t_ood,
          RTE.o_t_ood = :in_o_t_ood,
          RTE.c_t_ood = :in_c_t_ood,
          RTE.y_t_filial = :in_y_t_filial,
          RTE.o_t_filial = :in_o_t_filial,
          RTE.c_t_filial = :in_c_t_filial
       where RTE.rec_time = :in_rec_time;
  end
  else
  begin
    out_rec_time = current_timestamp;
    insert into rep_tab_ext values (:out_rec_time, :in_teacher_name, :in_tab_month,
      :in_y_t, :in_o_t, :in_c_t, :in_y_t_ood, :in_o_t_ood, :in_c_t_ood,
      :in_y_t_filial, :in_o_t_filial, :in_c_t_filial);
  end
end^


ALTER PROCEDURE ADD_REP_TAB_EXT_2 (
    IN_REC_TIME TIMESTAMP,
    IN_TEACHER_NAME VARCHAR(100),
    IN_TAB_MONTH DATE,
    IN_Y_T DOUBLE PRECISION,
    IN_O_T DOUBLE PRECISION,
    IN_C_T DOUBLE PRECISION,
    IN_Y_T_OOD DOUBLE PRECISION,
    IN_O_T_OOD DOUBLE PRECISION,
    IN_C_T_OOD DOUBLE PRECISION,
    IN_Y_T_FILIAL DOUBLE PRECISION,
    IN_O_T_FILIAL DOUBLE PRECISION,
    IN_C_T_FILIAL DOUBLE PRECISION)
RETURNS (
    OUT_REC_TIME TIMESTAMP)
AS
declare variable tmp integer;
begin
  if (:in_rec_time is not null) then /*edit mode*/
  begin
    select RTE.rec_time
    from rep_tab_ext_2 RTE
    where RTE.rec_time = :in_rec_time
    into :out_rec_time;

    if (:out_rec_time is not null) then
      update rep_tab_ext_2 RTE
      set RTE.teacher_name = :in_teacher_name,
          RTE.tab_month = :in_tab_month,
          RTE.y_t = :in_y_t,
          RTE.o_t = :in_o_t,
          RTE.c_t = :in_c_t,
          RTE.y_t_ood = :in_y_t_ood,
          RTE.o_t_ood = :in_o_t_ood,
          RTE.c_t_ood = :in_c_t_ood,
          RTE.y_t_filial = :in_y_t_filial,
          RTE.o_t_filial = :in_o_t_filial,
          RTE.c_t_filial = :in_c_t_filial
       where RTE.rec_time = :in_rec_time;
  end
  else
  begin
    out_rec_time = current_timestamp;
    insert into rep_tab_ext_2 values (:out_rec_time, :in_teacher_name, :in_tab_month,
      :in_y_t, :in_o_t, :in_c_t, :in_y_t_ood, :in_o_t_ood, :in_c_t_ood,
      :in_y_t_filial, :in_o_t_filial, :in_c_t_filial);
  end
end^


ALTER PROCEDURE ADD_REPORT_PARAM (
    IN_ID INTEGER,
    IN_NAME VARCHAR(30),
    IN_PAGE_ORIENT SMALLINT,
    IN_M_LEFT INTEGER,
    IN_M_RIGHT INTEGER,
    IN_M_TOP INTEGER,
    IN_M_BOTTOM INTEGER,
    IN_SIZES_1 VARCHAR(30),
    IN_SIZES_2 VARCHAR(30),
    IN_SIZES_3 VARCHAR(30),
    IN_QTY_1 SMALLINT,
    IN_QTY_2 SMALLINT,
    IN_QTY_3 SMALLINT)
RETURNS (
    OUT_ID INTEGER)
AS
begin
  if (:in_id is null) then
  begin
    out_id = gen_id(gen_report_param_id, 1);
    insert into report_param values (:out_id, :in_name, :in_page_orient, :in_m_left,
      :in_m_right, :in_m_top, :in_m_bottom, :in_sizes_1, :in_sizes_2, :in_sizes_3,
      :in_qty_1, :in_qty_2, :in_qty_3);
  end
  else
  begin
    select RP.id
    from report_param RP
    where RP.id = :in_id
    into :out_id;

    if (:out_id is not null) then
      update report_param RP
      set
        RP.name = :in_name,
        RP.page_orient = :in_page_orient,
        RP.m_left = :in_m_left,
        RP.m_right = :in_m_right,
        RP.m_top = :in_m_top,
        RP.m_bottom = :in_m_bottom,
        RP.sizes_1 = :in_sizes_1,
        RP.sizes_2 = :in_sizes_2,
        RP.sizes_3 = :in_sizes_3,
        RP.qty_1 = :in_qty_1,
        RP.qty_2 = :in_qty_2,
        RP.qty_3 = :in_qty_3
      where RP.id = :in_id;
  end
end^


ALTER PROCEDURE ADD_SPECIALIZATION (
    INID INTEGER,
    INDEPARTMENTID INTEGER,
    INCODE INTEGER,
    INNAME VARCHAR(30),
    INBUDGET DOUBLE PRECISION,
    INSELF_REPAYMENT DOUBLE PRECISION,
    ININFO VARCHAR(50))
RETURNS (
    OUTID INTEGER)
AS
begin
    OUTID = 0;
    if (:InID=0) then
    begin  InID = Gen_ID(GEN_SPECIALIZATION_ID,1);
        insert into "Specialization" 
            values (:InID , :InDepartmentID, :InCode ,   :InName, 
                :InBudget, :InSelf_Repayment, :InInfo);
        OUTID = :InID;
    end
    else
    begin
        select "ID"
        from "Specialization"
        where "ID" = :InID
        into :OutID;
               
        if (OutID is not NULL) then
            update "Specialization"
            set "DepartmentID" = :InDepartmentID,
                "Code" =: InCode,   
                "Name" =: InName,
                "Budget" =: InBudget,
                "Self_Repayment" =: InSelf_Repayment,
                "Info" =: InInfo
            where "ID" =: InID;
        else
            OutID=0;
    end
end^


ALTER PROCEDURE ADD_STUDENT (
    INID INTEGER,
    INCODE INTEGER,
    INNAME VARCHAR(50),
    INSPECID INTEGER,
    INFILIALID INTEGER,
    INFINANCINGID SMALLINT,
    INMASTERID INTEGER,
    INCLASS SMALLINT,
    INPERCENT SMALLINT,
    INBIRTHDATE DATE,
    INENTERDATE DATE,
    INRELEASEDATE DATE,
    INRESTOREDATE DATE,
    INENTERINFO VARCHAR(30),
    INRELEASEINFO VARCHAR(30),
    INRESTOREINFO VARCHAR(30),
    INACADEMYBDATE DATE,
    INACADEMYEDATE DATE,
    INACADEMYBINFO VARCHAR(30),
    INACADEMYEINFO VARCHAR(30),
    INADDRESS VARCHAR(256),
    INTELEPHONE VARCHAR(50),
    IN_ID_SEX INTEGER)
RETURNS (
    OUTID INTEGER)
AS
declare variable rel smallint;
declare variable ac smallint;
BEGIN
    OutID = 0;
    rel = 0;
    if (:inreleasedate is not null) then
      if (:inrestoredate is null) then rel = 1;
      else
        if (:inreleasedate > :inrestoredate) then rel = 1;

    ac = 0;
    if (:inacademybdate is not null) then
      if (:inacademyedate is null) then ac = 1;
      else
        if (:inacademybdate > :inacademyedate) then ac = 1;

    if (:InID = 0) then
    begin
        InID = Gen_ID(GEN_STUDENT_ID, 1);
        insert into "Student" VALUES (
            :InID, :InCode, :InName, :InSpecID, :InFilialID, :InFinancingID, :InMasterID, :InClass, :InPercent, :InBirthDate, :InEnterDate,
            :InReleaseDate, :InRestoreDate, :InEnterInfo, :InReleaseInfo, :InRestoreInfo, :InAcademyBDate, :InAcademyEDate, :InAcademyBInfo, 
            :InAcademyEInfo, :InAddress, :InTelephone, :rel, :ac, :in_id_sex
        );
        OutID = InID;
    end
    else
    BEGIN
        SELECT "ID" FROM "Student" WHERE "ID" = :InID INTO :OutID;
        if (OutID is not NULL) then
        begin
            UPDATE "Student"
            SET "Code" = :InCode,
                "Name" = :InName,
                "SpecializationID" = :InSpecID,
                "FilialID" = :InFilialID,
                "FinancingID" = :InFinancingID,    
                "MasterID" = :InMasterID,
                "Class" = :InClass,
                "Percent" = :InPercent,
                "BirthDate" = :InBirthDate,
                "EnterDate" = :InEnterDate,
                "ReleaseDate" = :InReleaseDate,
                "RestoreDate" = :InRestoreDate,
                "EnterInfo" = :InEnterInfo,
                "ReleaseInfo" = :InReleaseInfo,
                "RestoreInfo" = :InRestoreInfo,
                "AcademyBDate" = :InAcademyBDate,
                "AcademyEDate" = :InAcademyEDate,
                "AcademyBInfo" = :InAcademyBInfo,
                "AcademyEInfo" = :InAcademyEInfo,
                "Address" = :InAddress,
                "Telephone" = :InTelephone,
                Released = :rel,
                Academy = :ac,
                f_id_sex = :in_id_sex
            WHERE "ID" = :InID;
        end
        else
            OutID = 0;
    END
END^


ALTER PROCEDURE ADD_STUDENT_FILTER (
    IN_ID INTEGER,
    IN_NAME VARCHAR(30),
    IN_FILIAL_ID INTEGER,
    IN_CLASS_B INTEGER,
    IN_CLASS_E INTEGER,
    IN_CURATOR_ID INTEGER,
    IN_CATEGORY INTEGER,
    IN_PERIOD INTEGER,
    IN_STATUS INTEGER,
    IN_PAY_PERCENT INTEGER,
    IN_AGE_B INTEGER,
    IN_AGE_E INTEGER,
    IN_ENTER_D_B DATE,
    IN_ENTER_D_E DATE,
    IN_RELEASE_D_B DATE,
    IN_RELEASE_D_E DATE,
    IN_RESTORE_D_B DATE,
    IN_RESTORE_D_E DATE,
    IN_ACADEMY_D_B DATE,
    IN_ACADEMY_D_E DATE,
    IN_SUBJECT_ID_1 INTEGER,
    IN_TEACHER_ID_1 INTEGER,
    IN_SUBJECT_ID_2 INTEGER,
    IN_TEACHER_ID_2 INTEGER,
    IN_SUBJ_STATE INTEGER,
    IN_FINANCING_ID INTEGER,
    IN_ID_SEX INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
begin
  if (:in_id is null) then
  begin
    in_id = gen_id(gen_student_filter_id, 1);
    out_id = in_id;

    insert into student_filter
    values (:in_id, :in_name, :in_filial_id,
      :in_class_b, :in_class_e, :in_curator_id, :in_category, :in_period, :in_status,
      :in_pay_percent, :in_age_b, :in_age_e, :in_enter_d_b, :in_enter_d_e, :in_release_d_b,
      :in_release_d_e, :in_restore_d_b, :in_restore_d_e, :in_academy_d_b, :in_academy_d_e,
      :in_subject_id_1, :in_teacher_id_1, :in_subject_id_2, :in_teacher_id_2, :in_subj_state,
      :in_financing_id, :in_id_sex);
  end
  else
    select SF.id
    from student_filter SF
    where SF.id = :in_id
    into :out_id;

    if (out_id is not null) then
    begin
      update student_filter SF
      set
        SF.name = :in_name,
        SF.filial_id = :in_filial_id,
        SF.class_b = :in_class_b,
        SF.class_e = :in_class_e,
        SF.curator_id = :in_curator_id,
        SF.category = :in_category,
        SF.period = :in_period,
        SF.status = :in_status,
        SF.pay_percent = :in_pay_percent,
        SF.age_b = :in_age_b,
        SF.age_e = :in_age_e,
        SF.enter_d_b = :in_enter_d_b, 
        SF.enter_d_e = :in_enter_d_e,
        SF.release_d_b = :in_release_d_b,
        SF.release_d_e = :in_release_d_e,
        SF.restore_d_b = :in_restore_d_b,
        SF.restore_d_e = :in_restore_d_e,
        SF.academy_d_b = :in_academy_d_b,
        SF.academy_d_e = :in_academy_d_e,
        SF.subject_id_1 = :in_subject_id_1,
        SF.subject_id_2 = :in_subject_id_2,
        SF.teacher_id_1 = :in_teacher_id_1,
        SF.teacher_id_2 = :in_teacher_id_2,
        SF.subj_state = :in_subj_state,
        SF.financing_id = :in_financing_id,
        SF.f_id_sex = :in_id_sex
      where SF.id = :in_id;
    end
end^


ALTER PROCEDURE ADD_STUDENT_FILTER_SPEC (
    ID_FILTER INTEGER,
    ID_SPECIALIZATION INTEGER)
AS
begin
  IF (EXISTS (SELECT * FROM STUDENT_FILTER WHERE ID = :ID_FILTER)) THEN
  BEGIN
    IF (NOT EXISTS (
      SELECT *
      FROM STUDENT_FILTER_SPEC
      WHERE ID_FILTER = :ID_FILTER AND ID_SPECIALIZATION = :ID_SPECIALIZATION))
    THEN
      INSERT INTO STUDENT_FILTER_SPEC (ID_FILTER, ID_SPECIALIZATION)
      VALUES (:ID_FILTER, :ID_SPECIALIZATION);
  END
  ELSE
    EXCEPTION E_STUDENT_FILTER_SPEC;
end^


ALTER PROCEDURE ADD_STUDENT_PLAN (
    IN_CURR_REC_ID INTEGER,
    IN_STUDENT_ID INTEGER,
    IN_USE SMALLINT,
    IN_TEACHER_ID INTEGER)
RETURNS (
    OUTID INTEGER)
AS
begin
  OUTID = null;

  if (in_teacher_id is null) then
    delete from "Student_Plan" STP
    where STP."StudentID" = :in_student_id and STP.curr_rec_id = :in_curr_rec_id;
  else
  begin
    select STP.curr_rec_id
    from "Student_Plan" STP
    where (STP.curr_rec_id = :in_curr_rec_id) and ("StudentID" = :In_Student_ID)
    into :OutID;
               
    if (OutID is not NULL) then
      update "Student_Plan" STP
      set "Use" = :In_Use, "TeacherID" = :In_Teacher_ID
      where (STP.curr_rec_id =: in_curr_rec_id) and ("StudentID" = :in_student_id);
    else
    begin
      insert into "Student_Plan" values (:in_student_id, :in_curr_rec_id, :in_teacher_id, :in_use);
      OutID = in_curr_rec_id;
    end
  end
end^


ALTER PROCEDURE ADD_SUBJECT (
    INID INTEGER,
    INCODE INTEGER,
    INNAME VARCHAR(30),
    ININFO VARCHAR(50),
    INSHORTNAME VARCHAR(150))
RETURNS (
    OUTID INTEGER)
AS
begin
    OUTID = 0;
    if (:InID=0) then
    begin  InID = Gen_ID(GEN_SUBJECT_ID,1);
        insert into "Subject" 
            values (:InID ,  :InCode ,   :InName, :InInfo, :inshortname);
        OUTID = :InID;
    end
    else
    begin
        select "ID"
        from "Subject"
        where "ID" = :InID
        into :OutID;
               
        if (OutID is not NULL) then
            update "Subject"
            set "Code" =: InCode,   
                "Name" =: InName, 
                "Info" =: InInfo,
                short_name =: inshortname
            where "ID" =: InID;
        else
            OutID=0;
    end
end^


ALTER PROCEDURE ADD_TARIFF (
    INGRADE INTEGER,
    INSALARY DOUBLE PRECISION,
    ININFO VARCHAR(50))
RETURNS (
    OUTID INTEGER)
AS
begin
    select "Grade" 
    from "Tariff" 
    where "Grade"=:InGrade 
    into :OutID;
    
    if (OutID is NULL) then
    begin  
        insert into "Tariff" 
        values (:InGrade , :InSalary, :InInfo);
        OUTID = :InGrade;
    end
    else
    begin
        update "Tariff"
        set "Grade" =: InGrade,   
            "Salary" =: InSalary, 
            "Info" =: InInfo
        where "Grade" =: InGrade;
    end
end^


ALTER PROCEDURE ADD_TEACHER (
    INID INTEGER,
    INTAB_NUM INTEGER,
    INNAME VARCHAR(100),
    INFILIALID INTEGER,
    INSUBJECTID INTEGER,
    INEDUCATIONID INTEGER,
    INPOSTID INTEGER,
    INSTAGEDATE DATE,
    INBIRTHDATE DATE,
    INENTERDATE DATE,
    INRELEASEDATE DATE,
    INGRADEID INTEGER,
    INCONCERTGRADEID INTEGER,
    INDIPLOMA VARCHAR(256),
    INADDRESS VARCHAR(256),
    INTELEPHONE VARCHAR(50),
    INSTAGEY SMALLINT,
    INSTAGEM SMALLINT,
    INSTAGED SMALLINT,
    INIDGRADEADD INTEGER,
    INIDGRADECONCERTADD INTEGER,
    INIDTITLE INTEGER,
    INIDCATEGORY INTEGER,
    INIDCATEGORYCONC INTEGER,
    INCATEGORYDATE DATE,
    INCATEGORYCONCDATE DATE,
    INQUALIFICATIONID INTEGER,
    INEDUCATION2ID INTEGER,
    INQUALIFICATION2ID INTEGER,
    INDIPLOMA2 VARCHAR(256))
RETURNS (
    OUTID INTEGER)
AS
BEGIN
    if (INRELEASEDATE = '01.01.1900') then InReleaseDate = NULL;
    OutID = 0;
    if (:InID = 0) then
    begin
        InID = Gen_ID(GEN_TEACHER_ID, 1);
        insert into "Teacher" VALUES (
            :InID, :INTAB_NUM, :InName, :InFilialID, :InSubjectID, :InEducationID, :InPostID, :InStageDate,
            :InBirthDate, :InEnterDate, :InReleaseDate, :InGradeID, :InConcertGradeID, :InDiploma, :InAddress, :InTelephone,
            :instagey, :instagem, :instaged, :inidgradeadd, :inidgradeconcertadd, :inidtitle, :inidcategory, :inidcategoryconc,
            :incategorydate, :incategoryconcdate, :ineducation2id, :inqualificationid, :inqualification2id, :indiploma2
        );
        outid = inid;
    end
    else
    BEGIN
        SELECT "ID" FROM "Teacher" WHERE "ID" = :InID INTO :OutID;
        if (OutID is not NULL) then
            UPDATE "Teacher" t
            SET "Name" = :InName,
                TAB_NUM = :intab_num,
                "FilialID" = :InFilialID,
                "SubjectID" = :InSubjectID,
                "EducationID" = :InEducationID,
                "PostID" = :InPostID,
                "StageDate" = :InStageDate,
                "BirthDate" = :InBirthDate,
                "EnterDate" = :InEnterDate,
                "ReleaseDate" = :InReleaseDate,
                "GradeID" = :InGradeID,
                "ConcertGradeID" = :InConcertGradeID,
                "Diploma" = :InDiploma,
                "Address" = :InAddress,
                "Telephone" = :InTelephone,
                STAGE_Y = :instagey,
                Stage_m = :instagem,
                Stage_d = :instaged,
                id_grade_add = :inidgradeadd,
                id_grade_concert_add = :inidgradeconcertadd,
                t.id_title = :inidtitle,
                t.id_category = :inidcategory,
                t.id_category_conc = :inidcategoryconc,
                t.category_date = :incategorydate,
                t.category_conc_date = :incategoryconcdate,
                t.education_2_id = :ineducation2id,
                t.qualification_id = :inqualificationid,
                t.qualification_2_id = :inqualification2id,
                t.diploma_2 = :indiploma2
            WHERE "ID" = :InID;
        else
            OutID = 0;
    END
    post_event 'edit_teacher';
END^


ALTER PROCEDURE ADD_TEACHER_ADDING (
    INID INTEGER,
    INTEACHERID INTEGER,
    INNAME VARCHAR(30),
    INPERCENT SMALLINT,
    INSUM DOUBLE PRECISION)
RETURNS (
    OUTID INTEGER)
AS
begin
    OUTID = 0;
    if (:InID=0) then
    begin  InID = Gen_ID(GEN_TEACHER_ADDINGS_ID, 1);
        insert into "Teacher_Addings" 
            values (:InID, :InTeacherID, :InName, :InPercent, :InSum);
        OUTID = :InID;
    end
    else
    begin
        select "ID"
        from "Teacher_Addings"
        where "ID" = :InID
        into :OutID;
               
        if (OutID is not NULL) then
            update "Teacher_Addings"
            set "TeacherID" = :InTeacherID,
                "Name" = :InName,
                "Percent" = :InPercent,
                "Sum" = :InSum
            where "ID" = :InID;
        else
            OutID = 0;
    end
end^


ALTER PROCEDURE ADD_TEACHER_CAT_KIND (
    P_ID INTEGER,
    P_NAME VARCHAR(150),
    P_PRINT VARCHAR(255),
    P_COEF DOUBLE PRECISION)
RETURNS (
    P_O_ID INTEGER)
AS
begin
  if (p_id is not null) then
  begin
    p_o_id = p_id;
    update teacher_cat_kind tcc
    set
      tcc.f_name  = :p_name,
      tcc.f_print = :p_print,
      tcc.f_coef  = :p_coef
    where tcc.f_id = :p_id;
   end
   else
   begin
     p_o_id = Gen_ID(gen_common, 1);
     insert into teacher_cat_kind (f_id, f_name, f_print, f_coef)
     values (:p_o_id, :p_name, :p_print, :p_coef);
   end
end^


ALTER PROCEDURE ADD_TEACHER_FILTER (
    IN_ID INTEGER,
    IN_NAME VARCHAR(30),
    IN_MAIN_SUBJ_ID INTEGER,
    IN_MAIN_GRADE INTEGER,
    IN_CONC_GRADE INTEGER,
    IN_POST_ID VARCHAR(255),
    IN_EDUCATION_ID VARCHAR(255),
    IN_FILIAL_ID INTEGER,
    IN_STATE INTEGER,
    IN_STAGE_B INTEGER,
    IN_STAGE_E INTEGER,
    IN_BIRTH_D_B DATE,
    IN_BIRTH_D_E DATE,
    IN_ENTER_D_B DATE,
    IN_ENTER_D_E DATE,
    IN_RELEASE_D_B DATE,
    IN_RELEASE_D_E DATE,
    IN_STAGE_B_M INTEGER,
    IN_STAGE_E_M INTEGER,
    IN_CAT_ID_PED VARCHAR(255),
    IN_CAT_ID_CONC VARCHAR(255),
    IN_TITLE_ID VARCHAR(255),
    IN_AGE_B INTEGER,
    IN_AGE_E INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
begin
  if (:in_id is null) then
  begin
    in_id = gen_id(gen_teacher_filter_id, 1);
    out_id = in_id;

    insert into teacher_filter
    values (:in_id, :in_name, :in_main_subj_id, :in_main_grade, :in_conc_grade, :in_post_id,
      :in_education_id, :in_filial_id, :in_state, :in_stage_b, :in_stage_e, :in_birth_d_b, 
      :in_birth_d_e, :in_enter_d_b, :in_enter_d_e, :in_release_d_b, :in_release_d_e,
      :in_stage_b_m, :in_stage_e_m, :in_cat_id_ped, :in_cat_id_conc, :in_title_id,
      :in_age_b, :in_age_e
    );
  end
  else
    select TF.id
    from teacher_filter TF
    where TF.id = :in_id
    into :out_id;

    if (:out_id is not null) then
    begin
      update teacher_filter TF
      set
        TF.name = :in_name,
        TF.main_subj_id = :in_main_subj_id,
        TF.main_grade = :in_main_grade,
        TF.conc_grade = :in_conc_grade,
        TF.post_id = :in_post_id,
        TF.education_id = :in_education_id,
        TF.filial_id = :in_filial_id,
        TF.state = :in_state,
        TF.stage_b = :in_stage_b,
        TF.stage_e = :in_stage_e,
        TF.birth_d_b = :in_birth_d_b,
        TF.birth_d_e = :in_birth_d_e,
        TF.enter_d_b = :in_enter_d_b,
        TF.enter_d_e = :in_enter_d_e,
        TF.release_d_b = :in_release_d_b,
        TF.release_d_e = :in_release_d_e,
        TF.stage_b_m = :in_stage_b_m,
        TF.stage_e_m = :in_stage_e_m,
        TF.cat_id_ped = :in_cat_id_ped,
        TF.cat_id_conc = :in_cat_id_conc,
        TF.title_id = :in_title_id,
        TF.age_b    = :in_age_b,
        TF.age_e    = :in_age_e
      where TF.id = :in_id;
    end
end^


ALTER PROCEDURE ADD_TEACHER_GROUP (
    GROUPING_ID INTEGER,
    TEACHER_ID INTEGER,
    GR_SUBJ_ID INTEGER,
    CLASS_NUM INTEGER,
    GROUP_Q INTEGER)
AS
DECLARE VARIABLE TMP INTEGER;
begin

  select TG.grouping_id
  from teacher_group TG
  where TG.grouping_id = :grouping_id and TG.teacher_id = :teacher_id and
    TG.gr_subj_id = :gr_subj_id and TG.class_num = :class_num
  into :tmp;

  if (:tmp is not null) then
  begin
    update teacher_group TG
    set TG.group_q = :group_q
    where TG.grouping_id = :grouping_id and TG.teacher_id = :teacher_id and
      TG.gr_subj_id = :gr_subj_id and TG.class_num = :class_num;
  end
  else
    insert into teacher_group values (:grouping_id, :teacher_id, :gr_subj_id,
      :class_num, :group_q);
  delete from teacher_group TG where TG.group_q is null;
end^


ALTER PROCEDURE CG_ADD (
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50),
    HEADER VARCHAR(3000),
    FOOTER VARCHAR(3000),
    SHOW_POSITION INTEGER)
RETURNS (
    ID INTEGER)
AS
BEGIN
  IF (NOT EXISTS(SELECT ID FROM CALC_PACK WHERE (ID = :ID_CALC_PACK))) THEN
    EXCEPTION E_CALC_PACK_NOT_EXIST;
  ID = GEN_ID(GEN_CALC_GROUP, 1);
  INSERT INTO CALC_GROUP (ID, ID_CALC_PACK, NAME, HEADER, FOOTER, SHOW_POSITION)
  VALUES (:ID, :ID_CALC_PACK, :NAME, :HEADER, :FOOTER, :SHOW_POSITION);
END^


ALTER PROCEDURE CG_DELETE (
    ID INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  DELETE FROM CALC_GROUP
  WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CG_FILL_FROM_GROUPING (
    ID_CALC_PACK INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_GROUPING INTEGER)
AS
DECLARE VARIABLE V_SUBJECT_NAME VARCHAR(50);
DECLARE VARIABLE V_ID_GROUPING_SUBJ INTEGER;
DECLARE VARIABLE V_IS_CONCERTMASTER INTEGER;
DECLARE VARIABLE V_ID_CGS INTEGER;
BEGIN
  FOR
    SELECT gs.name, gs.id, gs.code
    FROM grouping g
      INNER JOIN grouping_subj gs ON
        g.id = gs.grouping_id
    WHERE g.ID = :ID_GROUPING
    INTO :V_SUBJECT_NAME, :v_id_grouping_subj, :v_is_concertmaster
  DO
  BEGIN
    EXECUTE PROCEDURE cgs_add(:id_calc_group, :id_calc_pack, :V_SUBJECT_NAME, :id_grouping, :v_id_grouping_subj, NULL, :v_is_concertmaster)
    RETURNING_VALUES :v_id_cgs;
  END
END^


ALTER PROCEDURE CG_FOOTER_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    FOOTER VARCHAR(3000))
AS
BEGIN
  IF (NOT EXISTS(SELECT ID FROM CALC_GROUP WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK)) THEN
    EXCEPTION E_CALC_INDIVIDUAL_NOT_EXISTS;
  ELSE
    UPDATE CALC_GROUP
    SET FOOTER = :FOOTER
    WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CG_HEADER_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    HEADER VARCHAR(3000))
AS
BEGIN
  IF (NOT EXISTS(SELECT ID FROM CALC_GROUP WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK)) THEN
    EXCEPTION E_CALC_GROUP_NOT_EXIST;
  ELSE
    UPDATE CALC_GROUP
    SET HEADER = :HEADER
    WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CG_NAME_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50))
AS
BEGIN
  IF (NOT EXISTS(SELECT ID FROM CALC_GROUP WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK)) THEN
    EXCEPTION E_CALC_GROUP_NOT_EXIST;
  ELSE
    UPDATE CALC_GROUP
    SET NAME = :NAME
    WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CG_RECALCULATE (
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER)
AS
DECLARE VARIABLE ID_CURR_COMMON INTEGER;
DECLARE VARIABLE ID_CALC_GROUP_SUBJECT INTEGER;
DECLARE VARIABLE ID_GROUPING INTEGER;
DECLARE VARIABLE ID_GROUPING_SUBJ INTEGER;
begin
  /* Procedure Text */
--1 заполняем общее ко-во учеников по классам и категории
  --сначала всё поудаляем
  DELETE FROM CALC_GROUP_CLASS_DETAIL CG
  WHERE CG.ID_CALC_GROUP = :ID_CALC_GROUP AND CG.ID_CALC_PACK = :ID_CALC_PACK;
  --берем первый попавшийся учебный план, т.к. предпологается, что либо план один и тот же,
  --либо совпадают категории
  SELECT FIRST(1) D."CurriculumID"
  FROM CALC_GROUP_SUBJECT CGS
    INNER JOIN GROUPING_DEPT GD ON
      CGS.ID_GROUPING = GD.GROUPING_ID
    INNER JOIN "Department" D ON
      D.ID = GD.DEPARTMENT_ID
  WHERE
    CGS.ID_CALC_GROUP = :ID_CALC_GROUP AND
    CGS.ID_CALC_PACK = :ID_CALC_PACK
  INTO :ID_CURR_COMMON;

  --заполним кол-во студентов и категории
  INSERT INTO CALC_GROUP_CLASS_DETAIL (CLASS_NUMBER, ID_CALC_GROUP, ID_CALC_PACK, CATEGORY, QTY_STUDENT)
  SELECT
    CC.CLASS_NUM, :ID_CALC_GROUP, :ID_CALC_PACK, CC.CATEGORY,
    (
      SELECT COUNT(1)
      FROM V_STUDENT_CURRENT s
      WHERE s.CLASS = cc.CLASS_NUM AND s.CURRICULUMID IN (
        SELECT gs.CURR_ID
        FROM CALC_GROUP_SUBJECT CGS
          LEFT JOIN GROUPING_SUBJ_CURR_ID GS ON
            gs.GROUPING_ID = cgs.ID_GROUPING AND
            gs.GROUPING_SUBJ_ID = cgs.ID_GROUPING_SUBJ
        WHERE CGS.ID_CALC_PACK = :ID_CALC_PACK AND CGS.ID_CALC_GROUP = :ID_CALC_GROUP)
    ) QTY_STUDENT
  FROM CURR_CAT CC
  WHERE CC.CURR_ID = :ID_CURR_COMMON;

--2 заполняем детали по предметам и классам (CALC_IND_SUBJ_CLASS_DETAIL)
  --сначала удалим всё
  DELETE FROM CALC_GROUP_SUBJECT_CLASS_DETAIL
  WHERE ID_CALC_GROUP = :ID_CALC_GROUP AND ID_CALC_PACK = :ID_CALC_PACK;

  --откроем курсор по предметам
  FOR
    SELECT CGS.ID, CGS.ID_GROUPING, CGS.ID_GROUPING_SUBJ
    FROM CALC_GROUP_SUBJECT CGS
    WHERE CGS.ID_CALC_GROUP = :ID_CALC_GROUP AND CGS.ID_CALC_PACK = :ID_CALC_PACK
    INTO :ID_CALC_GROUP_SUBJECT, :ID_GROUPING, :ID_GROUPING_SUBJ
  DO
  BEGIN
    INSERT INTO CALC_GROUP_SUBJECT_CLASS_DETAIL (CLASS_NUMBER, ID_CALC_GROUP_SUBJECT, ID_CALC_GROUP, ID_CALC_PACK, CLOCK_CURR, QTY_FACT)
    SELECT
      CRT.CLASS_NUM, :ID_CALC_GROUP_SUBJECT, :ID_CALC_GROUP, :ID_CALC_PACK, CRT.C_TIME,
      (
        SELECT SUM(tg.GROUP_Q)
        FROM TEACHER_GROUP tg
        WHERE tg.GROUPING_ID = :ID_GROUPING AND tg.GR_SUBJ_ID = :ID_GROUPING_SUBJ AND tg.CLASS_NUM = CRT.CLASS_NUM
      ) QTY_FACT
    FROM CURR_REC CR
      INNER JOIN CURR_REC_TIME CRT ON
        CRT.CURR_ID = CR.CURR_ID AND
        CRT.CURR_REC_ID = CR.ID AND
        CR.RDB$DB_KEY = (
          SELECT FIRST(1) CR.RDB$DB_KEY
          FROM GROUPING_SUBJ_CURR_ID GSCI
            INNER JOIN CURR_REC CR ON
              CR.CURR_ID = GSCI.CURR_ID AND
              CR.ID = GSCI.CURR_REC_ID
          WHERE GSCI.GROUPING_ID = :ID_GROUPING AND GSCI.GROUPING_SUBJ_ID = :ID_GROUPING_SUBJ);
  END
end^


ALTER PROCEDURE CG_SHOW_POSITION_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    SHOW_POSITION INTEGER)
AS
BEGIN
  IF (NOT EXISTS(SELECT ID FROM CALC_GROUP WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK)) THEN
    EXCEPTION E_CALC_GROUP_NOT_EXIST;
  ELSE
    UPDATE CALC_GROUP
    SET SHOW_POSITION = :SHOW_POSITION
    WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CGCD_ADD (
    CLASS_NUMBER INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    CATEGORY SMALLINT,
    QTY_STUDENT SMALLINT)
AS
BEGIN
  INSERT INTO CALC_GROUP_CLASS_DETAIL (CLASS_NUMBER, ID_CALC_GROUP, ID_CALC_PACK, CATEGORY, QTY_STUDENT)
  VALUES (:CLASS_NUMBER, :ID_CALC_GROUP, :ID_CALC_PACK, :CATEGORY, :QTY_STUDENT);
END^


ALTER PROCEDURE CGCD_CATEGORY_CHANGE (
    CLASS_NUMBER INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    CATEGORY SMALLINT)
AS
BEGIN
   UPDATE CALC_GROUP_CLASS_DETAIL
   SET CATEGORY = :CATEGORY
   WHERE (CLASS_NUMBER = :CLASS_NUMBER) AND (ID_CALC_GROUP = :ID_CALC_GROUP) AND (ID_CALC_PACK = :ID_CALC_PACK);
END^


ALTER PROCEDURE CGCD_QTY_STUDENT_CHANGE (
    CLASS_NUMBER INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    QTY_STUDENT SMALLINT)
AS
BEGIN
   UPDATE CALC_GROUP_CLASS_DETAIL
   SET QTY_STUDENT = :QTY_STUDENT
   WHERE (CLASS_NUMBER = :CLASS_NUMBER) AND (ID_CALC_GROUP = :ID_CALC_GROUP) AND (ID_CALC_PACK = :ID_CALC_PACK);
END^


ALTER PROCEDURE CGS_ADD (
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50),
    ID_GROUPING INTEGER,
    ID_GROUPING_SUBJ INTEGER,
    SHOW_POSITION INTEGER,
    IS_CONCERTMASTER SMALLINT)
RETURNS (
    ID INTEGER)
AS
BEGIN
  ID = GEN_ID(GEN_CALC_GROUP_SUBJECT, 1);
  INSERT INTO CALC_GROUP_SUBJECT (ID, ID_CALC_GROUP, ID_CALC_PACK, NAME, ID_GROUPING, ID_GROUPING_SUBJ, SHOW_POSITION, IS_CONCERTMASTER)
  VALUES (:ID, :ID_CALC_GROUP, :ID_CALC_PACK, :NAME, :ID_GROUPING, :ID_GROUPING_SUBJ, :SHOW_POSITION, :IS_CONCERTMASTER);
END^


ALTER PROCEDURE CGS_DELETE (
    ID INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  DELETE FROM CALC_GROUP_SUBJECT
  WHERE ID = :ID AND ID_CALC_GROUP = :ID_CALC_GROUP AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CGS_MOVE_DOWN (
    ID INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  UPDATE CALC_GROUP_SUBJECT
  SET
    SHOW_POSITION = CASE WHEN SHOW_POSITION <> (SELECT MAX(SHOW_POSITION) FROM CALC_GROUP_SUBJECT) THEN SHOW_POSITION + 1 END
  WHERE ID = :ID AND ID_CALC_GROUP = :ID_CALC_GROUP AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CGS_MOVE_UP (
    ID INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  UPDATE CALC_GROUP_SUBJECT
  SET
    SHOW_POSITION = CASE WHEN SHOW_POSITION > 1 THEN SHOW_POSITION - 1 END
  WHERE ID = :ID AND ID_CALC_GROUP = :ID_CALC_GROUP AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CGS_NAME_CHANGE (
    ID INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50))
AS
BEGIN
  UPDATE CALC_GROUP_SUBJECT
  SET
    NAME = :NAME
  WHERE ID = :ID AND ID_CALC_GROUP = :ID_CALC_GROUP AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CGSCD_ADD (
    CLASS_NUMBER SMALLINT,
    ID_CALC_GROUP_SUBJECT INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    CLOCK_CURR DOUBLE PRECISION,
    QTY_FACT SMALLINT)
AS
BEGIN
  INSERT INTO CALC_GROUP_SUBJECT_CLASS_DETAIL (CLASS_NUMBER, ID_CALC_GROUP_SUBJECT, ID_CALC_GROUP, ID_CALC_PACK, CLOCK_CURR, QTY_FACT)
  VALUES (:CLASS_NUMBER, :ID_CALC_GROUP_SUBJECT, :ID_CALC_GROUP, :ID_CALC_PACK, :CLOCK_CURR, :QTY_FACT);
END^


ALTER PROCEDURE CGSCD_CLOCK_CURR (
    CLASS_NUMBER SMALLINT,
    ID_CALC_GROUP_SUBJECT INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    CLOCK_CURR DOUBLE PRECISION)
AS
BEGIN
  UPDATE CALC_GROUP_SUBJECT_CLASS_DETAIL
  SET CLOCK_CURR = :CLOCK_CURR
  WHERE (CLASS_NUMBER = :CLASS_NUMBER) AND (ID_CALC_GROUP_SUBJECT = :ID_CALC_GROUP_SUBJECT) AND (ID_CALC_GROUP = :ID_CALC_GROUP) AND (ID_CALC_PACK = :ID_CALC_PACK);
END^


ALTER PROCEDURE CGSCD_CLOCK_CURR_CHANGE (
    CLASS_NUMBER SMALLINT,
    ID_CALC_GROUP_SUBJECT INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    CLOCK_CURR DOUBLE PRECISION)
AS
BEGIN
  UPDATE CALC_GROUP_SUBJECT_CLASS_DETAIL
  SET CLOCK_CURR = :CLOCK_CURR
  WHERE (CLASS_NUMBER = :CLASS_NUMBER) AND (ID_CALC_GROUP_SUBJECT = :ID_CALC_GROUP_SUBJECT) AND (ID_CALC_GROUP = :ID_CALC_GROUP) AND (ID_CALC_PACK = :ID_CALC_PACK);
END^


ALTER PROCEDURE CGSCD_DELETE (
    CLASS_NUMBER SMALLINT,
    ID_CALC_GROUP_SUBJECT INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  DELETE FROM CALC_GROUP_SUBJECT_CLASS_DETAIL
  WHERE (CLASS_NUMBER = :CLASS_NUMBER) AND (ID_CALC_GROUP_SUBJECT = :ID_CALC_GROUP_SUBJECT) AND (ID_CALC_GROUP = :ID_CALC_GROUP) AND (ID_CALC_PACK = :ID_CALC_PACK);
END^


ALTER PROCEDURE CGSCD_QTY_FACT_CHANGE (
    CLASS_NUMBER SMALLINT,
    ID_CALC_GROUP_SUBJECT INTEGER,
    ID_CALC_GROUP INTEGER,
    ID_CALC_PACK INTEGER,
    QTY_FACT SMALLINT)
AS
BEGIN
  UPDATE CALC_GROUP_SUBJECT_CLASS_DETAIL
  SET QTY_FACT = :QTY_FACT
  WHERE (CLASS_NUMBER = :CLASS_NUMBER) AND (ID_CALC_GROUP_SUBJECT = :ID_CALC_GROUP_SUBJECT) AND (ID_CALC_GROUP = :ID_CALC_GROUP) AND (ID_CALC_PACK = :ID_CALC_PACK);
END^


ALTER PROCEDURE CHANGE_CONSTANTS (
    IN_YTCOEF DOUBLE PRECISION,
    IN_OTCOEF DOUBLE PRECISION,
    IN_CTCOEF DOUBLE PRECISION,
    IN_PASPORT_CODE VARCHAR(50),
    IN_PASPORT_NAME VARCHAR(256),
    IN_DIRECTOR_SIGN VARCHAR(256),
    IN_TARIFFICATION_SIGN VARCHAR(3000),
    IN_TAB_SIGN VARCHAR(3000))
AS
begin
  update constants c set
    ytcoef = :in_ytcoef,
    otcoef = :in_otcoef,
    ctcoef = :in_ctcoef,
    pasport_code = :in_pasport_code,
    pasport_name = :in_pasport_name,
    pasport_director_sign = :in_director_sign,
    pasport_tariffication_sign = :in_tariffication_sign,
    pasport_tab_sign = :in_tab_sign;
end^


ALTER PROCEDURE CHANGE_SYS_DATE (
    IN_DATE DATE)
AS
begin
  update constants set SYSTEM_DATE = :in_date;
end^


ALTER PROCEDURE CHECK_ORDERED (
    P_TABLE_NAME VARCHAR(150),
    P_ORDER_BY VARCHAR(1000))
AS
declare variable v_pos_pre integer;
declare variable v_pos integer;
declare variable v_id integer;
declare variable v_order_by varchar(1000);
begin
  -- v_order_by = p_order_by || case when p_order_by is not null then ',' end || ' pos';
  if (p_order_by is null) then
    v_order_by = 'pos';
  else
    v_order_by = p_order_by || ',' || ' pos';
  -- начинаем с позиции 1
  v_pos_pre = 0;
  for
    execute statement
      'select id, pos from ' || p_table_name ||
      ' order by ' || v_order_by
    into :v_id, :v_pos
  do
  begin
    -- если текущая позиция не определена, или не по порядку, апдейтим
    if (v_pos is null or v_pos_pre + 1 <> v_pos) then
    begin
      v_pos = v_pos_pre + 1;
      execute statement 'update ' || p_table_name ||
        ' set pos = ' || :v_pos ||
        ' where id = ' || :v_id;
    end
    v_pos_pre = v_pos_pre + 1;
  end
end^


ALTER PROCEDURE CI_ADD (
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50),
    HEADER VARCHAR(3000),
    FOOTER VARCHAR(3000),
    SHOW_POSITION INTEGER)
RETURNS (
    OUT_ID INTEGER)
AS
BEGIN
  OUT_ID = GEN_ID(GEN_CALC_INDIVIDUAL, 1);
  INSERT INTO CALC_INDIVIDUAL (ID, ID_CALC_PACK, NAME, HEADER, FOOTER, SHOW_POSITION)
  VALUES (:OUT_ID, :ID_CALC_PACK, :NAME, :HEADER, :FOOTER, :SHOW_POSITION);
END^


ALTER PROCEDURE CI_DELETE (
    ID INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  DELETE FROM CALC_INDIVIDUAL
  WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CI_FILL_FROM_CURR_DEPT (
    ID_CALC_PACK INTEGER,
    ID_CURRICULUM INTEGER)
AS
DECLARE VARIABLE v_id_department INTEGER;
DECLARE VARIABLE v_id_calc_individual INTEGER;
DECLARE VARIABLE v_name_department VARCHAR(50) CHARACTER SET win1251;
BEGIN
  FOR
    SELECT d.id, d."Name"
    FROM curriculum c
      INNER JOIN "Department" d ON
        d."CurriculumID" = c.id
    WHERE c.id = :id_curriculum
    INTO :v_id_department, :v_name_department
  DO
  BEGIN
    EXECUTE PROCEDURE ci_add(:id_calc_pack, :v_name_department, '', '', null)
    RETURNING_VALUES :v_id_calc_individual;
    EXECUTE PROCEDURE ci_fill_from_dept(:id_calc_pack, :v_id_calc_individual, :v_id_department);
  END
END^


ALTER PROCEDURE CI_FILL_FROM_DEPT (
    ID_CALC_PACK INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_DEPARTMENT INTEGER)
AS
DECLARE VARIABLE V_ID INTEGER;
DECLARE VARIABLE V_SUBJECT_NAME VARCHAR(50);
DECLARE VARIABLE V_ID_CURR_REC INTEGER;
DECLARE VARIABLE V_IS_CONCERTMASTER INTEGER;
BEGIN
  
  DELETE FROM calc_individual_subject cis
  WHERE cis.id_calc_pack = :id_calc_pack AND cis.id_calc_individual = :id_calc_individual;

  FOR
    SELECT s."Name", cr.id, s."Code"
    FROM "Department" d
      INNER JOIN curr_rec CR ON
        d."CurriculumID" = cr.curr_id
      INNER JOIN "Subject" s ON
        s.id = cr.subject_id
    WHERE d.id = :id_department AND cr.GROUP_QTY = 1
    ORDER BY cr.NUM
    INTO :v_subject_name, :v_id_curr_rec, :v_is_concertmaster
  DO
  BEGIN
    EXECUTE PROCEDURE cis_add(:id_calc_individual, :id_calc_pack,  :v_subject_name, :id_department, :v_id_curr_rec, null, :v_is_concertmaster)
    RETURNING_VALUES :v_id;
  END
END^


ALTER PROCEDURE CI_FOOTER_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    FOOTER VARCHAR(3000))
AS
BEGIN
  IF (NOT EXISTS(SELECT ID FROM CALC_INDIVIDUAL WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK)) THEN
    EXCEPTION E_CALC_INDIVIDUAL_NOT_EXISTS;
  ELSE
    UPDATE CALC_INDIVIDUAL
    SET FOOTER = :FOOTER
    WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CI_HEADER_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    HEADER VARCHAR(3000))
AS
BEGIN
  IF (NOT EXISTS(SELECT ID FROM CALC_INDIVIDUAL WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK)) THEN
    EXCEPTION E_CALC_INDIVIDUAL_NOT_EXISTS;
  ELSE
    UPDATE CALC_INDIVIDUAL
    SET HEADER = :HEADER
    WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CI_NAME_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50))
AS
BEGIN
  IF (NOT EXISTS(SELECT ID FROM CALC_INDIVIDUAL WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK)) THEN
    EXCEPTION E_CALC_INDIVIDUAL_NOT_EXISTS;
  ELSE
    UPDATE CALC_INDIVIDUAL
    SET NAME = :NAME
    WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CI_RECALCULATE (
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER)
AS
DECLARE VARIABLE ID_DEP_COMMON INTEGER;
DECLARE VARIABLE ID_CALC_INDIVIDUAL_SUBJECT INTEGER;
DECLARE VARIABLE ID_DEPARTMENT INTEGER;
DECLARE VARIABLE ID_CURR_REC INTEGER;
DECLARE VARIABLE ID_CURRICULUM INTEGER;
BEGIN
  /* Procedure Text */
--1 заполняем общее ко-во учеников по классам и категории (CALC_INDIVIDUAL_CLASS_DETAIL)
  DELETE FROM CALC_INDIVIDUAL_CLASS_DETAIL CI
  WHERE CI.ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL AND CI.ID_CALC_PACK = :ID_CALC_PACK;
  --берем первый попавшийся учебный план, т.к. предпологается, что либо план один и тот же,
  --либо совпадают категории
  SELECT FIRST(1) CIS.ID_DEPARTMENT FROM CALC_INDIVIDUAL_SUBJECT CIS
  WHERE
    CIS.ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL AND
    CIS.ID_CALC_PACK = :ID_CALC_PACK
  INTO :ID_DEP_COMMON;

  INSERT INTO CALC_INDIVIDUAL_CLASS_DETAIL (CLASS_NUMBER, ID_CALC_INDIVIDUAL, ID_CALC_PACK, CATEGORY, QTY_STUDENT)
  SELECT
    cc.CLASS_NUM, :ID_CALC_INDIVIDUAL, :ID_CALC_PACK, cc.CATEGORY,
    (
      SELECT COUNT(1)
      FROM V_STUDENT_CURRENT sc
      WHERE sc.DEPARTMENTID = d.ID AND sc.CLASS = cc.CLASS_NUM
    ) QTY_STUDENT
  FROM "Department" d
    INNER JOIN CURR_CAT cc ON
      d."CurriculumID" = cc.CURR_ID
  WHERE d.ID = :ID_DEP_COMMON;
--2 заполняем детали по предметам и классам (CALC_IND_SUBJ_CLASS_DETAIL)
  DELETE FROM CALC_IND_SUBJ_CLASS_DETAIL
  WHERE ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL AND ID_CALC_PACK = :ID_CALC_PACK;

  --откроем курсор по предметам
  FOR
    SELECT CIS.ID, CIS.ID_DEPARTMENT, CIS.ID_CURR_REC, CIS.ID_CURRICULUM
    FROM CALC_INDIVIDUAL_SUBJECT CIS
    WHERE CIS.ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL AND CIS.ID_CALC_PACK = :ID_CALC_PACK
    INTO :ID_CALC_INDIVIDUAL_SUBJECT, :ID_DEPARTMENT, :ID_CURR_REC, :ID_CURRICULUM
  DO
  BEGIN
    INSERT INTO CALC_IND_SUBJ_CLASS_DETAIL (CLASS_NUMBER, ID_CALC_INDIVIDUAL_SUBJECT, ID_CALC_INDIVIDUAL, ID_CALC_PACK, CLOCK_CURRICULUM, QTY_FACT)
    SELECT crt.CLASS_NUM, :ID_CALC_INDIVIDUAL_SUBJECT, :ID_CALC_INDIVIDUAL, :ID_CALC_PACK, crt.C_TIME,
      (
        SELECT COUNT(1)
        FROM  VIEW_STUDENT_PLAN VSP
          INNER JOIN V_STUDENT_CURRENT S ON
            S.ID = VSP.STUDENT_ID AND
            VSP.USE = 1 AND
            S.DEPARTMENTID = :ID_DEPARTMENT AND
            VSP.CURR_ID = :ID_CURRICULUM AND
            VSP.ID = :ID_CURR_REC AND
            s.CLASS = crt.CLASS_NUM
      ) QTY_FACT
    FROM CURR_REC cr
      INNER JOIN CURR_REC_TIME crt ON
        cr.CURR_ID = :ID_CURRICULUM AND
        cr.ID = :ID_CURR_REC AND
        crt.CURR_ID = cr.CURR_ID AND
        crt.CURR_REC_ID = cr.ID;
  END
END^


ALTER PROCEDURE CI_SHOW_POSITION_CHANGE (
    ID INTEGER,
    ID_CALC_PACK INTEGER,
    SHOW_POSITION INTEGER)
AS
BEGIN
  IF (NOT EXISTS(SELECT ID FROM CALC_INDIVIDUAL WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK)) THEN
    EXCEPTION E_CALC_INDIVIDUAL_NOT_EXISTS;
  ELSE
    UPDATE CALC_INDIVIDUAL
    SET SHOW_POSITION = :SHOW_POSITION
    WHERE ID = :ID AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CICD_ADD (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    CATEGORY SMALLINT,
    QTY_STUDENT SMALLINT)
AS
BEGIN
  INSERT INTO CALC_INDIVIDUAL_CLASS_DETAIL (CLASS_NUMBER, ID_CALC_INDIVIDUAL, ID_CALC_PACK, CATEGORY, QTY_STUDENT)
  VALUES (:CLASS_NUMBER, :ID_CALC_INDIVIDUAL, :ID_CALC_PACK, :CATEGORY, :QTY_STUDENT);
END^


ALTER PROCEDURE CICD_CATEGORY_CHANGE (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    CATEGORY SMALLINT)
AS
BEGIN
  UPDATE CALC_INDIVIDUAL_CLASS_DETAIL
  SET
    CATEGORY = :CATEGORY
  WHERE CLASS_NUMBER = :CLASS_NUMBER AND ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CICD_DELETE (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  DELETE FROM CALC_INDIVIDUAL_CLASS_DETAIL
  WHERE
    CLASS_NUMBER = :CLASS_NUMBER AND
    ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL AND
    ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CICD_QTY_STUDENT_CHANGE (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    QTY_STUDENT SMALLINT)
AS
BEGIN
  UPDATE CALC_INDIVIDUAL_CLASS_DETAIL
  SET
    QTY_STUDENT = :QTY_STUDENT
  WHERE CLASS_NUMBER = :CLASS_NUMBER AND ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CIS_ADD (
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50),
    ID_DEPARTMENT INTEGER,
    ID_CURR_REC INTEGER,
    SHOW_POSITION INTEGER,
    IS_CONCERTMASTER SMALLINT)
RETURNS (
    ID INTEGER)
AS
BEGIN
  ID = GEN_ID(GEN_CALC_INDIVIDUAL_SUBJECT, 1);
  INSERT INTO CALC_INDIVIDUAL_SUBJECT (ID, ID_CALC_INDIVIDUAL, ID_CALC_PACK, NAME, ID_DEPARTMENT, ID_CURR_REC, ID_CURRICULUM, SHOW_POSITION, IS_CONCERTMASTER)
  VALUES (:ID, :ID_CALC_INDIVIDUAL, :ID_CALC_PACK, :NAME, :ID_DEPARTMENT, :ID_CURR_REC, NULL, :SHOW_POSITION, :IS_CONCERTMASTER);
END^


ALTER PROCEDURE CIS_DELETE (
    ID INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  DELETE FROM CALC_INDIVIDUAL_SUBJECT
  WHERE ID = :ID AND ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CIS_MOVE_DOWN (
    ID INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  UPDATE CALC_INDIVIDUAL_SUBJECT
  SET
    SHOW_POSITION = CASE WHEN SHOW_POSITION <> (SELECT MAX(SHOW_POSITION) FROM CALC_INDIVIDUAL_SUBJECT) THEN SHOW_POSITION + 1 END
  WHERE ID = :ID AND ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CIS_MOVE_UP (
    ID INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER)
AS
BEGIN
  UPDATE CALC_INDIVIDUAL_SUBJECT
  SET
    SHOW_POSITION = CASE WHEN SHOW_POSITION > 1 THEN SHOW_POSITION - 1 END
  WHERE ID = :ID AND ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CIS_NAME_CHANGE (
    ID INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    NAME VARCHAR(50))
AS
BEGIN
  UPDATE CALC_INDIVIDUAL_SUBJECT
  SET
    NAME = :NAME
  WHERE ID = :ID AND ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL AND ID_CALC_PACK = :ID_CALC_PACK;
END^


ALTER PROCEDURE CISCD_ADD (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL_SUBJECT INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    CLOCK_CURRICULUM DOUBLE PRECISION,
    QTY_FACT SMALLINT)
AS
BEGIN
  INSERT INTO CALC_IND_SUBJ_CLASS_DETAIL (CLASS_NUMBER, ID_CALC_INDIVIDUAL_SUBJECT, ID_CALC_INDIVIDUAL, ID_CALC_PACK, CLOCK_CURRICULUM, QTY_FACT)
  VALUES (:CLASS_NUMBER, :ID_CALC_INDIVIDUAL_SUBJECT, :ID_CALC_INDIVIDUAL, :ID_CALC_PACK, :CLOCK_CURRICULUM, :QTY_FACT);
END^


ALTER PROCEDURE CISCD_CLOCK_CURR_CHANGE (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL_SUBJECT INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    CLOCK_CURRICULUM DOUBLE PRECISION)
AS
BEGIN
  UPDATE CALC_IND_SUBJ_CLASS_DETAIL
  SET CLOCK_CURRICULUM = :CLOCK_CURRICULUM
  WHERE (CLASS_NUMBER = :CLASS_NUMBER) AND (ID_CALC_INDIVIDUAL_SUBJECT = :ID_CALC_INDIVIDUAL_SUBJECT) AND (ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL) AND (ID_CALC_PACK = :ID_CALC_PACK);
END^


ALTER PROCEDURE CISCD_DELETE (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL_SUBJECT INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    CLOCK_CURRICULUM DOUBLE PRECISION,
    QTY_FACT SMALLINT)
AS
BEGIN
  DELETE FROM CALC_IND_SUBJ_CLASS_DETAIL
  WHERE (CLASS_NUMBER = :CLASS_NUMBER) AND (ID_CALC_INDIVIDUAL_SUBJECT = :ID_CALC_INDIVIDUAL_SUBJECT) AND (ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL) AND (ID_CALC_PACK = :ID_CALC_PACK);
END^


ALTER PROCEDURE CISCD_QTY_FACT_CHANGE (
    CLASS_NUMBER INTEGER,
    ID_CALC_INDIVIDUAL_SUBJECT INTEGER,
    ID_CALC_INDIVIDUAL INTEGER,
    ID_CALC_PACK INTEGER,
    QTY_FACT SMALLINT)
AS
BEGIN
  UPDATE CALC_IND_SUBJ_CLASS_DETAIL
  SET QTY_FACT = :QTY_FACT
  WHERE (CLASS_NUMBER = :CLASS_NUMBER) AND (ID_CALC_INDIVIDUAL_SUBJECT = :ID_CALC_INDIVIDUAL_SUBJECT) AND (ID_CALC_INDIVIDUAL = :ID_CALC_INDIVIDUAL) AND (ID_CALC_PACK = :ID_CALC_PACK);
END^


ALTER PROCEDURE CLEAR_STUDENT_FILTER_SPEC (
    ID_FILTER INTEGER)
AS
begin
  IF (EXISTS (SELECT * FROM STUDENT_FILTER WHERE ID = :ID_FILTER)) THEN
  BEGIN
    DELETE FROM STUDENT_FILTER_SPEC WHERE ID_FILTER = :ID_FILTER;
  END
  ELSE
    EXCEPTION E_STUDENT_FILTER_SPEC;
end^


ALTER PROCEDURE CONST_ADD (
    P_CODE VARCHAR(150),
    P_NAME VARCHAR(150),
    P_TYPE INTEGER)
RETURNS (
    P_ID INTEGER)
AS
  declare variable v_id integer;
begin
  select c.id
  from const c
  where c.f_code = :p_code
  into p_id;

  if (p_id is null) then
  begin
    p_id = gen_id(gen_common, 1);
    insert into const(id, f_code, f_name, f_type) values (:p_id, :p_code, :p_name, :p_type);
  end
end^


ALTER PROCEDURE CONST_FLOAT_SET (
    P_CODE VARCHAR(150),
    P_VALUE DOUBLE PRECISION)
AS
declare variable v_id integer;
declare variable v_cnt integer;
begin
  select
    c.id,
    (select count(*) from const_float cf where cf.f_const_id = c.id) cnt
  from const c
    left join const_float cf on cf.f_const_id = c.id
  where c.f_code = :p_code
  into v_id, v_cnt;

  if (v_id is not null) then
  begin
    if (v_cnt > 0) then
    begin
      update const_float
      set
        f_value = :p_value
      where f_const_id = :v_id;
    end
    else
    begin
      insert into const_float (f_const_id, f_value)
      values (:v_id, :p_value);
    end
  end
end^


ALTER PROCEDURE CP_ADD_EDIT (
    ID INTEGER,
    NAME VARCHAR(50))
RETURNS (
    OUT_ID INTEGER)
AS
BEGIN
  IF (ID IS NOT NULL) THEN
  BEGIN
    IF (NOT EXISTS(SELECT ID FROM CALC_PACK WHERE (ID = :ID))) THEN
      EXCEPTION E_CALC_PACK_NOT_EXIST;
    UPDATE CALC_PACK
    SET NAME = :NAME
    WHERE (ID = :ID);
  END
  ELSE
  BEGIN
    ID = GEN_ID(GEN_CALC_PACK, 1);
    INSERT INTO CALC_PACK (ID, NAME)
    VALUES (:ID, :NAME);
  END
  OUT_ID = ID;
END^


ALTER PROCEDURE CP_DELETE (
    ID INTEGER)
AS
begin
  DELETE FROM CALC_PACK CP WHERE CP.ID = :ID;
end^


ALTER PROCEDURE DELETE_CURRICULUM (
    ID INTEGER)
AS
begin
  delete from curriculum where ID=:ID;
end^


ALTER PROCEDURE DELETE_CURRICULUM_RECORD (
    INID INTEGER,
    INCURRID INTEGER)
AS
declare variable num id_type;
begin
  select cr.num
  from curr_rec cr
  where cr.id = :inId and curr_id = :inCurrId
  into num;

  update curr_rec cr
  set cr.num = cr.num - 1
  where cr.curr_id = :inCurrId and cr.num > :num;

  delete from curr_rec
  where id = :inId
    and curr_id = :inCurrId;

end^


ALTER PROCEDURE DELETE_DEPARTMENT (
    INID INTEGER)
AS
BEGIN
    DELETE FROM "Department" WHERE "ID"=:INID;
END^


ALTER PROCEDURE DELETE_EDUCATION (
    INID INTEGER)
AS
BEGIN
    DELETE FROM "Education" WHERE "ID"=:INID;
END^


ALTER PROCEDURE DELETE_FILIAL (
    INID INTEGER)
AS
BEGIN
    DELETE FROM "Filial" WHERE "ID" =: INID;
END^


ALTER PROCEDURE DELETE_GROUPING (
    IN_ID INTEGER)
AS
begin
  /* Procedure Text */
  delete from grouping where id=:in_id;
end^


ALTER PROCEDURE DELETE_GROUPING_DEPT (
    IN_GROUPING_ID INTEGER,
    IN_DEPT_ID INTEGER)
AS
DECLARE VARIABLE TMP INTEGER;
begin
  /* Procedure Text */
  select G.grouping_id from grouping_dept G
  where G.grouping_id = :in_grouping_id and G.department_id = :in_dept_id
  into :tmp;
  if (:tmp is not null) then
    delete from grouping_dept G
    where G.grouping_id = :in_grouping_id and G.department_id = :in_dept_id;
end^


ALTER PROCEDURE DELETE_POST (
    INID INTEGER)
AS
BEGIN
    DELETE FROM "Post" WHERE "ID"=:INID;
END^


ALTER PROCEDURE DELETE_REP_TAB_EXT (
    IN_REC_TIME TIMESTAMP)
AS
begin
  delete from rep_tab_ext rte where rte.rec_time = :in_rec_time;
end^


ALTER PROCEDURE DELETE_REP_TAB_EXT_2 (
    IN_REC_TIME TIMESTAMP)
AS
begin
  delete from rep_tab_ext_2 rte where rte.rec_time = :in_rec_time;
end^


ALTER PROCEDURE DELETE_SPECIALIZATION (
    INID INTEGER)
AS
BEGIN
    DELETE FROM "Specialization" WHERE "ID"=:INID;
END^


ALTER PROCEDURE DELETE_STUDENT_PLAN (
    IN_CURR_REC_ID INTEGER,
    INSTUDENTID INTEGER)
AS
BEGIN
    DELETE FROM "Student_Plan" WHERE (curr_rec_id=:IN_curr_rec_ID) and ("StudentID"=:InStudentID);
END^


ALTER PROCEDURE DELETE_SUBJECT (
    INID INTEGER)
AS
BEGIN
    DELETE FROM "Subject" WHERE "ID" =: INID;
END^


ALTER PROCEDURE DELETE_TARIFF (
    INGRADE INTEGER)
AS
begin
   delete from "Tariff" where "Grade"=:InGrade;
end^


ALTER PROCEDURE DELETE_TARIFFICATION (
    IN_DATE TIMESTAMP)
AS
begin
  delete from tariffication  T
  where T.doc_date = :in_date;
end^


ALTER PROCEDURE DELETE_TEACHER (
    INID INTEGER)
AS
BEGIN
    DELETE FROM "Teacher" WHERE "ID"=:INID;
END^


ALTER PROCEDURE DELETE_TEACHER_ADDING (
    INID INTEGER)
AS
BEGIN
    DELETE FROM "Teacher_Addings" WHERE "ID"=:INID;
END^


ALTER PROCEDURE EDIT_MAIN_TAB (
    T_ID INTEGER,
    B_Y_TIME DOUBLE PRECISION,
    B_O_TIME DOUBLE PRECISION,
    B_C_TIME DOUBLE PRECISION,
    COMMENTS VARCHAR(256),
    SWP_Y_TIME DOUBLE PRECISION,
    SWP_O_TIME DOUBLE PRECISION,
    SWP_C_TIME DOUBLE PRECISION)
AS
declare variable TMP integer;
begin
  select MT.teacher_id
  from main_tab MT
  where MT.teacher_id = :t_id
  into :tmp;
  if (:tmp is not null) then
  begin
    update main_tab MT set
      MT.b_y_time = nullif(:b_y_time, 0),
      MT.b_o_time = nullif(:b_o_time, 0),
      MT.b_c_time = nullif(:b_c_time, 0),
      MT.comments = :comments,
      MT.swp_y_time = nullif(:swp_y_time, 0),
      MT.swp_o_time = nullif(:swp_o_time, 0),
      MT.swp_c_time = nullif(:swp_c_time, 0)
    where MT.teacher_id = :t_id;
  end
end^


ALTER PROCEDURE FILTRED_STUDENT (
    ID_FILTER INTEGER)
RETURNS (
    ID INTEGER)
AS
begin

  IF (:id_filter IS NULL) THEN
  BEGIN
    FOR SELECT ID FROM "Student" INTO :ID DO SUSPEND;
  END
  ELSE
  BEGIN
    IF (EXISTS (SELECT * FROM STUDENT_FILTER_SPEC WHERE ID_FILTER = :ID)) THEN
      FOR
        SELECT S.ID
        FROM "Student" S
          LEFT JOIN "Specialization" SPEC ON SPEC.ID = S."SpecializationID"
          LEFT JOIN "Department" D ON D.ID = SPEC."DepartmentID"
          LEFT JOIN CURRICULUM C ON C.ID = D."CurriculumID"
          LEFT JOIN CURR_CAT CC ON
            CC.CURR_ID = C.ID AND
            S."Class" = CC.CLASS_NUM
          LEFT JOIN "Student_Plan" SP1 ON
            SP1."StudentID" = S.ID
          LEFT JOIN CURR_REC CR1 ON
            CR1.CURR_ID = C.ID AND
            CR1.ID = SP1.CURR_REC_ID
          LEFT JOIN "Student_Plan" SP2 ON
            SP2."StudentID" = S.ID
          LEFT JOIN CURR_REC CR2 ON
            CR2.CURR_ID = C.ID AND
            SP2.CURR_REC_ID = CR2.CURR_ID
          INNER JOIN student_filter SF ON
            SF.ID = :ID_FILTER
          LEFT JOIN student_filter_spec SFS ON
            SFS.ID_FILTER = :ID_FILTER
        WHERE
          (SFS.ID_FILTER IS NULL OR (SFS.ID_SPECIALIZATION = S."SpecializationID")) AND
          (SF.FILIAL_ID IS NULL OR (SF.FILIAL_ID = S."FilialID")) AND
          (SF.CLASS_B IS NULL OR (S."Class" >= SF.CLASS_B)) AND
          (SF.CLASS_E IS NULL OR (S."Class" <= SF.CLASS_E)) AND
          (SF.CURATOR_ID IS NULL OR (SF.CURATOR_ID = S."MasterID")) AND
          (SF.CATEGORY IS NULL OR (CC.CATEGORY = SF.CATEGORY)) AND
          (SF.PERIOD IS NULL OR (C.PERIOD = SF.PERIOD)) AND
          (SF.STATUS IS NULL OR (
            SF.STATUS =
              CASE
                WHEN S.RELEASED > 0 THEN 0
                WHEN S.ACADEMY > 0 THEN 1
                ELSE 2
              END
            )
          )  AND
          (SF.PAY_PERCENT IS NULL OR (
            SF.PAY_PERCENT =
              CASE
                WHEN S."Percent" = 100 THEN 1 --полная
                WHEN S."Percent" < 100 THEN 2 --льготная
              END
            )
          ) AND
          (SF.AGE_B IS NULL OR
            (SF.AGE_B >=
              EXTRACT(YEAR FROM CURRENT_DATE) - EXTRACT(YEAR FROM S."BirthDate")
            )
          ) AND
          (SF.AGE_E IS NULL OR
            (SF.AGE_E <= EXTRACT(YEAR FROM S."BirthDate"))) AND
          (SF.ENTER_D_B IS NULL OR (SF.ENTER_D_B >= S."EnterDate")) AND
          (SF.ENTER_D_E IS NULL OR (SF.ENTER_D_E <= S."EnterDate")) AND
          (SF.RELEASE_D_B IS NULL OR (SF.RELEASE_D_B >= S."ReleaseDate")) AND
          (SF.RELEASE_D_E IS NULL OR (SF.RELEASE_D_E <= S."ReleaseDate")) AND
          (SF.RESTORE_D_B IS NULL OR (SF.RESTORE_D_B >= S."ReleaseDate")) AND
          (SF.RESTORE_D_E IS NULL OR (SF.RESTORE_D_E <= S."RestoreDate")) AND
          (SF.ACADEMY_D_B IS NULL OR (SF.ACADEMY_D_B >= S."AcademyBDate")) AND
          (SF.ACADEMY_D_E IS NULL OR (SF.ACADEMY_D_E <= S."AcademyEDate"))  AND
          (SF.SUBJECT_ID_1 IS NULL OR (SF.SUBJECT_ID_1 = CR1.SUBJECT_ID AND
            (SF.SUBJ_STATE IS NULL OR SF.SUBJ_STATE = SP1."Use"))) AND
          (SF.TEACHER_ID_1 IS NULL OR (SF.TEACHER_ID_1 = SP1."TeacherID" AND
            (SF.SUBJ_STATE IS NULL OR SF.SUBJ_STATE = SP1."Use"))) AND
          (SF.SUBJECT_ID_2 IS NULL OR (SF.SUBJECT_ID_2 = CR2.SUBJECT_ID AND
            (SF.SUBJ_STATE IS NULL OR SF.SUBJ_STATE = SP2."Use"))) AND
          (SF.TEACHER_ID_2 IS NULL OR (SF.TEACHER_ID_2 = SP1."TeacherID" AND
            (SF.SUBJ_STATE IS NULL OR SF.SUBJ_STATE = SP1."Use"))) AND
          (SF.FINANCING_ID IS NULL OR (SF.FINANCING_ID = S."FinancingID")) AND
          (SF.f_id_sex IS NULL OR (SF.f_id_sex = S.f_id_sex))
      INTO :ID
    DO SUSPEND;
  END

  /* Procedure Text */
  suspend;
end^


ALTER PROCEDURE GET_CURR_STAGE (
    STAGE_ON_DATE DATE,
    STAGE_Y SMALLINT,
    STAGE_M SMALLINT,
    STAGE_D SMALLINT)
RETURNS (
    CURR_STAGE_Y SMALLINT,
    CURR_STAGE_M SMALLINT,
    CURR_STAGE_D SMALLINT)
AS
  declare variable v_curr_date  date;
  declare variable v_start_date date;
begin
  v_start_date = cast(addday(addyear(addmonth(:stage_on_date, -coalesce(:stage_m, 0)), -coalesce(:stage_y, 0)), -coalesce(:stage_d, 0)) as date);
  v_curr_date  = cast(current_date as date);
  curr_stage_m = mod(datediff(month, v_start_date, v_curr_date), 12);
  curr_stage_y = datediff(year, v_start_date, v_curr_date);
  suspend;
end^


ALTER PROCEDURE GET_CURRS_STUDENTS_QTY (
    CURR_REC_ID INTEGER,
    FINANCING_ID INTEGER,
    CURR_ID INTEGER)
RETURNS (
    Q0 INTEGER,
    Q1 INTEGER,
    Q2 INTEGER,
    Q3 INTEGER,
    Q4 INTEGER,
    Q5 INTEGER,
    Q6 INTEGER,
    Q7 INTEGER,
    Q8 INTEGER,
    OSUM INTEGER,
    OVSUM INTEGER,
    YVSUM INTEGER)
AS
begin
select sum(case S."Class" when 0 then 1 else 0 end) C0,
       sum(case S."Class" when 1 then 1 else 0 end) C1,
       sum(case S."Class" when 2 then 1 else 0 end) C2,
       sum(case S."Class" when 3 then 1 else 0 end) C3,
       sum(case S."Class" when 4 then 1 else 0 end) C4,
       sum(case S."Class" when 5 then 1 else 0 end) C5,
       sum(case S."Class" when 6 then 1 else 0 end) C6,
       sum(case S."Class" when 7 then 1 else 0 end) C7,
       sum(case S."Class" when 8 then 1 else 0 end) C8,
       sum(CC.category) OSum,

       sum((case STP."TeacherID" when 0 then 1 end)*CC.category) OVSum,

       sum((case STP."TeacherID" when 0 then 1 end)*mod(CC.category + 1, 2)) YVSum
from "Student" S
  join "Student_Plan" STP on S.id = STP."StudentID" and STP."Use" > 0
    and S.released = 0 and S.academy = 0
    and STP.curr_rec_id = :curr_rec_id and S."FinancingID" = :financing_id
  join "Specialization" SP on SP.ID = S."SpecializationID"
  join "Department" D on D.id = SP."DepartmentID"
  join curriculum C on C.id = D."CurriculumID" and C.id = :curr_id
  join curr_cat CC on CC.curr_id = :curr_id and CC.class_num = S."Class"
  into :Q0, :Q1, :Q2, :Q3, :Q4, :Q5, :Q6, :Q7, :Q8, :OSUM, :ovsum, :yvsum;
  suspend;
end^


ALTER PROCEDURE GET_FILTERED_TEACHERS (
    FILTER_ID INTEGER)
RETURNS (
    TEACHER_ID INTEGER)
AS
begin
  for
    select t.id
    from v_teacher t
      left join teacher_filter tf on tf.id = :filter_id
      cross join constants     c
    where :filter_id is null -- фильтр выключен
      or
      -- фильтр включен
      (tf.main_subj_id    is null or t."SubjectID"     = tf.main_subj_id)
      and (tf.main_grade      is null or tf.main_grade     = t."GradeID")
      and (tf.conc_grade      is null or tf.conc_grade     = t."ConcertGradeID")
      and (tf.post_id         is null or ',' || tf.post_id || ',' like '%,' || t."PostID" || ',%')
      and (tf.education_id    is null
        or ',' || tf.education_id || ',' like
          '%,' || minvalue(coalesce(t."EducationID", 77777), coalesce(t.education_2_id, 77777)) || ',%'

      )
      and (tf.filial_id       is null or tf.filial_id      = t."FilialID")
      and (tf.state           is null or tf.state          = 0
                                      or tf.state          = 1 and t."ReleaseDate" is null     -- работающие
                                      or tf.state          = 2 and t."ReleaseDate" is not null -- уволенные
      )
      -- фильтр по стажу
      -- начало стажа
      and (tf.stage_b         is null and tf.stage_b_m is null
        or coalesce(tf.stage_b * 12, 0) + coalesce(tf.stage_b_m, 0)  <=
           ( cast(c.system_date as date)
             -
             cast(addyear(addmonth(t."StageDate", -coalesce(t.stage_m, 0)), -coalesce(t.stage_y, 0)) as date)
             +
             coalesce(t.stage_d, 0)
           ) / 30
      )
      -- окончание стажа
      and (tf.stage_e         is null and tf.stage_e_m is null
        or coalesce(tf.stage_e * 12, 0) + coalesce(tf.stage_e_m, 0) >=
          ( cast(c.system_date as date)
            -
            cast(addyear(addmonth(t."StageDate", -coalesce(t.stage_m, 0)), -coalesce(t.stage_y, 0)) as date)
            +
            coalesce(t.stage_d, 0)
          ) / 30
      )
      -- по дате рождения
      and (tf.birth_d_b       is null or tf.birth_d_b <= t."BirthDate")
      and (tf.birth_d_e       is null or tf.birth_d_e >= t."BirthDate")
      -- по возрасту
      and (tf.age_b           is null or tf.age_b <= datediff(month from t."BirthDate" to c.system_date)/12)
      and (tf.age_e           is null or datediff(month from t."BirthDate" to c.system_date)/12 <= tf.age_e)
      -- фильтр по дате устройства
      and (tf.enter_d_b       is null or tf.enter_d_b <= t."EnterDate")
      and (tf.enter_d_e       is null or tf.enter_d_e >= t."EnterDate")
      -- по дате увольнения
      and (tf.release_d_b     is null or tf.release_d_b <= t."ReleaseDate")
      and (tf.release_d_e     is null or tf.release_d_e >= t."ReleaseDate")
      -- по пед. категории
      and (tf.cat_id_ped      is null or ',' || tf.cat_id_ped || ',' like '%,' || t.id_category || ',%')
      -- по конц. категории
      and (tf.cat_id_conc     is null or ',' || tf.cat_id_conc || ',' like '%,' || t.id_category_conc || ',%')
      -- по званию
      and (tf.title_id        is null or ',' || tf.title_id || ',' like '%,' || t.id_title || ',%')
    into :teacher_id
  do
    suspend;
end^


ALTER PROCEDURE GET_FILTRED_STUDENT (
    ID_FILTER INTEGER)
RETURNS (
    ID INTEGER)
AS
BEGIN

  IF (:id_filter IS NULL) THEN
  BEGIN
    FOR SELECT ID FROM "Student" INTO :ID DO SUSPEND;
  END
  ELSE
  BEGIN
    FOR
      SELECT DISTINCT S.ID
      FROM "Student" S
        INNER JOIN student_filter SF ON
          SF.ID = :ID_FILTER
        INNER JOIN PROC_FOR_STUDENT_FILTER(:ID_FILTER) PFSF
        ON PFSF.STUDENTID = S.ID
        LEFT JOIN "Specialization" SPEC ON SPEC.ID = S."SpecializationID"
        LEFT JOIN "Department" D ON D.ID = SPEC."DepartmentID"
        LEFT JOIN CURRICULUM C ON C.ID = D."CurriculumID"
        LEFT JOIN CURR_CAT CC ON
          CC.CURR_ID = C.ID AND
          S."Class" = CC.CLASS_NUM
      WHERE
          (NOT EXISTS (SELECT * FROM STUDENT_FILTER_SPEC WHERE ID_FILTER = :ID_FILTER) OR
            S."SpecializationID" IN (SELECT ID_SPECIALIZATION FROM STUDENT_FILTER_SPEC WHERE ID_FILTER = :ID_FILTER)) AND
          (SF.FILIAL_ID IS NULL OR (SF.FILIAL_ID = S."FilialID")) AND
          (SF.CLASS_B IS NULL OR (S."Class" >= SF.CLASS_B)) AND
          (SF.CLASS_E IS NULL OR (S."Class" <= SF.CLASS_E)) AND
          (SF.CURATOR_ID IS NULL OR (SF.CURATOR_ID = S."MasterID")) AND
          (SF.CATEGORY IS NULL OR (CC.CATEGORY = SF.CATEGORY)) AND
          (SF.PERIOD IS NULL OR (C.PERIOD = SF.PERIOD)) AND
          (SF.STATUS IS NULL OR (
            (SF.STATUS = 0) AND (S.RELEASED = 0) AND (S.ACADEMY = 0) OR
            (SF.STATUS = 1) AND (S.RELEASED = 0) OR
            (SF.STATUS = 2) AND (S.ACADEMY = 1) AND (S.RELEASED = 0) OR
            (SF.STATUS = 3) AND (S.RELEASED > 0) OR
            (SF.STATUS = 4) AND (S.ACADEMY = 0) AND (S.RELEASED = 0) AND (S."AcademyBDate" IS NUll) OR
            (SF.STATUS = 5) AND (S.ACADEMY = 0) AND (S.RELEASED = 0) AND (S."RestoreDate" IS NUll) OR
            (SF.STATUS = 6) AND (S.ACADEMY = 0) AND (S.RELEASED = 0) AND (S."AcademyBDate" IS NUll) AND (S."RestoreDate" IS NUll)
            )
          )
          AND
          (SF.PAY_PERCENT IS NULL OR (
            SF.PAY_PERCENT =
              CASE
                WHEN S."Percent" = 100 THEN 1 --полная
                WHEN S."Percent" < 100 THEN 2 --льготная
              END
            )
          ) AND
          (SF.AGE_B IS NULL OR
            (SF.AGE_B <=
              div(CURRENT_DATE - S."BirthDate", 365)
            )
          ) AND
          (SF.AGE_E IS NULL OR
            (SF.AGE_E >= EXTRACT(YEAR FROM CURRENT_DATE) - EXTRACT(YEAR FROM S."BirthDate"))) AND
          (SF.ENTER_D_B IS NULL OR (SF.ENTER_D_B <= S."EnterDate")) AND
          (SF.ENTER_D_E IS NULL OR (SF.ENTER_D_E >= S."EnterDate")) AND
          (SF.RELEASE_D_B IS NULL OR (SF.RELEASE_D_B <= S."ReleaseDate")) AND
          (SF.RELEASE_D_E IS NULL OR (SF.RELEASE_D_E >= S."ReleaseDate")) AND
          (SF.RESTORE_D_B IS NULL OR (SF.RESTORE_D_B <= S."RestoreDate")) AND
          (SF.RESTORE_D_E IS NULL OR (SF.RESTORE_D_E >= S."RestoreDate")) AND
          (SF.ACADEMY_D_B IS NULL OR (SF.ACADEMY_D_B <= S."AcademyBDate")) AND
          (SF.ACADEMY_D_E IS NULL OR (SF.ACADEMY_D_E >= S."AcademyEDate")) AND
          (SF.FINANCING_ID IS NULL OR (SF.FINANCING_ID = S."FinancingID")) AND
          (SF.f_id_sex IS NULL OR (SF.f_id_sex = S.f_id_sex))
      INTO :ID
    DO SUSPEND;
  END
END^


ALTER PROCEDURE GET_QUALIFICATION_ID (
    NAME VARCHAR(256))
RETURNS (
    ID INTEGER)
AS
  declare variable v_curr_date  date;
  declare variable v_start_date date;
begin
  select q.id
  from qualification q
  where trim(lower(q.name)) = trim(lower(:name))
  into :id;

  if (id is null) then
  begin
    id = Gen_ID(gen_common, 1);
    insert into qualification(id, name) values (:id, trim(:name));
  end
  suspend;
end^


ALTER PROCEDURE GET_ST_I_SUBJ_CLOCKS_CSV (
    TEACHER_ID INTEGER,
    STUDENT_ID INTEGER)
RETURNS (
    CLOCKS VARCHAR(3000))
AS
declare variable SUBJECT_NAME varchar(150);
declare variable C_TIME numeric(3,1);
declare variable I numeric(10,0);
declare variable SUBJECT_CLOCKS varchar(6);
begin
  clocks = '';
  i = 0;
  for
    select
      (case when coalesce(cr2.id, cr3.id) is not null then 'К.' else '' end) ||
      coalesce(s.short_name, s."Name"),
      crt.c_time
    from "Student" st
      left join "Specialization" SP on SP.id = ST."SpecializationID"
      left join "Department"      D on D.id = SP."DepartmentID"
      left join curriculum        C on D."CurriculumID" = C.id
      left join "Student_Plan"  STP on ST.id = STP."StudentID"
      left join curr_rec         CR on CR.curr_id = C.id and STP.curr_rec_id = CR.id and CR.GROUP_QTY = 1
      -- если концертмейстер - получаем предыдущий предмет
      left join curr_rec        CR2 on CR.is_cmaster = 1 and CR2.curr_id = C.id and coalesce(CR2.is_cmaster, 0) != 1
                                   and CR2.num = CR.num - 1
      left join curr_rec        CR3 on CR.is_cmaster = 1 and CR3.curr_id = C.id and coalesce(CR3.is_cmaster, 0) != 1
                                   and CR3.num = CR.num - 2
      inner join curr_rec_time  CRT on CRT.curr_id = C.id and CRT.curr_rec_id = CR.id
                                   and ST."Class" = CRT.class_num
      -- концертмейстер нас не интересует, получаем наименование предмета
      inner join "Subject"         s on s.id = coalesce(cr2.subject_id, cr3.subject_id, cr.subject_id)
    where ST.released = 0 and ST.academy = 0 and STP."Use" > 0
      and stp."TeacherID" = :teacher_id
      and st.id = :student_id
      and crt.c_time > 0
    into :subject_name, :c_time
  do
  begin
      subject_clocks = :c_time;
      if (:c_time - truncate(:c_time) < 0.5) then
        subject_clocks = cast(:c_time as integer);
      if (:c_time > 0) then
        clocks = :clocks || coalesce(:subject_name, '') || coalesce(:subject_clocks, '');
  end
  suspend;
end^


ALTER PROCEDURE GET_TEACHER_CAT_LIST (
    ID_TEACHER INTEGER,
    ID_GROUP INTEGER)
RETURNS (
    CATEGORY_LIST VARCHAR(3000))
AS
declare variable tmp varchar(255);
begin
  category_list = '';
  FOR
    SELECT ock.f_name
    FROM teacher_cat tc
        LEFT JOIN obj_cat_kind ock ON
            tc.f_id_cat_kind = ock.f_id
    WHERE tc.f_id_teacher = :id_teacher AND ock.f_id_group = :id_group
    INTO :tmp
  DO
  BEGIN
    category_list = category_list || tmp || '; ';
  END
  suspend;
end^


ALTER PROCEDURE GET_TEACHERS_TM
RETURNS (
    TEACHER_ID INTEGER,
    TEACHER_NAME VARCHAR(250),
    TEACHER_POST VARCHAR(250),
    CAT_COEF_P DOUBLE PRECISION,
    CAT_COEF_C DOUBLE PRECISION,
    TITLE_PCT NUMERIC(10,2),
    SUM_CAT_COEF_P NUMERIC(10,2),
    SUM_CAT_COEF_C NUMERIC(10,2),
    SUM_PCT_P NUMERIC(10,2),
    SUM_PCT_C NUMERIC(10,2),
    SUM_PED NUMERIC(10,2),
    SUM_CONC NUMERIC(10,2),
    SUM_TOTAL NUMERIC(10,2),
    SUM_ADD NUMERIC(10,2),
    SUM_WT_ADD NUMERIC(10,2))
AS
declare variable V_TAR_DATE timestamp;
begin
  --v_tar_date =
  execute procedure proc_new_tariffication(null)
  returning_values (:v_tar_date);

  for
    select
      tr.teacher_id,
      tr.t_name,
      tr.t_post,
      case
        when t.id_category = 3 then 0.2
        when t.id_category = 2 then 0.15
        when t.id_category = 1 then 0.1
        else null
      end                                      cat_coef_p,
      case
        when t.id_category_conc = 3 then 0.2
        when t.id_category_conc = 2 then 0.15
        when t.id_category_conc = 1 then 0.1
        else null
      end                                      cat_coef_c,
      case
        when t.id_title is not null then 0.1
        else null
      end                                      title_pct,
      tr.sum_y + tr.sum_o                      sum_ped,
      tr.sum_c                                 sum_conc
    from v_tar_record tr
    left join v_tariffication tar on tar.doc_date = tr.doc_date
    left join "Teacher"       t   on t.id = tr.teacher_id
    where tr.doc_date = :v_tar_date
      and tr.teacher_id != 0 -- исключаем нераспред
    order by tr.t_name
    into :teacher_id, :teacher_name, :teacher_post,
      :cat_coef_p, :cat_coef_c, :title_pct, :sum_ped, :sum_conc
  do
  begin
    sum_cat_coef_p = :cat_coef_p * :sum_ped;
    sum_cat_coef_c = :cat_coef_c * :sum_conc;
    sum_pct_p      = :title_pct  * :sum_ped;
    sum_pct_c      = :title_pct  * :sum_conc;
    sum_add        = coalesce(:sum_cat_coef_p, 0) + coalesce(:sum_cat_coef_c, 0) +
                     coalesce(:sum_pct_p, 0) + coalesce(:sum_pct_c, 0);
    sum_wt_add     = coalesce(:sum_ped, 0) + coalesce(:sum_conc, 0);
    sum_total      = :sum_wt_add + :sum_add;
    suspend;
  end

  execute procedure delete_tariffication(:v_tar_date);
end^


ALTER PROCEDURE MAIN_TAB_PART_2
RETURNS (
    ABSENCE_CODES VARCHAR(255),
    TEACHER_TAB_NUM INTEGER,
    CLOCK_Y INTEGER,
    CLOCK_O INTEGER,
    CLOCK_C INTEGER,
    CLOCK_SWP_Y INTEGER,
    CLOCK_SWP_O INTEGER,
    CLOCK_SWP_C INTEGER,
    COMMENTS VARCHAR(255))
AS
declare variable V_DATE_BEGIN date;
declare variable V_DATE_END date;
declare variable V_ID integer;
declare variable V_QTY integer;
declare variable V_CODE varchar(150);
begin
  select c.system_date from constants c into :v_date_begin;

  v_date_begin = v_date_begin - extract(day from v_date_begin) + 1;
  v_date_end = dateadd(1 month to v_date_begin) - 1;

  for
    select t.tab_num, t.id, mt.b_y_time, mt.b_o_time, mt.b_c_time, mt.swp_y_time, mt.swp_o_time, mt.swp_c_time, mt.comments
    from "Teacher" t
      inner join main_tab mt on mt.teacher_id = t.id
    where t.id != 0
    order by t."Name"
    into :teacher_tab_num, :v_id, :clock_y, :clock_o, :clock_c, :clock_swp_y, :clock_swp_o, :clock_swp_c, :comments
  do
  begin
    absence_codes = '';
    for
      select abt.code, count(*)
      from teacher_absent ta
        left join absent_type abt on abt.id = ta.absent_type_id
      where ta.teacher_id = :v_id
        and ta.absent_date between :v_date_begin and :v_date_end
      group by abt.code
      into :v_code, :v_qty
    do
      absence_codes = absence_codes || v_qty || ' ' || v_code || ASCII_CHAR(13) || ASCII_CHAR(10);

    suspend;
  end
end^


ALTER PROCEDURE NEW_PROCEDURE (
    ID_FILTER INTEGER,
    ID_SPECIALIZATION INTEGER)
AS
begin
  IF (EXISTS (SELECT * FROM STUDENT_FILTER WHERE ID = :ID_FILTER)) THEN
  BEGIN
    IF (NOT EXISTS (
      SELECT *
      FROM STUDENT_FILTER_SPEC
      WHERE ID_FILTER = :ID_FILTER AND ID_SPECIALIZATION = :ID_SPECIALIZATION))
    THEN
      INSERT INTO STUDENT_FILTER_SPEC (ID_FILTER, ID_SPECIALIZATION)
      VALUES (:ID_FILTER, :ID_SPECIALIZATION);
  END
  ELSE
    EXCEPTION E_STUDENT_FILTER_SPEC;
end^


ALTER PROCEDURE POS_CHANGE (
    P_TABLE_NAME VARCHAR(150),
    P_ORDER_BY VARCHAR(1000),
    P_ID INTEGER,
    P_STEEP INTEGER)
AS
declare variable v_counter integer;
begin
  /* Procedure Text */
  -- 1. проверяем упорядоченность
  execute procedure CHECK_ORDERED(p_table_name, p_order_by);
  -- 2. поднимаем|опускаем элемент
  if (p_steep > 0) then
  begin
    v_counter = p_steep;
    while (v_counter > 0) do
    begin
      execute procedure pos_inc(p_table_name, p_id);
      v_counter = v_counter - 1;
    end
  end
 if (p_steep < 0) then
  begin
    v_counter = p_steep;
    while (v_counter < 0) do
    begin
      execute procedure pos_dec(p_table_name, p_id);
      v_counter = v_counter + 1;
    end
  end
  -- 3. снова проверяем упорядоченность, чтобы не было выхода из группы
  execute procedure CHECK_ORDERED(p_table_name, p_order_by);
end^


ALTER PROCEDURE POS_DEC (
    P_TABLE_NAME VARCHAR(150),
    P_ID INTEGER)
AS
declare variable v_pos_curr integer;
declare variable v_pos_prev integer;
declare variable v_id_prev integer;
begin
  /* Procedure Text */
  -- 1. считаем, что упорядоченность проверена
  -- 2. теперь всё по порядку, получаем текущую позицию
  execute statement 'select pos from ' || p_table_name || ' where id = ' || p_id
  into :v_pos_curr;
  -- если текущая позиция null, значит некорректно задан p_id - выходим
  if (v_pos_curr is null) then
  begin
    exit;
  end
  v_pos_prev = v_pos_curr - 1;
  -- 3. получаем id предыдущего елемента
  execute statement 'select id from ' || p_table_name || ' where pos = ' || v_pos_prev
  into :v_id_prev;
  -- если id следующего элемента - null - выходим
  if (v_id_prev is null) then
  begin
    exit;
  end
  -- меняем местами элементы
  execute statement 'update ' || p_table_name || ' set pos = ' || v_pos_curr  || ' where id = ' || v_id_prev;
  execute statement 'update ' || p_table_name || ' set pos = ' || v_pos_prev || ' where id = ' || p_id;
end^


ALTER PROCEDURE POS_INC (
    P_TABLE_NAME VARCHAR(150),
    P_ID INTEGER)
AS
declare variable v_pos_curr integer;
declare variable v_pos_next integer;
declare variable v_id_next integer;
begin
  /* Procedure Text */
  -- 1. считаем, что упорядоченность проверена
  -- 2. теперь всё по порядку, получаем текущую позицию
  execute statement 'select pos from ' || p_table_name || ' where id = ' || p_id
  into :v_pos_curr;
  -- если текущая позиция null, значит некорректно задан p_id - выходим
  if (v_pos_curr is null) then
  begin
    exit;
  end
  v_pos_next = v_pos_curr + 1;
  -- 3. получаем id следующего елемента
  execute statement 'select id from ' || p_table_name || ' where pos = ' || v_pos_next
  into :v_id_next;
  -- если id следующего элемента - null - выходим
  if (v_id_next is null) then
  begin
    exit;
  end
  -- меняем местами элементы
  execute statement 'update ' || p_table_name || ' set pos = ' || v_pos_curr  || ' where id = ' || v_id_next;
  execute statement 'update ' || p_table_name || ' set pos = ' || v_pos_next || ' where id = ' || p_id;
end^


ALTER PROCEDURE PROC_ALL_TEACHER_GROUP (
    IN_GROUPING_ID INTEGER,
    IN_TEACHER_ID INTEGER)
RETURNS (
    GROUPING_ID INTEGER,
    GROUPING_NAME VARCHAR(30),
    TEACHER_ID INTEGER,
    TEACHER VARCHAR(50),
    GR_QTY_0 INTEGER,
    GR_QTY_1 INTEGER,
    GR_QTY_2 INTEGER,
    GR_QTY_3 INTEGER,
    GR_QTY_4 INTEGER,
    GR_QTY_5 INTEGER,
    GR_QTY_6 INTEGER,
    GR_QTY_7 INTEGER,
    GR_QTY_8 INTEGER)
AS
begin
  for
    select G.id, G.name, T.id, T."Name",
      sum(case TG.class_num when 0 then TG.group_q else null end),
      sum(case TG.class_num when 1 then TG.group_q else null end),
      sum(case TG.class_num when 2 then TG.group_q else null end),
      sum(case TG.class_num when 3 then TG.group_q else null end),
      sum(case TG.class_num when 4 then TG.group_q else null end),
      sum(case TG.class_num when 5 then TG.group_q else null end),
      sum(case TG.class_num when 6 then TG.group_q else null end),
      sum(case TG.class_num when 7 then TG.group_q else null end),
      sum(case TG.class_num when 8 then TG.group_q else null end)
    from "Teacher" T join teacher_group TG on T.id = TG.teacher_id
      join grouping G on G.id = TG.grouping_id
    where (:in_grouping_id is null or G.id = :in_grouping_id) and
      (:in_teacher_id is null or T.id = :in_teacher_id)
    group by G.id, G.name, T.id, T."Name"
    into :grouping_id, :grouping_name, :teacher_id, :teacher, :gr_qty_0, :gr_qty_1,
      :gr_qty_2, :gr_qty_3, :gr_qty_4, :gr_qty_5, :gr_qty_6, :gr_qty_7, :gr_qty_8
  do SUSPEND;
  for
    select distinct
      G.id, G.name,
      T.id, T."Name", null, null, null, null, null, null, null, null, null
    from  "Student_Plan" STP
      join "Student" S on STP."StudentID" = S.id and
        S.released = 0 and S.academy = 0 and STP."Use" > 0
      join "Specialization" SP on SP.id = S."SpecializationID"
      join "Department" D on D.id = SP."DepartmentID"
      join curr_rec CR on D."CurriculumID" = CR.curr_id and CR.id = STP.curr_rec_id
      join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id
        and S."Class" = CRT.class_num and coalesce(CRT.c_time, 0) > 0
      join grouping G on G.financing_id = S."FinancingID"
      join grouping_subj_curr_id GSCN on GSCN.grouping_id = G.id and
        GSCN.curr_id = D."CurriculumID" and GSCN.curr_rec_id = STP.curr_rec_id
      join "Teacher" T on T.id = STP."TeacherID"
    where (:in_grouping_id is null or G.id = :in_grouping_id) and
      (:in_teacher_id is null or T.id = :in_teacher_id) and
      T.id not in
      (select TG.teacher_id from teacher_group TG where TG.grouping_id = G.id)
    into :grouping_id, :grouping_name, :teacher_id, :teacher, :gr_qty_0, :gr_qty_1, :gr_qty_2, 
:gr_qty_3,
      :gr_qty_4, :gr_qty_5, :gr_qty_6, :gr_qty_7, :gr_qty_8
  do suspend;
end^


ALTER PROCEDURE PROC_CALC_TEACHER_GROUP (
    IN_GROUPING_ID INTEGER,
    IN_CLASS_NUM INTEGER,
    IN_GR_SUBJ_ID INTEGER,
    IN_REPL_TYPE INTEGER)
AS
DECLARE VARIABLE GROUPING_ID INTEGER;
DECLARE VARIABLE CLASS_NUM INTEGER;
DECLARE VARIABLE GR_SUBJ_ID INTEGER;
DECLARE VARIABLE TEACHER_ID INTEGER;
DECLARE VARIABLE ST_GR_QTY INTEGER;
DECLARE VARIABLE ST_QTY INTEGER;
DECLARE VARIABLE GR_QTY INTEGER;
begin
  delete from teacher_group TG where TG.group_q = 0;
  for
    select G.id, STP."TeacherID", GS.id, GS.group_qty, S."Class",
      coalesce(sum(case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end), 0)
    from "Student_Plan" STP
      join "Student" S on STP."StudentID" = S.id and STP."Use" > 0 and
        S.released = 0 and S.academy = 0
      join "Specialization" SP on SP.id = S."SpecializationID"
      join "Department" D on D.id = SP."DepartmentID"
      join curr_rec CR on D."CurriculumID" = CR.curr_id and CR.id = STP.curr_rec_id
      join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id
        and S."Class" = CRT.class_num
      join grouping G on G.financing_id = S."FinancingID"
      join grouping_subj GS on GS.grouping_id = G.id
      join grouping_subj_curr_id GSCN on GSCN.grouping_id = G.id and
        GS.id = GSCN.grouping_subj_id and GSCN.curr_id = D."CurriculumID" and
        GSCN.curr_rec_id = STP.curr_rec_id
    where (G.id = :in_grouping_id or :in_grouping_id is null) and
      (GS.id = :in_gr_subj_id or :in_gr_subj_id is null) and
      (S."Class" = :in_class_num or :in_class_num is null)
    group by G.id, STP."TeacherID", GS.id, GS.group_qty, S."Class"
    into :grouping_id, :teacher_id, :gr_subj_id, :st_gr_qty, :class_num, :st_qty
  do
  begin
    select TG.group_q
    from teacher_group TG
    where TG.grouping_id = :grouping_id and TG.teacher_id = :teacher_id and
      TG.gr_subj_id = :gr_subj_id and TG.class_num = :class_num
    into :gr_qty;

    if (:in_repl_type = 0 and :gr_qty is null) then /* заменять только пустые*/
      execute procedure add_teacher_group(:grouping_id, :teacher_id, :gr_subj_id, :class_num,
        :st_qty / :st_gr_qty);
    else if (:in_repl_type = 1 and ((gr_qty is null) or (gr_qty = 0))) then /* заменять только пустые и нулевые */
      execute procedure add_teacher_group(:grouping_id, :teacher_id, :gr_subj_id, :class_num,
        :st_qty / :st_gr_qty);
    else if (:in_repl_type = 2) then /* заменять все */
      execute procedure add_teacher_group(:grouping_id, :teacher_id, :gr_subj_id, :class_num,
        :st_qty / :st_gr_qty);
  end
end^


ALTER PROCEDURE PROC_CALC_TEACHER_GROUP_EXT (
    IN_GROUPING_ID INTEGER,
    IN_TEACHER_ID INTEGER,
    IN_REPL_TYPE INTEGER)
AS
DECLARE VARIABLE GROUPING_ID INTEGER;
DECLARE VARIABLE TEACHER_ID INTEGER;
DECLARE VARIABLE GR_SUBJ_ID INTEGER;
DECLARE VARIABLE CLASS_NUM INTEGER;
DECLARE VARIABLE ST_GR_QTY INTEGER;
DECLARE VARIABLE ST_QTY INTEGER;
DECLARE VARIABLE GR_QTY INTEGER;
begin
  /*delete from teacher_group TG where TG.group_q = 0;*/
  for
    select G.id, STP."TeacherID", GS.id, GS.group_qty, S."Class",
      coalesce(sum(case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end), 0)
    from "Student_Plan" STP
      join "Student" S on STP."StudentID" = S.id and STP."Use" > 0 and
        S.released = 0 and S.academy = 0
      join "Specialization" SP on SP.id = S."SpecializationID"
      join "Department" D on D.id = SP."DepartmentID"
      join curr_rec CR on D."CurriculumID" = CR.curr_id and CR.id = STP.curr_rec_id
      join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id
        and S."Class" = CRT.class_num
      join grouping G on G.financing_id = S."FinancingID"
      join grouping_subj GS on GS.grouping_id = G.id
      join grouping_subj_curr_id GSCN on GSCN.grouping_id = G.id and
        GS.id = GSCN.grouping_subj_id and GSCN.curr_id = D."CurriculumID" and
        GSCN.curr_rec_id = STP.curr_rec_id
    where (G.id = :in_grouping_id or :in_grouping_id is null) and
      (STP."TeacherID" = :in_teacher_id or :in_teacher_id is null)
    group by G.id, STP."TeacherID", GS.id, GS.group_qty, S."Class"
    into :grouping_id, :teacher_id, :gr_subj_id, :st_gr_qty, :class_num, :st_qty
  do
  begin
    gr_qty = null;
    select TG.group_q
    from teacher_group TG
    where TG.grouping_id = :grouping_id and
      TG.teacher_id = :teacher_id and
      TG.gr_subj_id = :gr_subj_id and TG.class_num = :class_num
    into :gr_qty;

    if (:st_qty / :st_gr_qty <> 0) then
    begin
      if (:in_repl_type = 0 and :gr_qty is null) then 
        execute procedure add_teacher_group(:grouping_id, :teacher_id, :gr_subj_id, :class_num, 
:st_qty / :st_gr_qty);
      else if (:in_repl_type = 1 and ((gr_qty is null) or (gr_qty = 0))) then 
        execute procedure add_teacher_group(:grouping_id, :teacher_id, :gr_subj_id, :class_num, 
:st_qty / :st_gr_qty);
      else if (:in_repl_type = 2) then 
        execute procedure add_teacher_group(:grouping_id, :teacher_id, :gr_subj_id, :class_num, 
:st_qty / :st_gr_qty);
    end
  end
  delete from teacher_group TG where TG.group_q is null;
end^


ALTER PROCEDURE PROC_CURR_REC_REPORT (
    IN_CURR_ID INTEGER,
    IN_FINANCING_ID INTEGER)
RETURNS (
    CURR_REC_ID INTEGER,
    CURR_REC_NUM INTEGER,
    SUBJECT_NAME VARCHAR(30),
    SUBJECT_CODE INTEGER,
    GROUP_QTY INTEGER,
    QTY_0 INTEGER,
    QTY_1 INTEGER,
    QTY_2 INTEGER,
    QTY_3 INTEGER,
    QTY_4 INTEGER,
    QTY_5 INTEGER,
    QTY_6 INTEGER,
    QTY_7 INTEGER,
    QTY_8 INTEGER,
    T_0 DOUBLE PRECISION,
    T_1 DOUBLE PRECISION,
    T_2 DOUBLE PRECISION,
    T_3 DOUBLE PRECISION,
    T_4 DOUBLE PRECISION,
    T_5 DOUBLE PRECISION,
    T_6 DOUBLE PRECISION,
    T_7 DOUBLE PRECISION,
    T_8 DOUBLE PRECISION,
    T_ALL_Y DOUBLE PRECISION,
    T_ALL_O DOUBLE PRECISION,
    T_ALL_C DOUBLE PRECISION,
    T_V_Y DOUBLE PRECISION,
    T_V_O DOUBLE PRECISION,
    T_V_C DOUBLE PRECISION,
    G_QTY_Y INTEGER,
    G_QTY_O INTEGER,
    QTY_Y INTEGER,
    QTY_O INTEGER,
    QTY_C INTEGER,
    QTY_V_Y INTEGER,
    QTY_V_O INTEGER,
    QTY_V_C INTEGER,
    T_V_0 DOUBLE PRECISION,
    T_V_1 DOUBLE PRECISION,
    T_V_2 DOUBLE PRECISION,
    T_V_3 DOUBLE PRECISION,
    T_V_4 DOUBLE PRECISION,
    T_V_5 DOUBLE PRECISION,
    T_V_6 DOUBLE PRECISION,
    T_V_7 DOUBLE PRECISION,
    T_V_8 DOUBLE PRECISION)
AS
begin
  for
    select CR.id, CR.num, CR.group_qty, S."Code", S."Name"
    from curr_rec CR join "Subject" S on S.id = CR.subject_id
    where CR.curr_id = :in_curr_id
    order by CR.num
    into :curr_rec_id, :curr_rec_num, :group_qty, :subject_code, :subject_name
  do
  begin
    g_qty_y = null;
    g_qty_o = null;
    if (:group_qty = 1) then
    begin
      select
        sum(case ST."Class" when 0 then 1 else null end),
        sum(case ST."Class" when 1 then 1 else null end),
        sum(case ST."Class" when 2 then 1 else null end),
        sum(case ST."Class" when 3 then 1 else null end),
        sum(case ST."Class" when 4 then 1 else null end),
        sum(case ST."Class" when 5 then 1 else null end),
        sum(case ST."Class" when 6 then 1 else null end),
        sum(case ST."Class" when 7 then 1 else null end),
        sum(case ST."Class" when 8 then 1 else null end),

        sum(case ST."Class" when 0 then CRT.c_time else null end),
        sum(case ST."Class" when 1 then CRT.c_time else null end),
        sum(case ST."Class" when 2 then CRT.c_time else null end),
        sum(case ST."Class" when 3 then CRT.c_time else null end),
        sum(case ST."Class" when 4 then CRT.c_time else null end),
        sum(case ST."Class" when 5 then CRT.c_time else null end),
        sum(case ST."Class" when 6 then CRT.c_time else null end),
        sum(case ST."Class" when 7 then CRT.c_time else null end),
        sum(case ST."Class" when 8 then CRT.c_time else null end),
        sum((case :subject_code when 1 then null else CRT.c_time end) * (case CC.category when 0 
then 1 else null end)),
        sum((case :subject_code when 1 then null else CRT.c_time end) * CC.category),
        sum(CRT.c_time * (case :subject_code when 1 then 1 else null end)),
        sum((case :subject_code when 1 then null else 1 end) * (case CC.category when 0 then 1 
else null end)),
        sum((case :subject_code when 1 then null else 1 end) * CC.category),
        sum((case :subject_code when 1 then 1 else null end))
      from "Student" ST
        join "Specialization" SP on ST."SpecializationID" = SP.id
        join "Department" D on D.id = SP."DepartmentID" and
          D."CurriculumID" = :in_curr_id
        join "Student_Plan" STP on ST.id = STP."StudentID" and
          STP.curr_rec_id = :curr_rec_id
        join curr_rec_time CRT on CRT.curr_id = :in_curr_id and
          CRT.curr_rec_id = :curr_rec_id and ST."Class" = CRT.class_num and
          CRT.c_time > 0
        join curr_cat CC on CC.curr_id = :in_curr_id and CC.class_num = ST."Class"
      where ST."FinancingID" = :in_financing_id and STP."TeacherID" <> 0 and
        STP."Use" >0 and ST.released = 0 and ST.academy = 0
      into :qty_0, :qty_1, :qty_2, :qty_3, :qty_4, :qty_5, :qty_6, :qty_7,  :qty_8,
        :t_0, :t_1, :t_2, :t_3, :t_4, :t_5, :t_6, :t_7, :t_8, :t_all_y, :t_all_o,
        :t_all_c, :qty_y, :qty_o, :qty_c;

      select
        sum(case ST."Class" when 0 then CRT.c_time else null end),
        sum(case ST."Class" when 1 then CRT.c_time else null end),
        sum(case ST."Class" when 2 then CRT.c_time else null end),
        sum(case ST."Class" when 3 then CRT.c_time else null end),
        sum(case ST."Class" when 4 then CRT.c_time else null end),
        sum(case ST."Class" when 5 then CRT.c_time else null end),
        sum(case ST."Class" when 6 then CRT.c_time else null end),
        sum(case ST."Class" when 7 then CRT.c_time else null end),
        sum(case ST."Class" when 8 then CRT.c_time else null end),
        sum((case :subject_code when 1 then null else CRT.c_time end) * (case CC.category when 0 
then 1 else null end)),
        sum((case :subject_code when 1 then null else CRT.c_time end) * CC.category),
        sum(CRT.c_time * (case :subject_code when 1 then 1 else null end)),
        sum((case :subject_code when 1 then null else 1 end) * (case CC.category when 0 then 1 
else null end)),
        sum((case :subject_code when 1 then null else 1 end) * CC.category),
        sum((case :subject_code when 1 then 1 else null end))
      from "Student" ST
        join "Specialization" SP on ST."SpecializationID" = SP.id
        join "Department" D on D.id = SP."DepartmentID" and
          D."CurriculumID" = :in_curr_id
        join "Student_Plan" STP on ST.id = STP."StudentID" and
          STP.curr_rec_id = :curr_rec_id
        join curr_rec_time CRT on CRT.curr_id = :in_curr_id and
          CRT.curr_rec_id = :curr_rec_id and ST."Class" = CRT.class_num and
          CRT.c_time > 0
        join curr_cat CC on CC.curr_id = :in_curr_id and CC.class_num = ST."Class"
      where ST."FinancingID" = :in_financing_id and STP."TeacherID" = 0 and
        STP."Use" >0 and ST.released = 0 and ST.academy = 0
      into :t_v_0, :t_v_1, :t_v_2, :t_v_3, :t_v_4, :t_v_5, :t_v_6, :t_v_7, :t_v_8,
        :t_v_y, :t_v_o, :t_v_c, :qty_v_y, :qty_v_o, :qty_v_c;
    end
    else begin
      select
        sum(case TG.class_num when 0 then TG.group_q else null end),
        sum(case TG.class_num when 1 then TG.group_q else null end),
        sum(case TG.class_num when 2 then TG.group_q else null end),
        sum(case TG.class_num when 3 then TG.group_q else null end),
        sum(case TG.class_num when 4 then TG.group_q else null end),
        sum(case TG.class_num when 5 then TG.group_q else null end),
        sum(case TG.class_num when 6 then TG.group_q else null end),
        sum(case TG.class_num when 7 then TG.group_q else null end),
        sum(case TG.class_num when 8 then TG.group_q else null end),

        sum(case TG.class_num when 0 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 1 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 2 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 3 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 4 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 5 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 6 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 7 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 8 then TG.group_q*CRT.c_time else null end),
        sum((case CC.category when 0 then (case :subject_code when 1 then null else TG.group_q 
end) else null end) * CRT.c_time),
        sum(CC.category * (case :subject_code when 1 then null else TG.group_q end) * 
CRT.c_time),
        sum((case :subject_code when 1 then TG.group_q else null end) * CRT.c_time),
        sum(case CC.category when 0 then TG.group_q else null end),
        sum(TG.group_q * CC.category)
      from teacher_group TG
        join grouping_subj_curr_id GSCI on GSCI.grouping_id = TG.grouping_id and
          GSCI.grouping_subj_id = TG.gr_subj_id and TG.group_q > 0 and
          GSCI.curr_id = :in_curr_id and GSCI.curr_rec_id = :curr_rec_id
        join grouping G on G.id = TG.grouping_id and G.financing_id = :in_financing_id
        join curr_rec_time CRT on CRT.curr_id = :in_curr_id and
          CRT.curr_rec_id = :curr_rec_id and CRT.class_num = TG.class_num and
          CRT.c_time > 0
        join curr_cat CC on CC.curr_id = :in_curr_id and TG.class_num = CC.class_num
      where TG.teacher_id <> 0 and
        CRT.curr_id in
        (select min(GSCI2.curr_id)
         from grouping_subj_curr_id GSCI2
         where GSCI2.grouping_id = g.id and GSCI2.grouping_subj_id = TG.gr_subj_id)
      into :qty_0, :qty_1, :qty_2, :qty_3, :qty_4, :qty_5, :qty_6, :qty_7,  :qty_8,
        :t_0, :t_1, :t_2, :t_3, :t_4, :t_5, :t_6, :t_7, :t_8, :t_all_y, :t_all_o,
        :t_all_c, :g_qty_y, :g_qty_o;

      select
        sum(case TG.class_num when 0 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 1 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 2 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 3 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 4 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 5 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 6 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 7 then TG.group_q*CRT.c_time else null end),
        sum(case TG.class_num when 8 then TG.group_q*CRT.c_time else null end),
        sum((case CC.category when 0 then (case :subject_code when 1 then null else TG.group_q 
end) else null end) * CRT.c_time),
        sum(CC.category * (case :subject_code when 1 then null else TG.group_q end) * 
CRT.c_time),
        sum((case :subject_code when 1 then TG.group_q else null end) * CRT.c_time)
      from teacher_group TG
        join grouping_subj_curr_id GSCI on GSCI.grouping_id = TG.grouping_id and
          GSCI.grouping_subj_id = TG.gr_subj_id and TG.group_q > 0 and
          GSCI.curr_id = :in_curr_id and GSCI.curr_rec_id = :curr_rec_id
        join grouping G on G.id = TG.grouping_id and G.financing_id = :in_financing_id
        join curr_rec_time CRT on CRT.curr_id = :in_curr_id and
          CRT.curr_rec_id = :curr_rec_id and CRT.class_num = TG.class_num and
          CRT.c_time > 0
        join curr_cat CC on CC.curr_id = :in_curr_id and TG.class_num = CC.class_num
      where TG.teacher_id = 0 and
        CRT.curr_id in
        (select min(GSCI2.curr_id)
         from grouping_subj_curr_id GSCI2
         where GSCI2.grouping_id = g.id and GSCI2.grouping_subj_id = TG.gr_subj_id)
      into :t_v_0, :t_v_1, :t_v_2, :t_v_3, :t_v_4, :t_v_5, :t_v_6, :t_v_7, :t_v_8,
        :t_v_y, :t_v_o, :t_v_c;
    end

    suspend;
  end
end^


ALTER PROCEDURE PROC_CURR_REPORT (
    IN_CURR_ID INTEGER,
    IN_FINANCING_ID INTEGER)
RETURNS (
    Q_0 INTEGER,
    Q_1 INTEGER,
    Q_2 INTEGER,
    Q_3 INTEGER,
    Q_4 INTEGER,
    Q_5 INTEGER,
    Q_6 INTEGER,
    Q_7 INTEGER,
    Q_8 INTEGER,
    Q_ALL_Y INTEGER,
    Q_ALL_O INTEGER,
    Q_ALL_C INTEGER,
    Q_V_Y INTEGER,
    Q_V_O INTEGER,
    Q_V_C INTEGER,
    T_V_0 DOUBLE PRECISION,
    T_V_1 DOUBLE PRECISION,
    T_V_2 DOUBLE PRECISION,
    T_V_3 DOUBLE PRECISION,
    T_V_4 DOUBLE PRECISION,
    T_V_5 DOUBLE PRECISION,
    T_V_6 DOUBLE PRECISION,
    T_V_7 DOUBLE PRECISION,
    T_V_8 DOUBLE PRECISION,
    T_0 DOUBLE PRECISION,
    T_1 DOUBLE PRECISION,
    T_2 DOUBLE PRECISION,
    T_3 DOUBLE PRECISION,
    T_4 DOUBLE PRECISION,
    T_5 DOUBLE PRECISION,
    T_6 DOUBLE PRECISION,
    T_7 DOUBLE PRECISION,
    T_8 DOUBLE PRECISION,
    T_A_Y DOUBLE PRECISION,
    T_A_O DOUBLE PRECISION,
    T_A_C DOUBLE PRECISION,
    T_V_Y DOUBLE PRECISION,
    T_V_O DOUBLE PRECISION,
    T_V_C DOUBLE PRECISION,
    G_Y INTEGER,
    G_O INTEGER)
AS
begin
  select max(qty_0), max(qty_1), max(qty_2), max(qty_3), max(qty_4),
    max(qty_5), max(qty_6), max(qty_7), max(qty_8), max(qty_y),
    max(qty_o), max(qty_c), max(qty_v_y), max(qty_v_o), max(qty_v_c)
  from proc_curr_rec_report(:in_curr_id, :in_financing_id) PCRR
  where PCRR.group_qty = 1
  into :q_0, :q_1, :q_2, :q_3, :q_4, :q_5, :q_6, :q_7, :q_8,
    :q_all_y, :q_all_o, :q_all_c, :q_v_y, :q_v_o, :q_v_c;

  select
    sum(PCRR.t_0), sum(PCRR.t_1), sum(PCRR.t_2), sum(PCRR.t_3), sum(PCRR.t_4),
    sum(PCRR.t_5), sum(PCRR.t_6), sum(PCRR.t_7), sum(PCRR.t_8),
    sum(PCRR.t_v_0), sum(PCRR.t_v_1), sum(PCRR.t_v_2), sum(PCRR.t_v_3), sum(PCRR.t_v_4),
    sum(PCRR.t_v_5), sum(PCRR.t_v_6), sum(PCRR.t_v_7), sum(PCRR.t_v_8),
    sum(PCRR.t_all_y), sum(PCRR.t_all_o), sum(PCRR.t_all_c),
    sum(PCRR.t_v_y), sum(PCRR.t_v_o), sum(PCRR.t_v_c),
    sum(PCRR.g_qty_y), sum(PCRR.g_qty_o)
  from proc_curr_rec_report(:in_curr_id, :in_financing_id) PCRR
  into :t_0, :t_1, :t_2, :t_3, :t_4, :t_5, :t_6, :t_7, :t_8,
    :t_v_0, :t_v_1, :t_v_2, :t_v_3, :t_v_4, :t_v_5, :t_v_6, :t_v_7, :t_v_8,
    :t_a_y, :t_a_o, :t_a_c, :t_v_y, :t_v_o, :t_v_c, :g_y, :g_o;

  suspend;
end^


ALTER PROCEDURE PROC_EXTRACT_ALL_GROUP (
    IN_GROUPING_ID INTEGER)
AS
DECLARE VARIABLE GROUPING_ID INTEGER;
DECLARE VARIABLE TEACHER_ID INTEGER;
DECLARE VARIABLE GR_SBJ_ID INTEGER;
DECLARE VARIABLE TMP INTEGER;
begin
  /* Procedure Text */ /*$$IBE$$ 
  delete from teacher_group TG
  where TG.grouping_id = :in_grouping_id and TG.teacher_id not in
    (select DISTINCT STP."TeacherID"
     from "Student_Plan" STP join "Student" S on STP."StudentID" = S.id and
         S."ReleaseDate" is null and
         (S."AcademyBDate" is null or S."AcademyEDate" is not null)
       join "Specialization" SP on SP.id = S."SpecializationID"
       join "Department" D on D.id = SP."DepartmentID"
       join "Curriculum_Record" CR on CR."CurriculumID" = D."CurriculumID" and
         CR."Num" = STP.id
     where
       STP."Use" > 0 and STP."TeacherID" is not null and
       (case S."Class"
        when 0 then CR."Time0"
        when 1 then CR."Time1"
        when 2 then CR."Time2"
        when 3 then CR."Time3"
        when 4 then CR."Time4"
        when 5 then CR."Time5"
        when 6 then CR."Time6"
        when 7 then CR."Time7"
        when 8 then CR."Time8"
        end) > 0 and
       CR."Group" > 1 and D.id in
        (select GD.department_id from grouping_dept GD
         where GD.grouping_id = TG.grouping_id));
  for
    select DISTINCT G.ID, STP."TeacherID"
    from grouping G, "Student_Plan" STP
      join "Student" S on STP."StudentID" = S.id and S."ReleaseDate" is null and
        (S."AcademyBDate" is null or (S."AcademyEDate" is not null))
      join "Specialization" SP on SP.id = S."SpecializationID"
      join "Department" D on D.id = SP."DepartmentID"
      join "Curriculum_Record" CR on CR."CurriculumID" = D."CurriculumID" and
         CR."Num" = STP.id
    where G.id = :in_grouping_id and
      STP."Use" > 0 and STP."TeacherID" is not null and
       (case S."Class"
        when 0 then CR."Time0"
        when 1 then CR."Time1"
        when 2 then CR."Time2"
        when 3 then CR."Time3"
        when 4 then CR."Time4"
        when 5 then CR."Time5"
        when 6 then CR."Time6"
        when 7 then CR."Time7"
        when 8 then CR."Time8"
        end) > 0 and
      CR."Group" > 1 and D.id in
      (select GD.department_id from grouping_dept GD where GD.grouping_id = G.id)
    into :grouping_id, :teacher_id
  do
  begin
    tmp = null;
    select DISTINCT TG.teacher_id
    from teacher_group TG
    where TG.grouping_id = :grouping_id and TG.teacher_id = :teacher_id
    into :tmp;

    if (:tmp is null)
    then
      for
        select GS.id
        from grouping_subj GS
        where GS.grouping_id = :grouping_id
        into :gr_sbj_id
      do
        insert into teacher_group
        values (:grouping_id, :teacher_id, :gr_sbj_id, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    else
      insert into teacher_group
      select :grouping_id, :teacher_id, GS.id, 0, 0, 0, 0, 0, 0, 0, 0, 0
      from grouping_subj GS
      where GS.grouping_id = :grouping_id and
        GS.id not in
        (select distinct tg.gr_subj_id from teacher_group TG
         where TG.grouping_id = :grouping_id and TG.teacher_id = :teacher_id);
  end
 $$IBE$$*/ EXIT;
end^


ALTER PROCEDURE PROC_EXTRACT_GR_SUBJECTS (
    IN_GROUPIND_ID INTEGER)
AS
DECLARE VARIABLE TMP_SBJ_ID INTEGER;
DECLARE VARIABLE TMP_GROUP SMALLINT;
DECLARE VARIABLE TMP_CURR_ID INTEGER;
DECLARE VARIABLE TMP_CURR_REC_ID INTEGER;
DECLARE VARIABLE TMP INTEGER;
DECLARE VARIABLE TMP_SBJ_CODE INTEGER;
DECLARE VARIABLE TMP_ID INTEGER;
DECLARE VARIABLE ID INTEGER;
DECLARE VARIABLE ADDED INTEGER;
DECLARE VARIABLE PRE_ID INTEGER;
DECLARE VARIABLE TMP_SUBJ_NAME VARCHAR(30) CHARACTER SET WIN1251;
begin

  delete from grouping_subj_curr_id where GROUPING_ID = :in_groupind_id;
  id = 0;

  for select distinct D."CurriculumID"
      from grouping_dept GD
        join "Department" D on GD.department_id = D.id and
          GD.grouping_id = :in_groupind_id
      into :tmp_curr_id do
  begin
    tmp = 0;
    added = 0;
    for select distinct CR."ID", CR.subject_id,  S."Code", CR.group_qty, S."Name"
      from curr_rec CR join "Subject" S on S.id = CR.subject_id and CR.curr_id = :tmp_curr_id
      where CR.group_qty > 1
      order by CR.num
      into :tmp_curr_rec_id, :tmp_sbj_id, :tmp_sbj_code, :tmp_group, :tmp_subj_name do
    begin
      if (:tmp_sbj_code = 1) then
        if (:added = 1) then
        begin
          /*added = 0;*/
          id = id + 1;
          select GS.id from grouping_subj GS
          where grouping_id = :in_groupind_id and GS.id = :id
          into :tmp;

          if (id = tmp) then
            update grouping_subj GS set
              GS.name = :tmp_subj_name,
              GS.code = :tmp_sbj_code,
              GS.group_qty = :tmp_group
            where GS.grouping_id = :in_groupind_id and GS.id = :id;
          else
            execute procedure add_grouping_subj(:in_groupind_id, null, :tmp_subj_name, 
:tmp_sbj_code, :tmp_group, null)
            returning_values :id;
        end
        else
        begin
          tmp = pre_id + 1;
        end
      else
      begin
        tmp = null;
        added = 0;

        select distinct GS.id
        from grouping_subj GS
          join grouping_subj_curr_id GSCI on GS.grouping_id = GSCI.grouping_id and
            GS.id = GSCI.grouping_subj_id and GS.grouping_id = :in_groupind_id
          join curr_rec CR on GSCI.curr_id = CR.curr_id and GSCI.curr_rec_id = CR.id
            and CR.subject_id = :tmp_sbj_id
          join "Subject" S on S.id = CR.subject_id and S."Code" <> 1
        where
          GS.id < :id
        into :tmp;

        if (:tmp is null) then
        begin
          added = 1;
          id = id + 1;
          select GS.id from grouping_subj GS
          where grouping_id = :in_groupind_id and GS.id = :id
          into :tmp_id;
          if (id = tmp_id) then
            update grouping_subj GS set
              GS.name = :tmp_subj_name,
              GS.group_qty = :tmp_group,
              GS.code = :tmp_sbj_code
            where GS.grouping_id = :in_groupind_id and GS.id = :id;
          else
            execute procedure add_grouping_subj(:in_groupind_id, null, :tmp_subj_name, 
:tmp_sbj_code, :tmp_group, null)
            returning_values :id;
          pre_id = id;
        end
        else
          pre_id = tmp;
      end
      if (:tmp is null) then
      begin
        insert into grouping_subj_curr_id
        values (:in_groupind_id, :id, :tmp_curr_id, :tmp_curr_rec_id);
      end
      else
        insert into grouping_subj_curr_id
        values (:in_groupind_id, :tmp, :tmp_curr_id, :tmp_curr_rec_id);
    end
  end
delete from grouping_subj GS
where GS.grouping_id = :in_groupind_id and GS.id > :id;
end^


ALTER PROCEDURE PROC_FILL_TEACHER_TM
RETURNS (
    TEACHER_ID INTEGER,
    FINANCING_ID INTEGER,
    YTIME DOUBLE PRECISION,
    OTIME DOUBLE PRECISION,
    CTIME DOUBLE PRECISION)
AS
DECLARE VARIABLE T_ID INTEGER;
DECLARE VARIABLE F_ID INTEGER;
begin /*$$IBE$$ 
  delete from teacher_tm;
  for select T.id, F.id
    from "Teacher" T, "Financing" F
    into :t_id, :f_id
  do
  begin
    insert into teacher_tm
      select :t_id, :f_id, PTM.outytime, PTM.outotime, PTM.outctime,
        PTM.outypay, PTM.outopay, PTM.outcpay, PTM.outsumtime, PTM.outsumpay
      from proc_teacher_tm(:t_id, :f_id) PTM;
  end
 $$IBE$$*/ EXIT;
end^


ALTER PROCEDURE PROC_FOR_STUDENT_FILTER (
    ID_FILTER INTEGER)
RETURNS (
    STUDENTID INTEGER)
AS
DECLARE VARIABLE IN_SUBJECT_ID_1 INTEGER;
DECLARE VARIABLE IN_SUBJECT_ID_2 INTEGER;
DECLARE VARIABLE IN_TEACHER_ID_1 INTEGER;
DECLARE VARIABLE IN_TEACHER_ID_2 INTEGER;
DECLARE VARIABLE SUBJSTATE INTEGER;
begin
  /* процедура по SubjectID, TeacherID и SubjState возвращает ID студентов*/ 
  SELECT SF.SUBJECT_ID_1, SF.SUBJECT_ID_2, SF.TEACHER_ID_1, SF.TEACHER_ID_2, SF.SUBJ_STATE
  FROM STUDENT_FILTER SF
  WHERE SF.ID = :ID_FILTER
  INTO :IN_SUBJECT_ID_1, :IN_SUBJECT_ID_2, :IN_TEACHER_ID_1, :IN_TEACHER_ID_2, :SUBJSTATE;

  IF (:IN_SUBJECT_ID_1 IS NULL AND :IN_SUBJECT_ID_2 IS NULL AND :IN_TEACHER_ID_1 IS NULL AND :IN_TEACHER_ID_2 IS NULL) THEN
    FOR SELECT ID FROM "Student" ORDER BY ID INTO :studentid DO SUSPEND;
  ELSE
  BEGIN
  if (((:in_subject_id_1 is not null or :in_teacher_id_1 is not null) and
       :in_subject_id_2 is null and :in_teacher_id_2 is null)) then
   for select distinct S.id
    from "Student" S
      join "Specialization" SP on S."SpecializationID" = SP.id
      join "Department" D on D.id = SP."DepartmentID"
      join curr_rec CR on CR.curr_id = D."CurriculumID"
      join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id and
        CRT.class_num = S."Class" and CRT.c_time > 0
      join "Student_Plan" STP on S.id = STP."StudentID" and CR.id = STP.curr_rec_id
    where
      (:in_teacher_id_1 is null or STP."TeacherID" = :in_teacher_id_1) and
      (:in_subject_id_1 is null or CR.subject_id = :in_subject_id_1) and
      (  :subjstate is null or
        (:subjstate = 0 and STP."Use" > 0) or/*распределенные*/
        (:subjstate = 1 and STP."Use" = 0) /*нераспределенные*/
      )
    into :studentid
    do suspend;
  else if (((:in_subject_id_2 is not null or :in_teacher_id_2 is not null) and
       :in_subject_id_1 is null and :in_teacher_id_1 is null)) then
   for select distinct S.id
    from "Student" S
      join "Specialization" SP on S."SpecializationID" = SP.id
      join "Department" D on D.id = SP."DepartmentID"
      join curr_rec CR on CR.curr_id = D."CurriculumID"
      join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id and
        CRT.class_num = S."Class" and CRT.c_time > 0
      join "Student_Plan" STP on S.id = STP."StudentID" and CR.id = STP.curr_rec_id
    where
      (:in_teacher_id_2 is null or STP."TeacherID" = :in_teacher_id_2) and
      (:in_subject_id_2 is null or CR.subject_id = :in_subject_id_2) and
      (  :subjstate is null or
        (:subjstate = 0 and STP."Use" > 0) or/*распределенные*/
        (:subjstate = 1 and STP."Use" = 0) /*нераспределенные*/
      )
    into :studentid
    do suspend;
  else
    for select distinct S.id
    from "Student" S
      join "Specialization" SP on S."SpecializationID" = SP.id
      join "Department" D on D.id = SP."DepartmentID"
      join curr_rec CR on CR.curr_id = D."CurriculumID"
      join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id and
        CRT.class_num = S."Class" and CRT.c_time > 0
      join "Student_Plan" STP on S.id = STP."StudentID" and CR.id = STP.curr_rec_id
      join curr_rec CR2 on CR2.curr_id = D."CurriculumID"
      join curr_rec_time CRT2 on CRT2.curr_id = CR2.curr_id and CRT2.curr_rec_id = CR2.id and
        CRT2.class_num = S."Class" and CRT2.c_time > 0
      join "Student_Plan" STP2 on S.id = STP2."StudentID" and CR2.id = STP2.curr_rec_id
    where
      (STP."TeacherID" = :in_teacher_id_1 or :in_teacher_id_1 is null) and
      (CR.subject_id = :in_subject_id_1 or :in_subject_id_1 is null) and
      (STP2."TeacherID" = :in_teacher_id_2 or :in_teacher_id_2 is null) and
      (CR2.subject_id = :in_subject_id_2 or :in_subject_id_2 is null) and
      (  :subjstate is null or
        (:subjstate = 0 and STP."Use" > 0 and STP2."Use" > 0) or/*распределенные*/
        (:subjstate = 1 and STP."Use" = 0 and STP2."Use" = 0) /*нераспределенные*/
      )
    into :studentid
    do suspend;
  END
end^


ALTER PROCEDURE PROC_GET_TEACHER_GROUP_W_ST_QTY (
    IN_GROUPING_ID INTEGER,
    IN_TEACHER_ID INTEGER,
    IN_GR_SUBJ_ID INTEGER)
RETURNS (
    GROUPING_ID INTEGER,
    GR_SUBJ_ID INTEGER,
    GR_SUBJ_NAME VARCHAR(30),
    GR_SUBJ_CODE INTEGER,
    GR_QTY INTEGER,
    G_QTY_0 INTEGER,
    G_QTY_1 INTEGER,
    G_QTY_2 INTEGER,
    G_QTY_3 INTEGER,
    G_QTY_4 INTEGER,
    G_QTY_5 INTEGER,
    G_QTY_6 INTEGER,
    G_QTY_7 INTEGER,
    G_QTY_8 INTEGER,
    S_QTY_0 INTEGER,
    S_QTY_1 INTEGER,
    S_QTY_2 INTEGER,
    S_QTY_3 INTEGER,
    S_QTY_4 INTEGER,
    S_QTY_5 INTEGER,
    S_QTY_6 INTEGER,
    S_QTY_7 INTEGER,
    S_QTY_8 INTEGER,
    TEACHER_ID INTEGER)
AS
begin
  grouping_id = :in_grouping_id;
  teacher_id = :in_teacher_id;
  for
    select GS.id, GS.name, GS.code, GS.group_qty
    from grouping_subj GS
    where GS.grouping_id = :in_grouping_id and
      (:in_gr_subj_id is null or GS.id = :in_gr_subj_id)
    order by GS.Pos
    into :gr_subj_id, :gr_subj_name, :gr_subj_code, :gr_qty
  do
  begin
    select
      sum(case TG.class_num when 0 then TG.group_q else null end),
      sum(case TG.class_num when 1 then TG.group_q else null end),
      sum(case TG.class_num when 2 then TG.group_q else null end),
      sum(case TG.class_num when 3 then TG.group_q else null end),
      sum(case TG.class_num when 4 then TG.group_q else null end),
      sum(case TG.class_num when 5 then TG.group_q else null end),
      sum(case TG.class_num when 6 then TG.group_q else null end),
      sum(case TG.class_num when 7 then TG.group_q else null end),
      sum(case TG.class_num when 8 then TG.group_q else null end)
    from teacher_group TG join "Teacher" T on TG.teacher_id = T.id and
      T.id = :in_teacher_id
    where TG.grouping_id = :in_grouping_id and TG.gr_subj_id = :gr_subj_id
    into :g_qty_0, :g_qty_1, :g_qty_2, :g_qty_3, :g_qty_4, :g_qty_5, :g_qty_6,
      :g_qty_7, :g_qty_8;

    select
      sum(case S."Class" when 0 then (case coalesce(CRT.c_time, 0) when 0 then null else 1 end) 
else null end),
      sum(case S."Class" when 1 then (case coalesce(CRT.c_time, 0) when 0 then null else 1 end) 
else null end),
      sum(case S."Class" when 2 then (case coalesce(CRT.c_time, 0) when 0 then null else 1 end) 
else null end),
      sum(case S."Class" when 3 then (case coalesce(CRT.c_time, 0) when 0 then null else 1 end) 
else null end),
      sum(case S."Class" when 4 then (case coalesce(CRT.c_time, 0) when 0 then null else 1 end) 
else null end),
      sum(case S."Class" when 5 then (case coalesce(CRT.c_time, 0) when 0 then null else 1 end) 
else null end),
      sum(case S."Class" when 6 then (case coalesce(CRT.c_time, 0) when 0 then null else 1 end) 
else null end),
      sum(case S."Class" when 7 then (case coalesce(CRT.c_time, 0) when 0 then null else 1 end) 
else null end),
      sum(case S."Class" when 8 then (case coalesce(CRT.c_time, 0) when 0 then null else 1 end) 
else null end)
    from  "Student" S
      join "Student_Plan" STP on S.id = STP."StudentID" and
        STP."TeacherID" = :in_teacher_id and STP."Use" > 0 and
        S.released = 0 and S.academy = 0
      join "Specialization" SP on SP.ID = S."SpecializationID"
      join "Department" D on D.id = SP."DepartmentID"
      join curriculum C on C.id = D."CurriculumID"
      join curr_rec_time CRT on CRT.curr_id = C.id and CRT.curr_rec_id = STP.curr_rec_id
        and CRT.class_num = S."Class" and CRT.c_time > 0
      join grouping_subj_curr_id GSCI on
        GSCI.grouping_id = :in_grouping_id and GSCI.grouping_subj_id = :gr_subj_id and
        C.id = GSCI.curr_id and STP.curr_rec_id = GSCI.curr_rec_id
      join grouping G on G.id = :in_grouping_id and G.financing_id = S."FinancingID"
    into :s_qty_0, :s_qty_1, :s_qty_2, :s_qty_3, :s_qty_4, :s_qty_5,
      :s_qty_6, :s_qty_7, :s_qty_8;
    suspend;
  end
end^


ALTER PROCEDURE PROC_LTG_REPORT (
    IN_LTG_ID INTEGER)
RETURNS (
    Q_0 INTEGER,
    Q_1 INTEGER,
    Q_2 INTEGER,
    Q_3 INTEGER,
    Q_4 INTEGER,
    Q_5 INTEGER,
    Q_6 INTEGER,
    Q_7 INTEGER,
    Q_8 INTEGER,
    Q_ALL_Y INTEGER,
    Q_ALL_O INTEGER,
    Q_ALL_C INTEGER,
    Q_V_Y INTEGER,
    Q_V_O INTEGER,
    Q_V_C INTEGER,
    T_V_0 DOUBLE PRECISION,
    T_V_1 DOUBLE PRECISION,
    T_V_2 DOUBLE PRECISION,
    T_V_3 DOUBLE PRECISION,
    T_V_4 DOUBLE PRECISION,
    T_V_5 DOUBLE PRECISION,
    T_V_6 DOUBLE PRECISION,
    T_V_7 DOUBLE PRECISION,
    T_V_8 DOUBLE PRECISION,
    T_0 DOUBLE PRECISION,
    T_1 DOUBLE PRECISION,
    T_2 DOUBLE PRECISION,
    T_3 DOUBLE PRECISION,
    T_4 DOUBLE PRECISION,
    T_5 DOUBLE PRECISION,
    T_6 DOUBLE PRECISION,
    T_7 DOUBLE PRECISION,
    T_8 DOUBLE PRECISION,
    T_A_Y DOUBLE PRECISION,
    T_A_O DOUBLE PRECISION,
    T_A_C DOUBLE PRECISION,
    T_V_Y DOUBLE PRECISION,
    T_V_O DOUBLE PRECISION,
    T_V_C DOUBLE PRECISION,
    G_Y INTEGER,
    G_O INTEGER)
AS
DECLARE VARIABLE I_T_0 DOUBLE PRECISION;
DECLARE VARIABLE I_T_1 DOUBLE PRECISION;
DECLARE VARIABLE I_T_2 DOUBLE PRECISION;
DECLARE VARIABLE I_T_3 DOUBLE PRECISION;
DECLARE VARIABLE I_T_4 DOUBLE PRECISION;
DECLARE VARIABLE I_T_5 DOUBLE PRECISION;
DECLARE VARIABLE I_T_6 DOUBLE PRECISION;
DECLARE VARIABLE I_T_7 DOUBLE PRECISION;
DECLARE VARIABLE I_T_8 DOUBLE PRECISION;
DECLARE VARIABLE I_T_V_0 DOUBLE PRECISION;
DECLARE VARIABLE I_T_V_1 DOUBLE PRECISION;
DECLARE VARIABLE I_T_V_2 DOUBLE PRECISION;
DECLARE VARIABLE I_T_V_3 DOUBLE PRECISION;
DECLARE VARIABLE I_T_V_4 DOUBLE PRECISION;
DECLARE VARIABLE I_T_V_5 DOUBLE PRECISION;
DECLARE VARIABLE I_T_V_6 DOUBLE PRECISION;
DECLARE VARIABLE I_T_V_7 DOUBLE PRECISION;
DECLARE VARIABLE I_T_V_8 DOUBLE PRECISION;
DECLARE VARIABLE I_T_A_Y DOUBLE PRECISION;
DECLARE VARIABLE I_T_A_O DOUBLE PRECISION;
DECLARE VARIABLE I_T_A_C DOUBLE PRECISION;
DECLARE VARIABLE I_T_V_Y DOUBLE PRECISION;
DECLARE VARIABLE I_T_V_O DOUBLE PRECISION;
DECLARE VARIABLE I_T_V_C DOUBLE PRECISION;
DECLARE VARIABLE G_T_0 DOUBLE PRECISION;
DECLARE VARIABLE G_T_1 DOUBLE PRECISION;
DECLARE VARIABLE G_T_2 DOUBLE PRECISION;
DECLARE VARIABLE G_T_3 DOUBLE PRECISION;
DECLARE VARIABLE G_T_4 DOUBLE PRECISION;
DECLARE VARIABLE G_T_5 DOUBLE PRECISION;
DECLARE VARIABLE G_T_6 DOUBLE PRECISION;
DECLARE VARIABLE G_T_7 DOUBLE PRECISION;
DECLARE VARIABLE G_T_8 DOUBLE PRECISION;
DECLARE VARIABLE G_T_V_0 DOUBLE PRECISION;
DECLARE VARIABLE G_T_V_1 DOUBLE PRECISION;
DECLARE VARIABLE G_T_V_2 DOUBLE PRECISION;
DECLARE VARIABLE G_T_V_3 DOUBLE PRECISION;
DECLARE VARIABLE G_T_V_4 DOUBLE PRECISION;
DECLARE VARIABLE G_T_V_5 DOUBLE PRECISION;
DECLARE VARIABLE G_T_V_6 DOUBLE PRECISION;
DECLARE VARIABLE G_T_V_7 DOUBLE PRECISION;
DECLARE VARIABLE G_T_V_8 DOUBLE PRECISION;
DECLARE VARIABLE G_T_A_Y DOUBLE PRECISION;
DECLARE VARIABLE G_T_A_O DOUBLE PRECISION;
DECLARE VARIABLE G_T_A_C DOUBLE PRECISION;
DECLARE VARIABLE G_T_V_Y DOUBLE PRECISION;
DECLARE VARIABLE G_T_V_O DOUBLE PRECISION;
DECLARE VARIABLE G_T_V_C DOUBLE PRECISION;
begin
  select
    sum(case S."Class" when 0 then 1 else null end),
    sum(case S."Class" when 1 then 1 else null end),
    sum(case S."Class" when 2 then 1 else null end),
    sum(case S."Class" when 3 then 1 else null end),
    sum(case S."Class" when 4 then 1 else null end),
    sum(case S."Class" when 5 then 1 else null end),
    sum(case S."Class" when 6 then 1 else null end),
    sum(case S."Class" when 7 then 1 else null end),
    sum(case S."Class" when 8 then 1 else null end),
    sum(case when (STCC.category = 0) then 1 else null end),
    sum(case when (STCC.category = 1) then 1 else null end)
  from "Student" S
    join "Specialization" STSP on S."SpecializationID" = STSP.id
    join "Department" STD on STD.id = STSP."DepartmentID"
    join curr_cat STCC on STCC.curr_id = STD."CurriculumID" and
      STCC.class_num = S."Class"
  where (S.released = 0) and (S.academy = 0) and STSP.id in (
    select SP.id
    from learn_time_grid LTG
      join ltg_i_subject LTGIS on LTG.id = :in_ltg_id and LTGIS.ltg_id = :in_ltg_id
      join ltg_i_subj_curr LISC on LISC.ltg_id = :in_ltg_id and LISC.ltg_i_subj_id = LTGIS.id
      join "Department" D on LISC.curr_id = D."CurriculumID"
      join "Specialization" SP on SP."DepartmentID" = D.id
    )
  into :q_0, :q_1, :q_2, :q_3, :q_4, :q_5, :q_6, :q_7, :q_8, :q_all_y, :q_all_o;
  q_all_c = nullif(coalesce(q_all_y, 0) + coalesce(q_all_o, 0), 0);
  q_v_y = q_all_y; q_v_o = q_all_o; q_v_c = q_all_c;

  select
    sum(PLRRG.t_0), sum(PLRRG.t_1), sum(PLRRG.t_2), sum(PLRRG.t_3), sum(PLRRG.t_4),
    sum(PLRRG.t_5), sum(PLRRG.t_6), sum(PLRRG.t_7), sum(PLRRG.t_8),
    sum(PLRRG.t_v_0), sum(PLRRG.t_v_1), sum(PLRRG.t_v_2), sum(PLRRG.t_v_3), sum(PLRRG.t_v_4),
    sum(PLRRG.t_v_5), sum(PLRRG.t_v_6), sum(PLRRG.t_v_7), sum(PLRRG.t_v_8),
    sum(PLRRG.t_all_y), sum(PLRRG.t_all_o), sum(PLRRG.t_all_c),
    sum(PLRRG.t_v_y), sum(PLRRG.t_v_o), sum(PLRRG.t_v_c),
    sum(PLRRG.g_qty_y), sum(PLRRG.g_qty_o)
  from proc_ltg_report_rec_g(:in_ltg_id) PLRRG
  into :g_t_0, :g_t_1, :g_t_2, :g_t_3, :g_t_4, :g_t_5, :g_t_6, :g_t_7, :g_t_8,
    :g_t_v_0, :g_t_v_1, :g_t_v_2, :g_t_v_3, :g_t_v_4, :g_t_v_5, :g_t_v_6, :g_t_v_7, :g_t_v_8,
    :g_t_a_y, :g_t_a_o, :g_t_a_c, :g_t_v_y, :g_t_v_o, :g_t_v_c, :g_y, :g_o;

  select
    sum(PLRRG.t_0), sum(PLRRG.t_1), sum(PLRRG.t_2), sum(PLRRG.t_3), sum(PLRRG.t_4),
    sum(PLRRG.t_5), sum(PLRRG.t_6), sum(PLRRG.t_7), sum(PLRRG.t_8),
    sum(PLRRG.t_v_0), sum(PLRRG.t_v_1), sum(PLRRG.t_v_2), sum(PLRRG.t_v_3), sum(PLRRG.t_v_4),
    sum(PLRRG.t_v_5), sum(PLRRG.t_v_6), sum(PLRRG.t_v_7), sum(PLRRG.t_v_8),
    sum(PLRRG.t_all_y), sum(PLRRG.t_all_o), sum(PLRRG.t_all_c),
    sum(PLRRG.t_v_y), sum(PLRRG.t_v_o), sum(PLRRG.t_v_c)
  from proc_ltg_report_rec_i(:in_ltg_id) PLRRG
  into :i_t_0, :i_t_1, :i_t_2, :i_t_3, :i_t_4, :i_t_5, :i_t_6, :i_t_7, :i_t_8,
    :i_t_v_0, :i_t_v_1, :i_t_v_2, :i_t_v_3, :i_t_v_4, :i_t_v_5, :i_t_v_6, :i_t_v_7, :i_t_v_8,
    :i_t_a_y, :i_t_a_o, :i_t_a_c, :i_t_v_y, :i_t_v_o, :i_t_v_c;

  t_0 = nullif(coalesce(g_t_0, 0) + coalesce(i_t_0, 0), 0);
  t_1 = nullif(coalesce(g_t_1, 0) + coalesce(i_t_1, 0), 0);
  t_2 = nullif(coalesce(g_t_2, 0) + coalesce(i_t_2, 0), 0);
  t_3 = nullif(coalesce(g_t_3, 0) + coalesce(i_t_3, 0), 0);
  t_4 = nullif(coalesce(g_t_4, 0) + coalesce(i_t_4, 0), 0);
  t_5 = nullif(coalesce(g_t_5, 0) + coalesce(i_t_5, 0), 0);
  t_6 = nullif(coalesce(g_t_6, 0) + coalesce(i_t_6, 0), 0);
  t_7 = nullif(coalesce(g_t_7, 0) + coalesce(i_t_7, 0), 0);
  t_8 = nullif(coalesce(g_t_8, 0) + coalesce(i_t_8, 0), 0);
  t_v_0 = nullif(coalesce(g_t_v_0, 0) + coalesce(i_t_v_0, 0), 0);
  t_v_1 = nullif(coalesce(g_t_v_1, 0) + coalesce(i_t_v_1, 0), 0);
  t_v_2 = nullif(coalesce(g_t_v_2, 0) + coalesce(i_t_v_2, 0), 0);
  t_v_3 = nullif(coalesce(g_t_v_3, 0) + coalesce(i_t_v_3, 0), 0);
  t_v_4 = nullif(coalesce(g_t_v_4, 0) + coalesce(i_t_v_4, 0), 0);
  t_v_5 = nullif(coalesce(g_t_v_5, 0) + coalesce(i_t_v_5, 0), 0);
  t_v_6 = nullif(coalesce(g_t_v_6, 0) + coalesce(i_t_v_6, 0), 0);
  t_v_7 = nullif(coalesce(g_t_v_7, 0) + coalesce(i_t_v_7, 0), 0);
  t_v_8 = nullif(coalesce(g_t_v_8, 0) + coalesce(i_t_v_8, 0), 0);
  t_a_y = nullif(coalesce(g_t_a_y, 0) + coalesce(i_t_a_y, 0), 0);
  t_a_o = nullif(coalesce(g_t_a_o, 0) + coalesce(i_t_a_o, 0), 0);
  t_a_c = nullif(coalesce(g_t_a_c, 0) + coalesce(i_t_a_c, 0), 0);
  t_v_o = nullif(coalesce(g_t_v_o, 0) + coalesce(i_t_v_o, 0), 0);
  t_v_y = nullif(coalesce(g_t_v_y, 0) + coalesce(i_t_v_y, 0), 0);
  t_v_c = nullif(coalesce(g_t_v_c, 0) + coalesce(i_t_v_c, 0), 0);
  suspend;
end^


ALTER PROCEDURE PROC_LTG_REPORT_REC_G (
    IN_LTG_ID INTEGER)
RETURNS (
    G_SUBJ_ID INTEGER,
    SUBJECT_NAME VARCHAR(30),
    SUBJECT_CODE INTEGER,
    GROUP_QTY INTEGER,
    QTY_0 INTEGER,
    QTY_1 INTEGER,
    QTY_2 INTEGER,
    QTY_3 INTEGER,
    QTY_4 INTEGER,
    QTY_5 INTEGER,
    QTY_6 INTEGER,
    QTY_7 INTEGER,
    QTY_8 INTEGER,
    T_0 DOUBLE PRECISION,
    T_1 DOUBLE PRECISION,
    T_2 DOUBLE PRECISION,
    T_3 DOUBLE PRECISION,
    T_4 DOUBLE PRECISION,
    T_5 DOUBLE PRECISION,
    T_6 DOUBLE PRECISION,
    T_7 DOUBLE PRECISION,
    T_8 DOUBLE PRECISION,
    T_ALL_Y DOUBLE PRECISION,
    T_ALL_O DOUBLE PRECISION,
    T_ALL_C DOUBLE PRECISION,
    T_V_Y DOUBLE PRECISION,
    T_V_O DOUBLE PRECISION,
    T_V_C DOUBLE PRECISION,
    T_V_0 DOUBLE PRECISION,
    T_V_1 DOUBLE PRECISION,
    T_V_2 DOUBLE PRECISION,
    T_V_3 DOUBLE PRECISION,
    T_V_4 DOUBLE PRECISION,
    T_V_5 DOUBLE PRECISION,
    T_V_6 DOUBLE PRECISION,
    T_V_7 DOUBLE PRECISION,
    T_V_8 DOUBLE PRECISION,
    G_QTY_Y INTEGER,
    G_QTY_O INTEGER)
AS
DECLARE VARIABLE GROUPING_ID INTEGER;
begin
  for
    select GS.grouping_id, GS.id, GS.name, GS.code, GS.group_qty
    from ltg_grouping LG
      join grouping_subj GS on LG.ltg_id = :in_ltg_id and GS.grouping_id = LG.grouping_id
    order by GS.grouping_id, GS.pos
    into :grouping_id, :g_subj_id, :subject_name, :subject_code, :group_qty
  do
  begin
    select
      sum(case TG.class_num when 0 then TG.group_q else null end),
      sum(case TG.class_num when 1 then TG.group_q else null end),
      sum(case TG.class_num when 2 then TG.group_q else null end),
      sum(case TG.class_num when 3 then TG.group_q else null end),
      sum(case TG.class_num when 4 then TG.group_q else null end),
      sum(case TG.class_num when 5 then TG.group_q else null end),
      sum(case TG.class_num when 6 then TG.group_q else null end),
      sum(case TG.class_num when 7 then TG.group_q else null end),
      sum(case TG.class_num when 8 then TG.group_q else null end),

      sum(case TG.class_num when 0 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 1 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 2 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 3 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 4 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 5 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 6 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 7 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 8 then TG.group_q*CRT.c_time else null end),
      sum(case when (CC.category = 0 and :subject_code = 0) then TG.group_q*CRT.c_time else 
null end),
      sum(case when (CC.category = 1 and :subject_code = 0) then TG.group_q*CRT.c_time else 
null end),
      sum(case when (:subject_code = 1) then TG.group_q*CRT.c_time else null end),
      sum(case CC.category when 0 then TG.group_q else null end),
      sum(case CC.category when 1 then TG.group_q else null end)
    from teacher_group TG
      join grouping_subj_curr_id GSCI on TG.grouping_id = :grouping_id and
        GSCI.grouping_id = :grouping_id and TG.gr_subj_id = :g_subj_id and
        GSCI.grouping_subj_id = :g_subj_id and TG.group_q > 0
      join curr_rec_time CRT on CRT.curr_id = GSCI.curr_id and
        CRT.curr_rec_id = GSCI.curr_rec_id and CRT.class_num = TG.class_num and
        CRT.c_time > 0
      join curr_cat CC on CC.curr_id = CRT.curr_id and TG.class_num = CC.class_num
    where TG.teacher_id <> 0 and CRT.curr_id in
      (select min(GSCI2.curr_id)
       from grouping_subj_curr_id GSCI2
       where GSCI2.grouping_id = :grouping_id and
         GSCI2.grouping_subj_id = TG.gr_subj_id)
    into :qty_0, :qty_1, :qty_2, :qty_3, :qty_4, :qty_5, :qty_6, :qty_7,  :qty_8,
      :t_0, :t_1, :t_2, :t_3, :t_4, :t_5, :t_6, :t_7, :t_8, :t_all_y, :t_all_o,
      :t_all_c, :g_qty_y, :g_qty_o;

    select
      sum(case TG.class_num when 0 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 1 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 2 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 3 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 4 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 5 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 6 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 7 then TG.group_q*CRT.c_time else null end),
      sum(case TG.class_num when 8 then TG.group_q*CRT.c_time else null end),
      sum(case when (CC.category = 0 and :subject_code = 0)
        then TG.group_q*CRT.c_time else null end),
      sum(case when (CC.category = 1 and :subject_code = 0)
        then TG.group_q*CRT.c_time else null end),
      sum(case when :subject_code = 1 then TG.group_q*CRT.c_time else null end)
    from teacher_group TG
      join grouping_subj_curr_id GSCI on TG.grouping_id = :grouping_id and
        GSCI.grouping_id = :grouping_id and TG.gr_subj_id = :g_subj_id and
        GSCI.grouping_subj_id = :g_subj_id and TG.group_q > 0
      join curr_rec_time CRT on CRT.curr_id = GSCI.curr_id and
        CRT.curr_rec_id = GSCI.curr_rec_id and CRT.class_num = TG.class_num and
        CRT.c_time > 0
      join curr_cat CC on CC.curr_id = CRT.curr_id and TG.class_num = CC.class_num
    where TG.teacher_id = 0 and CRT.curr_id in
      (select min(GSCI2.curr_id)
       from grouping_subj_curr_id GSCI2
       where GSCI2.grouping_id = :grouping_id and
         GSCI2.grouping_subj_id = TG.gr_subj_id)
    into :t_v_0, :t_v_1, :t_v_2, :t_v_3, :t_v_4, :t_v_5, :t_v_6, :t_v_7, :t_v_8,
      :t_v_y, :t_v_o, :t_v_c;
    suspend;
  end
end^


ALTER PROCEDURE PROC_LTG_REPORT_REC_I (
    IN_LTG_ID INTEGER)
RETURNS (
    LTG_SUBJ_ID INTEGER,
    LTG_SUBJ_POS INTEGER,
    SUBJECT_NAME VARCHAR(30),
    SUBJECT_CODE INTEGER,
    GROUP_QTY INTEGER,
    QTY_0 INTEGER,
    QTY_1 INTEGER,
    QTY_2 INTEGER,
    QTY_3 INTEGER,
    QTY_4 INTEGER,
    QTY_5 INTEGER,
    QTY_6 INTEGER,
    QTY_7 INTEGER,
    QTY_8 INTEGER,
    T_0 DOUBLE PRECISION,
    T_1 DOUBLE PRECISION,
    T_2 DOUBLE PRECISION,
    T_3 DOUBLE PRECISION,
    T_4 DOUBLE PRECISION,
    T_5 DOUBLE PRECISION,
    T_6 DOUBLE PRECISION,
    T_7 DOUBLE PRECISION,
    T_8 DOUBLE PRECISION,
    T_ALL_Y DOUBLE PRECISION,
    T_ALL_O DOUBLE PRECISION,
    T_ALL_C DOUBLE PRECISION,
    T_V_Y DOUBLE PRECISION,
    T_V_O DOUBLE PRECISION,
    T_V_C DOUBLE PRECISION,
    QTY_Y INTEGER,
    QTY_O INTEGER,
    QTY_C INTEGER,
    QTY_V_Y INTEGER,
    QTY_V_O INTEGER,
    QTY_V_C INTEGER,
    T_V_0 DOUBLE PRECISION,
    T_V_1 DOUBLE PRECISION,
    T_V_2 DOUBLE PRECISION,
    T_V_3 DOUBLE PRECISION,
    T_V_4 DOUBLE PRECISION,
    T_V_5 DOUBLE PRECISION,
    T_V_6 DOUBLE PRECISION,
    T_V_7 DOUBLE PRECISION,
    T_V_8 DOUBLE PRECISION)
AS
begin
  group_qty = 1;
  for
    select distinct LIS.id, LIS.name, LIS.pos, S."Code"
    from ltg_i_subject LIS
      join ltg_i_subj_curr LISC on
        LIS.ltg_id = :in_ltg_id and LISC.ltg_id = :in_ltg_id and
        LIS.id = LISC.ltg_i_subj_id
      join curr_rec CR on CR.curr_id = LISC.curr_id and CR.id = LISC.curr_rec_id
      join "Subject" S on S.id = CR.subject_id
    order by LIS.pos
    into :ltg_subj_id, :subject_name, :ltg_subj_pos, :subject_code
  do
  begin
    select
      sum(case S."Class" when 0 then 1 else null end) q_0,
      sum(case S."Class" when 1 then 1 else null end) q_1,
      sum(case S."Class" when 2 then 1 else null end) q_2,
      sum(case S."Class" when 3 then 1 else null end) q_3,
      sum(case S."Class" when 4 then 1 else null end) q_4,
      sum(case S."Class" when 5 then 1 else null end) q_5,
      sum(case S."Class" when 6 then 1 else null end) q_6,
      sum(case S."Class" when 7 then 1 else null end) q_7,
      sum(case S."Class" when 8 then 1 else null end) q_8,
      sum(case S."Class" when 0 then CRT.c_time else null end) t_0,
      sum(case S."Class" when 1 then CRT.c_time else null end) t_1,
      sum(case S."Class" when 2 then CRT.c_time else null end) t_2,
      sum(case S."Class" when 3 then CRT.c_time else null end) t_3,
      sum(case S."Class" when 4 then CRT.c_time else null end) t_4,
      sum(case S."Class" when 5 then CRT.c_time else null end) t_5,
      sum(case S."Class" when 6 then CRT.c_time else null end) t_6,
      sum(case S."Class" when 7 then CRT.c_time else null end) t_7,
      sum(case S."Class" when 8 then CRT.c_time else null end) t_8,
      sum(case when (CC.category = 0 and SBJ."Code" = 0) then CRT.c_time else null end) y_t,
      sum(case when (CC.category = 1 and SBJ."Code" = 0) then CRT.c_time else null end) y_t,
      sum(case SBJ."Code" when 1 then CRT.c_time else null end) c_t,
      sum(case CC.category when 0 then 1 else null end),
      sum(case CC.category when 1 then 1 else null end),
      sum(case SBJ."Code" when 1 then 1 else null end)
    from
      ltg_i_subj_curr LISC
      join curr_rec CR on LISC.ltg_id = :in_ltg_id and LISC.ltg_i_subj_id = :ltg_subj_id and
        CR.curr_id = LISC.curr_id and CR.id = LISC.curr_rec_id
      join "Subject" SBJ on SBJ.id = CR.subject_id
      join curr_rec_time CRT on CRT.curr_id = LISC.curr_id and CRT.curr_rec_id = LISC.curr_rec_id
        and CRT.c_time > 0
      join curr_cat CC on CC.curr_id = LISC.curr_id and CRT.class_num = CC.class_num
      join "Department" D on D."CurriculumID" = LISC.curr_id
      join "Specialization" SP on D.id = SP."DepartmentID"
      join "Student" S on S."SpecializationID" = SP.id and S.released = 0 and S.academy = 0 and
        S."Class" = CRT.class_num
      join "Student_Plan" STP on STP."Use" > 0 and STP."StudentID" = S.id and
        STP.curr_rec_id = CR.id and STP."TeacherID" is not null and STP."TeacherID" <> 0
    into :qty_0, :qty_1, :qty_2, :qty_3, :qty_4, :qty_5, :qty_6, :qty_7,  :qty_8,
        :t_0, :t_1, :t_2, :t_3, :t_4, :t_5, :t_6, :t_7, :t_8, :t_all_y, :t_all_o,
        :t_all_c, :qty_y, :qty_o, :qty_c;

    select
      sum(case S."Class" when 0 then CRT.c_time else null end) t_0,
      sum(case S."Class" when 1 then CRT.c_time else null end) t_1,
      sum(case S."Class" when 2 then CRT.c_time else null end) t_2,
      sum(case S."Class" when 3 then CRT.c_time else null end) t_3,
      sum(case S."Class" when 4 then CRT.c_time else null end) t_4,
      sum(case S."Class" when 5 then CRT.c_time else null end) t_5,
      sum(case S."Class" when 6 then CRT.c_time else null end) t_6,
      sum(case S."Class" when 7 then CRT.c_time else null end) t_7,
      sum(case S."Class" when 8 then CRT.c_time else null end) t_8,
      sum(case when (CC.category = 0 and SBJ."Code" = 0) then CRT.c_time else null end) y_t,
      sum(case when (CC.category = 1 and SBJ."Code" = 0) then CRT.c_time else null end) y_t,
      sum(case SBJ."Code" when 1 then CRT.c_time else null end) c_t,
      sum(case CC.category when 0 then 1 else null end),
      sum(case CC.category when 1 then 1 else null end),
      sum(case SBJ."Code" when 1 then 1 else null end)
    from
      ltg_i_subj_curr LISC
      join curr_rec CR on CR.curr_id = LISC.curr_id and CR.id = LISC.curr_rec_id and
        LISC.ltg_id = :in_ltg_id and LISC.ltg_i_subj_id = :ltg_subj_id
      join "Subject" SBJ on SBJ.id = CR.subject_id
      join curr_rec_time CRT on CRT.curr_id = LISC.curr_id and CRT.curr_rec_id = LISC.curr_rec_id
        and CRT.c_time > 0
      join curr_cat CC on CC.curr_id = LISC.curr_id and CRT.class_num = CC.class_num
      join "Department" D on D."CurriculumID" = LISC.curr_id
      join "Specialization" SP on D.id = SP."DepartmentID"
      join "Student" S on S."SpecializationID" = SP.id and S.released = 0 and S.academy = 0 and
        S."Class" = CRT.class_num
      join "Student_Plan" STP on STP."Use" > 0 and STP."StudentID" = S.id and
        STP.curr_rec_id = CR.id and STP."TeacherID" = 0
    into :t_v_0, :t_v_1, :t_v_2, :t_v_3, :t_v_4, :t_v_5, :t_v_6, :t_v_7, :t_v_8,
      :t_v_y, :t_v_o, :t_v_c, :qty_v_y, :qty_v_o, :qty_v_c;
    suspend;
  end
end^


ALTER PROCEDURE PROC_MAIN_TAB (
    DAYS_QTY INTEGER)
AS
declare variable T_ID integer;
declare variable T_NAME varchar(50);
declare variable B_Y_TIME double precision;
declare variable B_O_TIME double precision;
declare variable B_C_TIME double precision;
declare variable S_Y_TIME double precision;
declare variable S_O_TIME double precision;
declare variable S_C_TIME double precision;
declare variable T_TAB_NUM integer;
declare variable t_mt_it integer;
begin
  /*  */
  delete from main_tab mt
  where mt.teacher_id not in (
    select T.id
    from "Teacher" T
    where T."ReleaseDate" is null
  );
  for
    select T.id, substr(T."Name", 1, 30), T.tab_num, mt.teacher_id
    from "Teacher" T
      left join main_tab mt on mt.teacher_id = t.id
    where T."ReleaseDate" is null
    into :T_ID, :T_NAME, :t_tab_num, :t_mt_it
  do
  begin
    select PTT.outytime, PTT.outotime, PTT.outctime
    from proc_teacher_tm(:T_ID, 0) PTT
    into :b_y_time, :b_o_time, :b_c_time;

    select PTT.outytime, PTT.outotime, PTT.outctime
    from proc_teacher_tm(:T_ID, 1) PTT
    into :s_y_time, :s_o_time, :s_c_time;

    if (:t_mt_it is not null) then
    begin
      update main_tab mt
      set
        mt.tab_num =      :t_tab_num,
        mt.teacher_name = :t_name,
        mt.days_qty =     :DAYS_QTY,
        mt.b_y_time =     :b_y_time*4,
        mt.b_o_time =     :b_o_time*4,
        mt.b_c_time =     :b_c_time*4,
        mt.s_y_time =     :s_y_time*4,
        mt.s_o_time =     :s_o_time*4,
        mt.s_c_time =     :s_c_time*4,
        mt.t_date   =     current_date
      where mt.teacher_id = :t_id;
    end
    else
    begin
      insert into main_tab (teacher_id, tab_num, teacher_name, days_qty, b_y_time, b_o_time, b_c_time, s_y_time, s_o_time, s_c_time, t_date)
      values (:t_id, :t_tab_num, :t_name, :days_qty, :b_y_time*4, :b_o_time*4, :b_c_time*4, :s_y_time*4, :s_o_time*4, :s_c_time*4, current_date);
    end
  end
end^


ALTER PROCEDURE PROC_NEW_TARIFFICATION (
    IN_INFO VARCHAR(50))
RETURNS (
    OUT_DATE TIMESTAMP)
AS
declare variable T_ID integer;
declare variable T_NAME varchar(50);
declare variable T_SUBJ_NAME varchar(30);
declare variable T_POST_NAME varchar(30);
declare variable T_ED_NAME varchar(30);
declare variable T_DIPLOMA varchar(256);
declare variable T_STAGE_D smallint;
declare variable T_STAGE_M smallint;
declare variable T_STAGE_Y smallint;
declare variable T_MAIN_SALARY smallint;
declare variable T_CONCERT_SALARY smallint;
declare variable T_SUM_ADDINGS double precision;
declare variable COEF_Y_TIME double precision;
declare variable COEF_O_TIME double precision;
declare variable COEF_C_TIME double precision;
declare variable DOC_DATE timestamp;
declare variable B_Y_TIME double precision;
declare variable B_O_TIME double precision;
declare variable B_C_TIME double precision;
declare variable S_Y_TIME double precision;
declare variable S_O_TIME double precision;
declare variable S_C_TIME double precision;
declare variable SYS_DATE date;
declare variable T_ENTER_DATE date;
declare variable T_STAGE_DATE date;
declare variable V_MONTH integer;
declare variable V_YEAR integer;
declare variable V_STAGE_DATE_REAL date;
declare variable V_DAY integer;
begin
  /* Procedure Text */
  select c.ytcoef, c.otcoef, c.ctcoef, c.system_date from constants c into
    :coef_y_time, :coef_o_time, :coef_c_time, :sys_date;
  doc_date = CURRENT_DATE + CURRENT_TIME;
  out_date = doc_date;
  -- достаём ставки (они общие для всех)
  select cf.f_value from v_const_float cf where cf.f_code = 'Rate.Teacher' into :t_main_salary;
  select cf.f_value from v_const_float cf where cf.f_code = 'Rate.Concertmaster' into :t_concert_salary;

  insert into tariffication values (:doc_date, :in_info,
    :coef_y_time, :coef_o_time, :coef_c_time, :sys_date);

  for select T.id, T."Name", S."Name", P."Name", E."Name", T."Diploma",
    coalesce(T.stage_d, 0), coalesce(T.stage_m, 0), coalesce(T.stage_y, 0),
    T."EnterDate", T."StageDate"
    from "Teacher" T
      left join "Education" E on E.id = T."EducationID"
      left join "Post" P on P.id = T."PostID"
      left join "Subject" S on S.id = T."SubjectID"
    where T."ReleaseDate" is null
    group by T.id, T."Name", S."Name", P."Name", E."Name", T."Diploma",
      T.stage_d, T.stage_m, T.stage_y, T."EnterDate", T."StageDate"
    order by T."Name"
    into :t_id, :t_name, :t_subj_name, :t_post_name, :t_ed_name, :t_diploma,
      :t_stage_d, :t_stage_m, :t_stage_y, :t_enter_date, :t_stage_date
  do
  begin

    if (t_stage_date IS NOT NULL) then
    begin
        V_STAGE_DATE_REAL = addyear(addmonth(t_stage_date, -coalesce(t_stage_m, 0)), -coalesce(t_stage_y, 0));

        select
          datediff(month from :V_STAGE_DATE_REAL to cast(:doc_date as date))
        from rdb$database
        into :t_stage_m;
        t_stage_y = div(t_stage_m, 12);
        t_stage_m = mod(t_stage_m, 12);
        --v_day = CAST(doc_date AS DATE) - CAST(V_STAGE_DATE_REAL AS DATE);
        --v_month = mod(v_day, 365)/30;
        --v_year = div(v_day, 365);
        --t_stage_m = v_month;
        --t_stage_y = v_year;
    end

    select coalesce(outytime, 0), coalesce(outotime, 0), coalesce(outctime, 0),
      coalesce(outaddsum, 0)
    from proc_teacher_tm(:t_id, 0)
    into :b_y_time, :b_o_time, :b_c_time, :t_sum_addings;   /* бюджет */

    select coalesce(outytime, 0), coalesce(outotime, 0), coalesce(outctime, 0)
    from proc_teacher_tm(:t_id, 1)
    into :s_y_time, :s_o_time, :s_c_time;  /* самоокуп */

    if (not (coalesce(b_y_time, 0) + coalesce(b_o_time, 0) + coalesce(b_c_time, 0) +
      coalesce(s_y_time, 0) + coalesce(s_y_time, 0) + coalesce(s_y_time, 0) = 0)) then
    insert into tariffication_record (
      doc_date, teacher_id, t_name, t_subj, t_post, t_education, t_diploma,
      t_stage_d, t_stage_m, t_stage_y,
      t_main_salary, t_concert_salary,
      t_b_time_y, t_b_time_o, t_b_time_c,
      t_s_time_y, t_s_time_o, t_s_time_c,
      t_addings, t_enter_date, t_stage_date
    )
    values(
      :doc_date, :t_id, :t_name, :t_subj_name, :t_post_name, :t_ed_name, :t_diploma,
      :t_stage_d, :t_stage_m, :t_stage_y,
      :t_main_salary, :t_concert_salary,
      :b_y_time, :b_o_time, :b_c_time,
      :s_y_time, :s_o_time, :s_c_time,
      :t_sum_addings, :t_enter_date, :t_stage_date
    );
  end
end^


ALTER PROCEDURE PROC_PREPARE_GR_CURR (
    GROUPING_ID INTEGER)
RETURNS (
    CURRICULUM_ID INTEGER,
    CURR_REC_NUM INTEGER,
    SUBJECT_ID INTEGER,
    SUBJECT_NAME VARCHAR(30),
    SUBJECT_CODE INTEGER,
    SUBJECT_GROUP INTEGER,
    GROUPING_SUBJ_ID INTEGER)
AS
DECLARE VARIABLE CURR_ID INTEGER;
begin
  /* Procedure Text */ /*$$IBE$$ 
  for select distinct C.id
      from grouping G
        join grouping_dept GD on G.id = grouping_id and GD.grouping_id = grouping_id
        join "Department" D on D.id = GD.department_id
        join curriculum C on C.id = D."CurriculumID"
      order by C.id
      into :curr_id
  do

    for select CR.curr_id, CR.num, CR.subject_id, S."Name", S."Code", CR.group_qty, null
        from curr_rec CR join "Subject" S on S.id = CR.subject_id
        where CR.curr_id = :curr_id and CR.group_qty = 1
        order by CR.id
        into :curriculum_id, :curr_rec_num, :subject_id, :subject_name, :subject_code,
          :subject_group, :grouping_subj_id
    do suspend;

    for select null, null, S.id, S."Name", S."Code", GS.group_qty, GS.id
      from grouping G
      join grouping_subj GS on GS.grouping_id = :grouping_id and G.id = :grouping_id
      join "Subject" S on GS.subject_id = S.id
      into :curriculum_id, :curr_rec_num, :subject_id, :subject_name, :subject_code,
        :subject_group, :grouping_subj_id
    do suspend;
 $$IBE$$*/ EXIT;
end^


ALTER PROCEDURE PROC_STUDENT_PLAN (
    INID INTEGER,
    INSTUDENTID INTEGER,
    INSPECID INTEGER,
    INCLASSNUM INTEGER)
RETURNS (
    OUTID INTEGER,
    OUTTEACHERID INTEGER,
    OUTSUBJECTID INTEGER,
    OUTSUBJECT VARCHAR(30),
    OUTSUBJECTCODE INTEGER,
    OUTUSE INTEGER,
    OUTTIME DOUBLE PRECISION)
AS
begin
/*
    Процедура выдает план обучения для указанного студента (InStudentID),
    специализации (InSpecID) и номера класса
*/ /*$$IBE$$ 
  if (:instudentid = 0) then
  begin
    for SELECT DISTINCT CR.num, null, S.id, S."Name", S."Code", 0, CRT.c_time
      FROM "Specialization" SP
      join "Department" D on SP."ID" = :InSpecID and SP."DepartmentID" = D."ID"
      join curr_rec CR on CR.curr_id = D."CurriculumID"
      join curr_rec_time CRT on CRT.curr_id = CR.curr_id and
        CRT.curr_rec_id = CR.curr_id and CRT.class_num = :inclassnum
      join "Subject" S on S."ID" = CR.subject_id
      order by CR.Num
      INTO :OutID, :OutTeacherID, :OutSubjectID, :outsubject, :outsubjectcode, :OutUse, :OutTime do
      suspend;
  end
  else
    if (:InID <> 0) then
    begin
        SELECT DISTINCT STP."ID", STP."TeacherID", S.id, S."Name", S."Code", "Use", CRT.c_time
        FROM "Department" D
        join "Specialization" SP on SP."ID" = :InSpecID and SP."DepartmentID" = D."ID"
        join curr_rec CR on CR.curr_id = D."CurriculumID" and CR.Num = :inid
        join curr_rec_time CRT on CRT.curr_id = D."CurriculumID" and
          CRT.curr_rec_id = CR.id and CRT.class_num = :inclassnum
        join "Subject" S on S."ID" = CR.subject_id
        join "Student_Plan" STP on STP."StudentID" = :instudentid and STP."ID" = :inid
        INTO :OutID, :OutTeacherID, :OutSubjectID, :outsubject, :outsubjectcode, :OutUse, :OutTime;
        suspend;
    end
    else
    for SELECT DISTINCT STP."ID", STP."TeacherID", S.id, S."Name", S."Code", "Use", CRT.c_time
        FROM "Student_Plan" STP
        join "Department" D on STP."StudentID" = :instudentid
        join "Specialization" SP on SP."ID" = :InSpecID and SP."DepartmentID" = D."ID"
        join curr_rec CR on CR.curr_id = D."CurriculumID" and CR.Num = STP.id
        join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id and
          CRT.class_num = :inclassnum
        join "Subject" S on S."ID" = CR.subject_id
        INTO :OutID, :OutTeacherID, :OutSubjectID, :outsubject, :outsubjectcode, :OutUse, :OutTime
        do SUSPEND;
 $$IBE$$*/ EXIT;
end^


ALTER PROCEDURE PROC_TEACHER_GROUP (
    IN_GROUPING_ID INTEGER)
RETURNS (
    GROUPING_ID INTEGER,
    TEACHER_ID INTEGER,
    TEACHER VARCHAR(30),
    GR_QTY_0 INTEGER,
    GR_QTY_1 INTEGER,
    GR_QTY_2 INTEGER,
    GR_QTY_3 INTEGER,
    GR_QTY_4 INTEGER,
    GR_QTY_5 INTEGER,
    GR_QTY_6 INTEGER,
    GR_QTY_7 INTEGER,
    GR_QTY_8 INTEGER)
AS
begin
  grouping_id = in_grouping_id;
  for
    select T.id, T."Name",
      sum(case TG.class_num when 0 then TG.group_q else null end),
      sum(case TG.class_num when 1 then TG.group_q else null end),
      sum(case TG.class_num when 2 then TG.group_q else null end),
      sum(case TG.class_num when 3 then TG.group_q else null end),
      sum(case TG.class_num when 4 then TG.group_q else null end),
      sum(case TG.class_num when 5 then TG.group_q else null end),
      sum(case TG.class_num when 6 then TG.group_q else null end),
      sum(case TG.class_num when 7 then TG.group_q else null end),
      sum(case TG.class_num when 8 then TG.group_q else null end)
    from "Teacher" T join teacher_group TG on T.id = TG.teacher_id and
      TG.grouping_id = :grouping_id
    group by T.id, T."Name"
    into :teacher_id, :teacher, :gr_qty_0, :gr_qty_1, :gr_qty_2, :gr_qty_3,
      :gr_qty_4, :gr_qty_5, :gr_qty_6, :gr_qty_7, :gr_qty_8
  do SUSPEND;
  for
    select distinct T.id, T."Name", null, null, null, null, null, null, null, null, null
    from  "Student_Plan" STP
      join "Student" S on STP."StudentID" = S.id and
        S.released = 0 and S.academy = 0 and STP."Use" > 0
      join "Specialization" SP on SP.id = S."SpecializationID"
      join "Department" D on D.id = SP."DepartmentID"
      join curr_rec CR on D."CurriculumID" = CR.curr_id and CR.id = STP.curr_rec_id
      join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id
        and S."Class" = CRT.class_num and coalesce(CRT.c_time, 0) > 0
      join grouping G on G.id = :grouping_id and G.financing_id = S."FinancingID"
      join grouping_subj_curr_id GSCN on GSCN.grouping_id = G.id and
        GSCN.curr_id = D."CurriculumID" and GSCN.curr_rec_id = STP.curr_rec_id
      join "Teacher" T on T.id = STP."TeacherID"
    where T.id not in
      (select TG.teacher_id from teacher_group TG where TG.grouping_id = :grouping_id)
    into :teacher_id, :teacher, :gr_qty_0, :gr_qty_1, :gr_qty_2, :gr_qty_3,
      :gr_qty_4, :gr_qty_5, :gr_qty_6, :gr_qty_7, :gr_qty_8
  do suspend;
end^


ALTER PROCEDURE PROC_TEACHER_GROUP_CLS (
    GROUPING_ID INTEGER,
    GR_SUBJECT_ID INTEGER,
    CLASS_NUM INTEGER)
RETURNS (
    TEACHER_ID INTEGER,
    TEACHER VARCHAR(30),
    GR_QTY INTEGER,
    ST_QTY INTEGER)
AS
begin
  for
    select T."Name", T.id, coalesce(sum( case coalesce(CRT.c_time, 0) when 0 then 0 else 1 end), 0),
      TG.group_q
    from  "Student_Plan" STP
      join "Student" S on STP."StudentID" = S.id and S."Class" = :class_num and
        S.released = 0 and S.academy = 0 and STP."Use" > 0
      join "Specialization" SP on SP.id = S."SpecializationID"
      join "Department" D on D.id = SP."DepartmentID"
      join curr_rec CR on D."CurriculumID" = CR.curr_id and CR.id = STP.curr_rec_id
      join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id
        and S."Class" = CRT.class_num
      join grouping G on G.id = :grouping_id and G.financing_id = S."FinancingID"
      join grouping_subj_curr_id GSCN on GSCN.grouping_id = G.id and
        GSCN.curr_id = D."CurriculumID" and GSCN.curr_rec_id = STP.curr_rec_id and
        GSCN.grouping_subj_id = :gr_subject_id
      full join teacher_group TG on STP."TeacherID" = TG.teacher_id and
        TG.grouping_id = :grouping_id and TG.gr_subj_id = :gr_subject_id and
        TG.class_num = :class_num
      join "Teacher" T on (STP."TeacherID" = T.id or TG.teacher_id = T.id)
    where (TG.class_num = :class_num and TG.grouping_id = :grouping_id and
      TG.gr_subj_id = :gr_subject_id) or TG.teacher_id is null
    group by T.id, T."Name", TG.group_q
    into :teacher, :teacher_id, :st_qty, :gr_qty
    do
    begin
      if ((:st_qty > 0) or (:gr_qty > 0) ) then suspend;
      st_qty = 0;
      gr_qty = 0;
    end
end^


ALTER PROCEDURE PROC_TEACHER_GROUP_ST_QTY (
    IN_GROUPING_ID INTEGER,
    IN_TEACHER_ID INTEGER)
RETURNS (
    GROUPING_ID INTEGER,
    TEACHER_ID INTEGER,
    GR_SUBJ_ID INTEGER,
    SUBJECT_ID INTEGER,
    GROUP_QTY INTEGER,
    SUBJECT VARCHAR(30),
    SUBJ_CODE INTEGER,
    G_0 INTEGER,
    Q_0 INTEGER,
    G_1 INTEGER,
    Q_1 INTEGER,
    G_2 INTEGER,
    Q_2 INTEGER,
    G_3 INTEGER,
    Q_3 INTEGER,
    G_4 INTEGER,
    Q_4 INTEGER,
    G_5 INTEGER,
    Q_5 INTEGER,
    G_6 INTEGER,
    Q_6 INTEGER,
    G_7 INTEGER,
    Q_7 INTEGER,
    G_8 INTEGER,
    Q_8 INTEGER)
AS
begin /*$$IBE$$ 
for select
    G.ID,
    TG.teacher_id,
    GS.id,
    GS.subject_id,
    SBJ."Name",
    SBJ."Code",
    GS.group_qty,
    TG.group_0,
    coalesce(sum(case S."Class" when 0 then case coalesce(CR."Time0", 0) when 0 then 0 else 1 end else 0 end), 0),
    TG.group_1,
    coalesce(sum(case S."Class" when 1 then case coalesce(CR."Time1", 0) when 0 then 0 else 1 end else 0 end), 0),
    TG.group_2,
    coalesce(sum(case S."Class" when 2 then case coalesce(CR."Time2", 0) when 0 then 0 else 1 end else 0 end), 0),
    TG.group_3,
    coalesce(sum(case S."Class" when 3 then case coalesce(CR."Time3", 0) when 0 then 0 else 1 end else 0 end), 0),
    TG.group_4,
    coalesce(sum(case S."Class" when 4 then case coalesce(CR."Time4", 0) when 0 then 0 else 1 end else 0 end), 0),
    TG.group_5,
    coalesce(sum(case S."Class" when 5 then case coalesce(CR."Time5", 0) when 0 then 0 else 1 end else 0 end), 0),
    TG.group_6,
    coalesce(sum(case S."Class" when 6 then case coalesce(CR."Time6", 0) when 0 then 0 else 1 end else 0 end), 0),
    TG.group_7,
    coalesce(sum(case S."Class" when 7 then case coalesce(CR."Time7", 0) when 0 then 0 else 1 end else 0 end), 0),
    TG.group_8,
    coalesce(sum(case S."Class" when 8 then case coalesce(CR."Time8", 0) when 0 then 0 else 1 end else 0 end), 0)

  from grouping G
     join grouping_subj GS on G.id = :in_grouping_id and GS.grouping_id = :in_grouping_id
     join teacher_group TG on TG.grouping_id = :in_grouping_id and GS.id = TG.gr_subj_id and
       TG.teacher_id = :in_teacher_id
     join "Subject" SBJ on GS.subject_id = SBJ.id
     join "Student_Plan" STP on STP."TeacherID" = :in_teacher_id and STP."Use" > 0
     join "Student" S on STP."StudentID" = S.id and G.financing_id = S."FinancingID" and
       S."ReleaseDate" is null and (S."AcademyBDate" is null or S."AcademyEDate" is not null)
     join "Specialization" SP on SP.id = S."SpecializationID"
     join "Department" D on D.id = SP."DepartmentID"
     left join "Curriculum_Record" CR on D."CurriculumID" = CR."CurriculumID" and CR."Num" = STP.id and
       CR."CurriculumID" in
       (select GSCN.curriculum_id from grouping_subj_curr_num GSCN where GSCN.grouping_id = :in_grouping_id and
         GSCN.grouping_subj_id = GS.id and GSCN.curr_rec_num = STP.id)
  group by
    G.ID,
    TG.teacher_id,
    GS.id,
    GS.subject_id,
    SBJ."Name",
    SBJ."Code",
    GS.group_qty,
    TG.group_0, TG.group_1, TG.group_2, TG.group_3, TG.group_4, TG.group_5, TG.group_6, TG.group_7, TG.group_8
  order by GS.id
  into :grouping_id, :teacher_id, :gr_subj_id, :subject_id, :subject, :subj_code, :group_qty,
    :g_0, :q_0, :g_1, :q_1, :g_2, :q_2, :g_3, :q_3, :g_4, :q_4, :g_5, :q_5, :g_6, :q_6, :g_7, :q_7,
    :g_8, :q_8
  do
    suspend;
 $$IBE$$*/ EXIT;
end^


ALTER PROCEDURE PROC_TEACHER_REPORT (
    ID_TEACHER INTEGER,
    ID_DEPARTMENT INTEGER)
RETURNS (
    NAME_SUBJECT VARCHAR(150),
    CLASS_NUMBER INTEGER,
    PERIOD INTEGER,
    QTY_Y INTEGER,
    QTY_O INTEGER,
    TIME_Y DOUBLE PRECISION,
    TIME_O DOUBLE PRECISION,
    TIME_C DOUBLE PRECISION)
AS
begin
/*
{
      'select distinct GS.name, TG.class_num, C.period, ' + //--TG.group_q, CRT.c_time*TG.group_q ' +
' CASE WHEN cc.category = 0 THEN TG.group_q ELSE NULL END, ' +
' CASE WHEN cc.category = 1 THEN TG.group_q ELSE NULL END, ' +
' CASE WHEN cc.category = 0 AND gs.code = 0 THEN CRT.c_time*TG.group_q ELSE NULL END, ' +
' CASE WHEN cc.category = 1 AND gs.code = 0 THEN CRT.c_time*TG.group_q ELSE NULL END, ' +
' CASE WHEN gs.code != 0 THEN CRT.c_time*TG.group_q ELSE NULL END ' +
      'from teacher_group TG ' +
      'join grouping_subj GS on TG.grouping_id = GS.grouping_id and ' +
      '  GS.ID = TG.gr_subj_id ' +
      'join grouping_subj_curr_id GSCI on ' +
      '  GSCI.grouping_id = TG.grouping_id and ' +
      '  GSCI.grouping_subj_id = TG.gr_subj_id ' +
      'join grouping_dept GD on TG.grouping_id = GD.grouping_id ' +
      'join "Department" D on D.id = GD.department_id ' +
      'join curriculum C on C.id = D."CurriculumID" and ' +
      '  GSCI.curr_id = C.id ' +
      'join curr_rec_time CRT on CRT.curr_id = C.id and ' +
      '  CRT.curr_rec_id = GSCI.curr_rec_id and ' +
      '  CRT.class_num = TG.class_num ' +
      ' LEFT JOIN curr_cat cc ON cc.curr_id = GSCI.curr_id AND cc.class_num = crt.class_num ' +
      'where TG.teacher_id = :t_id and ' +
      '  D.id = :dept_id and  ' +
      '  D.id in ' +
      ' (select min(D1.id) ' +
      '  from grouping_dept GD1 ' +
      '    join grouping_subj_curr_id GSCI1 on ' +
      '      GSCI1.grouping_id = TG.grouping_id and ' +
      '      GSCI1.grouping_subj_id = TG.gr_subj_id and ' +
      '      GD1.grouping_id = TG.grouping_id ' +
      '    join "Department" D1 on ' +
      '      GD1.department_id = D1.id and ' +
      '      D1."CurriculumID" = GSCI1.curr_id ' +
      '  where D1.id in (' + DeptIDs.DelimitedText + ')) ' +
      'order by TG.grouping_id, GS.id;'
}

*/



  FOR
    SELECT gs.name, vtgt.class_num, c.period,
      vtgt.qty_y, vtgt.qty_o,
      vtgt.time_y, vtgt.time_o, vtgt.time_c
    FROM "Department" d
      LEFT JOIN curriculum c ON
        d."CurriculumID" = c.id
      LEFT JOIN grouping_subj_curr_id gsci ON
        gsci.curr_id = c.id
      LEFT JOIN grouping_subj gs ON
        gs.grouping_id = gsci.grouping_id AND
        gs.id = gsci.grouping_subj_id
      LEFT JOIN v_teacher_group_time vtgt ON
        vtgt.id_grouping = gsci.grouping_id AND
        vtgt.id_grouping_subj = gsci.grouping_subj_id
    WHERE vtgt.id_teacher = :id_teacher AND d.id = :id_department
    INTO :name_subject, :class_number, :period, :qty_o, :qty_y, :time_y, :time_o, :time_c
  DO

    suspend;
end^


ALTER PROCEDURE PROC_TEACHER_TM (
    INTEACHERID INTEGER,
    INFINANCING INTEGER)
RETURNS (
    OUTYTIME DOUBLE PRECISION,
    OUTOTIME DOUBLE PRECISION,
    OUTCTIME DOUBLE PRECISION,
    OUTYPAY DOUBLE PRECISION,
    OUTOPAY DOUBLE PRECISION,
    OUTCPAY DOUBLE PRECISION,
    OUTSUMTIME DOUBLE PRECISION,
    OUTSUMPAY DOUBLE PRECISION,
    OUTADDSUM DOUBLE PRECISION)
AS
declare variable TMPTIME double precision;
declare variable TMPMAINSALARY double precision;
declare variable TMPCONCSALARY double precision;
declare variable YCOEF double precision;
declare variable OCOEF double precision;
declare variable CCOEF double precision;
declare variable PSUM double precision;
declare variable MSUM double precision;
declare variable OGROUP double precision;
declare variable YGROUP double precision;
declare variable CGROUP double precision;
begin
  /* подсчет времени работы и оплаты преподавателей */
  outytime = 0;
  /* для групп из 1 человека (не групповые часы)*/
  select
    -- концертмейст.
    sum(case SBJ."Code" when 1 then CRT.c_time else null end),
    -- преп. старш. категория
    sum(case SBJ."Code" when 1 then null else CRT.c_time*CC.category end),
    -- преп. младш. категория
    sum(case SBJ."Code" when 1 then null else (case CC.category when 0 then CRT.c_time else null end) end),
    -- преп. итого
    sum(case SBJ."Code" when 1 then null else CRT.c_time end)
  from "Student_Plan" STP
    join "Student" S on STP."Use" > 0 and
      S.id = STP."StudentID" and S."FinancingID" = :infinancing and
      S.released = 0 and S.academy = 0 and STP."TeacherID" = :inteacherid
    join "Specialization" SP on SP.id = S."SpecializationID"
    join "Department" D on D.id = SP."DepartmentID"
    join curr_cat CC on CC.curr_id = D."CurriculumID" and CC.class_num = S."Class"
    join curr_rec CR on CR.curr_id = D."CurriculumID" and CR.id = STP.curr_rec_id and CR.group_qty = 1 /* 1 человек */
    join curr_rec_time CRT on CRT.curr_id = CR.curr_id and CRT.curr_rec_id = CR.id and
      S."Class" = CRT.class_num and CRT.c_time > 0
    join "Subject" SBJ on SBJ.id = CR.subject_id
    join "Teacher" T on T."ID" = :inteacherid and T."ReleaseDate" is null
  into :outctime, :outotime, :outytime, :tmptime;

  -- групповые часы не концертмейстерские
  select
    -- преп. старш. часы
    sum(TG.group_q*CC.category*CRT.c_time),
    -- преп. младш. часы
    sum(case CC.category when 0 then TG.group_q*CRT.c_time else null end)
  from grouping G join teacher_group TG on G.id = TG.grouping_id and
      G.financing_id = :infinancing and TG.teacher_id = :inteacherid
    join "Teacher" T on TG.teacher_id = T.id and T."ReleaseDate" is null
    join grouping_subj_curr_id GSCN on TG.grouping_id = GSCN.grouping_id and
      TG.gr_subj_id = GSCN.grouping_subj_id
    join grouping_subj GS on GS.grouping_id = TG.grouping_id and TG.gr_subj_id = GS.id and GS.code <> 1 -- не концертм.
    join curr_cat CC on CC.curr_id = GSCN.curr_id and CC.class_num = tg.class_num
    join curr_rec_time CRT on CRT.curr_id = CC.curr_id and CRT.curr_rec_id = GSCN.curr_rec_id and
      CRT.class_num = CC.class_num and CRT.c_time > 0
  where CC.curr_id in
    (select min(GSCN1.curr_id) from grouping_subj_curr_id GSCN1
     where GSCN1.grouping_id = GSCN.grouping_id and
           GSCN1.grouping_subj_id = GSCN.grouping_subj_id)
  into :ogroup, :ygroup;

  -- групповые часы концертмейстерские
  select sum(TG.group_q*CRT.c_time)
  from grouping G
    join teacher_group TG on G.id = TG.grouping_id and
      G.financing_id = :infinancing and TG.teacher_id = :inteacherid
    join "Teacher" T on TG.teacher_id = T.id and T."ReleaseDate" is null
    join grouping_subj_curr_id GSCN on TG.grouping_id = GSCN.grouping_id and
      TG.gr_subj_id = GSCN.grouping_subj_id
    join grouping_subj GS on GS.grouping_id = TG.grouping_id and TG.gr_subj_id = GS.id and GS.code = 1 -- т.е. концертм.
    join curr_cat CC on CC.curr_id = GSCN.curr_id and CC.class_num = tg.class_num
    join curr_rec_time CRT on CRT.curr_id = CC.curr_id and CRT.curr_rec_id = GSCN.curr_rec_id and
      CRT.class_num = CC.class_num and CRT.c_time > 0
  where CC.curr_id in (select min(GSCN1.curr_id) from grouping_subj_curr_id GSCN1
     where GSCN1.grouping_id = GSCN.grouping_id and
           GSCN1.grouping_subj_id = GSCN.grouping_subj_id)
  into :cgroup;

  outotime = coalesce(outotime, 0) + coalesce(ogroup, 0);
  outytime = coalesce(outytime, 0) + coalesce(ygroup, 0);
  outctime = coalesce(outctime, 0) + coalesce(cgroup, 0);
  if (outotime = 0) then outotime = null;
  if (outytime = 0) then outytime = null;
  if (outctime = 0) then outctime = null;

  -- получаем тарифные ставки
  select c.f_value from v_const_float c where c.f_code = 'Rate.Teacher'       into :tmpmainsalary; -- преподавательская
  select c.f_value from v_const_float c where c.f_code = 'Rate.Concertmaster' into :tmpconcsalary; -- концертмейстерская

  select distinct ytcoef, otcoef, ctcoef from constants into :ycoef, :ocoef, :ccoef;
  outypay = cast(trunc(tmpmainsalary / ycoef * outytime, 2) as numeric(10, 2));
  outopay = cast(trunc(tmpmainsalary / ocoef * outotime, 2) as numeric(10, 2));
  outcpay = cast(trunc(tmpconcsalary / ccoef * outctime, 2) as numeric(10, 2));
  outsumtime = coalesce(outytime, 0) + coalesce(outotime, 0) + coalesce(outctime, 0);
  outsumpay = coalesce(outypay, 0) + coalesce(outopay, 0) + coalesce(outcpay, 0);
  if (outsumtime = 0) then outsumtime = null;
  if (outsumpay = 0) then outsumpay = null;

  select sum(TA."Percent"/100 * :tmpmainsalary), sum(TA."Sum")
  from "Teacher_Addings" TA join "Teacher" T on
    TA."TeacherID" = :inteacherid and T."ID" = :inteacherid
  where T."ReleaseDate" is null
  into :psum, :msum;
  if (:psum is null) then psum = 0;
  if (:msum is null) then msum = 0;
  outaddsum = psum + msum;
  if (outaddsum = 0) then outaddsum = null;

  suspend;
end^


ALTER PROCEDURE TABLE_BOOKMARK_D (
    TABLE_NAME VARCHAR(50))
AS
BEGIN
  DELETE FROM TABLE_BOOKMARK
  WHERE (TABLE_NAME = :TABLE_NAME);
END^


ALTER PROCEDURE TABLE_BOOKMARK_IU (
    TABLE_NAME VARCHAR(50),
    BOOKMARK VARCHAR(50))
AS
BEGIN
  IF (EXISTS(SELECT TABLE_NAME FROM TABLE_BOOKMARK WHERE (TABLE_NAME = :TABLE_NAME))) THEN
    UPDATE TABLE_BOOKMARK
    SET BOOKMARK = :BOOKMARK
    WHERE (TABLE_NAME = :TABLE_NAME);
  ELSE
    INSERT INTO TABLE_BOOKMARK (
        TABLE_NAME,
        BOOKMARK)
    VALUES (
        :TABLE_NAME,
        :BOOKMARK);
END^


ALTER PROCEDURE TEACHER_ABSENT_CODES (
    TEACHER_ID INTEGER,
    THE_DAY DATE)
RETURNS (
    CODE VARCHAR(150))
AS
declare variable tmp_code varchar(5) character set win1251;
begin
  code = '';
  for
    select a.code
    from teacher_absent ta
      left join absent_type a on a.id = ta.absent_type_id
    where ta.teacher_id = :teacher_id and ta.absent_date = :the_day
    into :tmp_code
  do
  begin
    if (code != '') then
      code = :code || :tmp_code;
    else
      code = :code || ' ' || :tmp_code;
  end
  suspend;
end^


ALTER PROCEDURE TEACHER_ABSENT_DATA_EDIT (
    TEACHER_ID INTEGER,
    COMMENTS VARCHAR(256))
AS
declare variable v_mon      date;
declare variable v_is_exist integer;
begin
  select c.system_date
  from constants c
  into :v_mon;

  v_mon = v_mon - extract(day from v_mon) + 1;
  select count(1)
  from teacher_absent_month_data d
  where d.teacher_id = :teacher_id
    and d.mon = :v_mon
  into :v_is_exist;

  if (v_is_exist = 1) then
  begin
    update teacher_absent_month_data d
    set d.comments = :comments
    where d.teacher_id = :teacher_id
      and d.mon        = :v_mon;
  end
  else
  begin
    insert into teacher_absent_month_data (teacher_id, mon, comments)
    values (:teacher_id, :v_mon, :comments);
  end
end^


ALTER PROCEDURE TEACHER_ABSENTS_CLEAR (
    TEACHER_ID INTEGER)
AS
begin
  delete from teacher_absent ta
  where ta.teacher_id = :teacher_id;
end^


ALTER PROCEDURE TEACHER_ABSENTS_EDIT (
    TEACHER_ID INTEGER,
    DATE_FROM DATE,
    DATE_TO DATE,
    ABSENTS VARCHAR(256))
AS
declare variable v_id integer;
declare variable v_date date;
begin
  delete from teacher_absent ta
  where ta.teacher_id = :teacher_id
    and ta.absent_date between :date_from and :date_to;
  for
    select t.id
    from absent_type t
    where t.is_calendar_type is null
      and position(',' || t.id || ',' in ',' || :absents ||  ',') > 0
    into :v_id
  do
  begin
    v_date = date_from;
    while (v_date <= date_to) do
    begin
      insert into teacher_absent (teacher_id, absent_date, absent_type_id)
      values (:teacher_id, :v_date, :v_id);
      v_date = v_date + 1;
    end
  end
end^


ALTER PROCEDURE TEACHER_CAT_EDIT (
    P_ID INTEGER,
    P_ID_TEACHER INTEGER,
    P_ID_CAT_KIND INTEGER,
    P_DATE_BEGIN DATE)
RETURNS (
    OUT_ID INTEGER)
AS
begin
  if (p_id is null) then
  begin
    p_id = Gen_ID(gen_teacher_cat_id, 1);
    INSERT INTO teacher_cat(f_id, f_id_teacher, f_id_cat_kind, f_date_begin)
    VALUES (:p_id, :p_id_teacher, :p_id_cat_kind, :p_date_begin);
  end
  else begin
    UPDATE teacher_cat tc
    SET
      tc.f_id_teacher = :p_id_teacher,
      tc.f_id_cat_kind = :p_id_cat_kind,
      tc.f_date_begin = :p_date_begin
    WHERE tc.f_id = :p_id;
  end
  out_id = p_id;
end^


ALTER PROCEDURE TT_ADD (
    P_ID_TEACHER INTEGER,
    P_ID_KIND INTEGER,
    P_DATE DATE,
    P_SERIES_NUMBER VARCHAR(3000))
RETURNS (
    ID INTEGER)
AS
begin
  ID = Gen_ID(gen_teacher_title_id, 1);
  INSERT INTO teacher_title (f_id, f_id_teacher, f_id_kind, f_date, f_series_number)
  VALUES (:id, :p_id_teacher, :p_id_kind, :p_date, :p_series_number);
end^


ALTER PROCEDURE UPDATE_CURR_REC_NUMS
AS
  declare variable num     INTEGER_TYPE;
  declare variable curr_id ID_TYPE;
  declare variable rec_id ID_TYPE;
begin
  for
    select c.id
    from curriculum c
    order by c.id
    into curr_id
  do
  begin
    num = 1;
    for
      select cr.id
      from curr_rec cr
      where cr.curr_id = :curr_id
      order by cr.num
      into rec_id
    do
    begin
      update curr_rec cr
      set cr.num = :num
      where cr.id = :rec_id and cr.curr_id = :curr_id;
      num = num + 1;
    end
  end
end^



SET TERM ; ^


/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE TABLE ABSENT_TYPE
'Тип отсутсвия';

DESCRIBE TABLE CALC_GROUP
'Расчёт групповых часов';

DESCRIBE TABLE CALC_GROUP_CLASS_DETAIL
'Детальная информация по групповому расчёту';

DESCRIBE TABLE CALC_GROUP_SUBJECT
'Групповой предмет расчёта';

DESCRIBE TABLE CALC_INDIVIDUAL
'Расчёт индивидуальных часов';

DESCRIBE TABLE CALC_INDIVIDUAL_CLASS_DETAIL
'Детальная информация по индивидуальному предмету расчёта';

DESCRIBE TABLE CALC_INDIVIDUAL_SUBJECT
'Предмет пакета индивидуального расчёта часов';

DESCRIBE TABLE CALC_IND_SUBJ_CLASS_DETAIL
'Детальная информация предмета по классам';

DESCRIBE TABLE CALC_PACK
'Пакет расчёта часов';

DESCRIBE TABLE CURR_CAT
'таблица категорий учебных планов';

DESCRIBE TABLE CURR_REC
'запись уч. плана';

DESCRIBE TABLE CURR_REC_TIME
'время записи уч. плана';

DESCRIBE TABLE GROUPING
'Таблица, необходимая для составления списков отделений для расчета групп.
Name - наименование классификатора.';

DESCRIBE TABLE GROUPING_DEPT
'Таблица, необходимая для составления списков отделений для расчета групп.
В данной таблице хранится список ID отделений.';

DESCRIBE TABLE LEARN_TIME_GRID
'Сетка учебных часов';

DESCRIBE TABLE LTG_GROUPING
'Совокупности в сетке учебных часов';

DESCRIBE TABLE LTG_I_SUBJECT
'Индивидуальные предметы сетки учебных часов';

DESCRIBE TABLE LTG_I_SUBJ_CURR
'Ссылки индивидуальных предметов на соответствующие в учебных планах';

DESCRIBE TABLE MAIN_TAB
'Основной табель';

DESCRIBE TABLE STUDENT_FILTER_SPEC
'деталь фильтра студента по специализациям';

DESCRIBE TABLE TEACHER_ABSENT
'Отсутствие преподавателя на дату и тип отсутсвия';

DESCRIBE TABLE TEACHER_CAT
'Категории преподавателя';

DESCRIBE TABLE TEACHER_GROUP
'Таблица количества групп для преподавателя по предметам.';

DESCRIBE TABLE TEACHER_NOTE
'Примечания преподавателей';

DESCRIBE TABLE TEACHER_TITLE
'Почётные звания преподавателей';



/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/



/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE PROCEDURE CGS_ADD
'Добавление предмета в групповой расчёт';

DESCRIBE PROCEDURE CGS_NAME_CHANGE
'Изменить имя предмета';

DESCRIBE PROCEDURE CG_ADD
'Добавление группового расчёта';

DESCRIBE PROCEDURE CICD_DELETE
'Удалить деталь по классу';

DESCRIBE PROCEDURE CIS_ADD
'Добавление предмета в индивидуальный расчёт';

DESCRIBE PROCEDURE CIS_NAME_CHANGE
'Изменить имя предмета';

DESCRIBE PROCEDURE PROC_CALC_TEACHER_GROUP
'Автоматический расчет группы для конкретного препадавателя';

DESCRIBE PROCEDURE PROC_EXTRACT_ALL_GROUP
'Выполнение необходимых инициализирующих действий над группами всех классификаторов
в том числе удаление требуемых преподавателей и добавление новых.';

DESCRIBE PROCEDURE PROC_EXTRACT_GR_SUBJECTS
'Обновление списка групповых предметов для определенного классификатора';

DESCRIBE PROCEDURE PROC_FOR_STUDENT_FILTER
'Используется для сложной фильтрации студентов
по предметам и преподавателям';

DESCRIBE PROCEDURE PROC_MAIN_TAB
'Расчет главного табеля';

DESCRIBE PROCEDURE PROC_NEW_TARIFFICATION
'Формирует тарификационную ведомость';



/******************************************************************************/
/***                          Fields descriptions                           ***/
/******************************************************************************/

DESCRIBE FIELD ID TABLE CALC_GROUP
'Ай-ди расчёта';

DESCRIBE FIELD ID_CALC_PACK TABLE CALC_GROUP
'Ссылка на пакет расчёта';

DESCRIBE FIELD NAME TABLE CALC_GROUP
'Наименование рассчёта групп';

DESCRIBE FIELD HEADER TABLE CALC_GROUP
'Заголовок отчёта';

DESCRIBE FIELD FOOTER TABLE CALC_GROUP
'Подвал отчёта';

DESCRIBE FIELD SHOW_POSITION TABLE CALC_GROUP
'Позиция отображения/печати';

DESCRIBE FIELD CLASS_NUMBER TABLE CALC_GROUP_CLASS_DETAIL
'Номер класса';

DESCRIBE FIELD ID_CALC_GROUP TABLE CALC_GROUP_CLASS_DETAIL
'Ссылка на групповой расчёт';

DESCRIBE FIELD ID_CALC_PACK TABLE CALC_GROUP_CLASS_DETAIL
'Ссылка на пакет';

DESCRIBE FIELD CATEGORY TABLE CALC_GROUP_CLASS_DETAIL
'Категория';

DESCRIBE FIELD QTY_STUDENT TABLE CALC_GROUP_CLASS_DETAIL
'Кол-во студентов';

DESCRIBE FIELD ID TABLE CALC_GROUP_SUBJECT
'Ай ди групового предмета';

DESCRIBE FIELD ID_CALC_GROUP TABLE CALC_GROUP_SUBJECT
'Ай ди расчёта групп';

DESCRIBE FIELD ID_CALC_PACK TABLE CALC_GROUP_SUBJECT
'Ай ди пачки расчёта ';

DESCRIBE FIELD NAME TABLE CALC_GROUP_SUBJECT
'Наименования предмета';

DESCRIBE FIELD ID_GROUPING TABLE CALC_GROUP_SUBJECT
'Ай ди группировки';

DESCRIBE FIELD SHOW_POSITION TABLE CALC_GROUP_SUBJECT
'Позиция отображения';

DESCRIBE FIELD IS_CONCERTMASTER TABLE CALC_GROUP_SUBJECT
'Это концертмейстер?';

DESCRIBE FIELD ID_GROUPING_SUBJ TABLE CALC_GROUP_SUBJECT
'Ай ди предмета группировки';

DESCRIBE FIELD CLASS_NUMBER TABLE CALC_GROUP_SUBJECT_CLASS_DETAIL
'Номер класса';

DESCRIBE FIELD ID_CALC_GROUP_SUBJECT TABLE CALC_GROUP_SUBJECT_CLASS_DETAIL
'Ссылка на предмет расчёта групп';

DESCRIBE FIELD ID_CALC_GROUP TABLE CALC_GROUP_SUBJECT_CLASS_DETAIL
'Ссылка на расчёт групп';

DESCRIBE FIELD ID_CALC_PACK TABLE CALC_GROUP_SUBJECT_CLASS_DETAIL
'Ссылка на пачку';

DESCRIBE FIELD CLOCK_CURR TABLE CALC_GROUP_SUBJECT_CLASS_DETAIL
'Часы по учебному плану.';

DESCRIBE FIELD QTY_FACT TABLE CALC_GROUP_SUBJECT_CLASS_DETAIL
'Кол-во гупп фактически';

DESCRIBE FIELD ID TABLE CALC_INDIVIDUAL
'Ай ди индивидуального расчёта';

DESCRIBE FIELD ID_CALC_PACK TABLE CALC_INDIVIDUAL
'Ссылка на пакет расчёта';

DESCRIBE FIELD NAME TABLE CALC_INDIVIDUAL
'Наименование индивидуального расчёта';

DESCRIBE FIELD HEADER TABLE CALC_INDIVIDUAL
'Заголовок отчёта';

DESCRIBE FIELD FOOTER TABLE CALC_INDIVIDUAL
'Подвал отчёта';

DESCRIBE FIELD SHOW_POSITION TABLE CALC_INDIVIDUAL
'Позиция отображения/печати';

DESCRIBE FIELD CLASS_NUMBER TABLE CALC_INDIVIDUAL_CLASS_DETAIL
'№ класса';

DESCRIBE FIELD ID_CALC_INDIVIDUAL TABLE CALC_INDIVIDUAL_CLASS_DETAIL
'Ссылка на индивидуальный расчёт';

DESCRIBE FIELD ID_CALC_PACK TABLE CALC_INDIVIDUAL_CLASS_DETAIL
'Ссылка на пакет расчёта';

DESCRIBE FIELD CATEGORY TABLE CALC_INDIVIDUAL_CLASS_DETAIL
'Категория класса';

DESCRIBE FIELD QTY_STUDENT TABLE CALC_INDIVIDUAL_CLASS_DETAIL
'Кол-во студентов в классе';

DESCRIBE FIELD NAME TABLE CALC_INDIVIDUAL_SUBJECT
'Наименование предмета';

DESCRIBE FIELD ID_DEPARTMENT TABLE CALC_INDIVIDUAL_SUBJECT
'Ссылка на отделение';

DESCRIBE FIELD ID_CURR_REC TABLE CALC_INDIVIDUAL_SUBJECT
'Ссылка на предмет уч. плана';

DESCRIBE FIELD ID_CURRICULUM TABLE CALC_INDIVIDUAL_SUBJECT
'Ссылка на уч. план';

DESCRIBE FIELD IS_CONCERTMASTER TABLE CALC_INDIVIDUAL_SUBJECT
'Это концертмейстер';

DESCRIBE FIELD CLASS_NUMBER TABLE CALC_IND_SUBJ_CLASS_DETAIL
'№ класса';

DESCRIBE FIELD ID_CALC_INDIVIDUAL_SUBJECT TABLE CALC_IND_SUBJ_CLASS_DETAIL
'Ссылка на индивидуальный предмет';

DESCRIBE FIELD ID_CALC_INDIVIDUAL TABLE CALC_IND_SUBJ_CLASS_DETAIL
'Ссылка на индивидуальный расчёт';

DESCRIBE FIELD ID_CALC_PACK TABLE CALC_IND_SUBJ_CLASS_DETAIL
'Ссылка на пакет расчёта';

DESCRIBE FIELD CLOCK_CURRICULUM TABLE CALC_IND_SUBJ_CLASS_DETAIL
'Часы по учебному плану';

DESCRIBE FIELD QTY_FACT TABLE CALC_IND_SUBJ_CLASS_DETAIL
'Кол-во студентов по факту';

DESCRIBE FIELD ID TABLE CALC_PACK
'Ай ди пакета';

DESCRIBE FIELD NAME TABLE CALC_PACK
'Наименование пакета расчёта';

DESCRIBE FIELD F_ID TABLE SEX
'Пол';

DESCRIBE FIELD F_ID TABLE TEACHER_CAT
'Айди';

DESCRIBE FIELD F_ID_TEACHER TABLE TEACHER_CAT
'Ссылка на преподавателя';

DESCRIBE FIELD F_ID_CAT_KIND TABLE TEACHER_CAT
'Ссылка на справочник';

DESCRIBE FIELD F_ID TABLE TEACHER_TITLE
'Айди';

DESCRIBE FIELD F_ID_TEACHER TABLE TEACHER_TITLE
'Ссылка на преподавателя';

DESCRIBE FIELD F_ID_KIND TABLE TEACHER_TITLE
'Ссылка на тип';

DESCRIBE FIELD F_DATE TABLE TEACHER_TITLE
'Дата присвоения';

DESCRIBE FIELD F_NAME TABLE TEACHER_TITLE_KIND
'Типы званий преподавателей';

